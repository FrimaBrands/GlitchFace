
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unknown // Remote Host (Demo Shell)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .control-group { backdrop-filter: blur(6px); }
    canvas { background:#000; }
  </style>
</head>
<body class="bg-zinc-900 text-zinc-100">
  <div class="max-w-6xl mx-auto p-4 grid grid-cols-12 gap-4">
    <div class="col-span-9">
      <!-- Replace this with your real canvas -->
      <canvas id="glcanvas" width="1280" height="720" class="w-full rounded-xl shadow-lg"></canvas>
    </div>
    <div class="col-span-3 space-y-4">
      <!-- REMOTE CONTROL (v2) -->
      <div class="control-group bg-black/50 border border-gray-800 rounded-lg p-3">
        <h3 class="font-semibold text-gray-200 mb-3">REMOTE</h3>
        <p class="text-xs text-gray-400 mb-2">Visitors can scan the QR to trigger a 5s canvas-only recording. Queue handled automatically.</p>
        <div class="space-y-3">
          <label class="flex items-center justify-between text-sm">
            <span class="text-gray-400">Enable remote trigger (armed)</span>
            <input type="checkbox" id="remoteEnable" class="form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0">
          </label>
          <div class="grid grid-cols-2 gap-2">
            <button id="remoteShowQR" class="bg-emerald-500 hover:bg-emerald-600 text-black font-semibold py-2 rounded text-sm transition-colors" disabled>Open QR Window</button>
            <button id="remoteReset" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 rounded text-sm transition-colors" disabled>Revoke / Reset</button>
          </div>
          <div id="remoteStatus" class="text-xs font-mono text-green-400">REMOTE: idle</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // simple animation so there's something to record
    const c = document.getElementById('glcanvas');
    const ctx = c.getContext('2d');
    let t=0; function loop(){ t+=0.02; ctx.fillStyle='#000'; ctx.fillRect(0,0,c.width,c.height);
      for(let i=0;i<200;i++){ ctx.fillStyle='hsl('+((i*7+t*80)%360)+',80%,60%)'; ctx.fillRect(640+Math.sin(t+i)*400, 360+Math.cos(t*1.4+i)*200, 8, 8); }
      requestAnimationFrame(loop);
    } loop();
  </script>

  <!-- Remote Trigger Module v2 -->
  <script>
  (() => {
    const els = {
      enable: document.getElementById('remoteEnable'),
      showQR: document.getElementById('remoteShowQR'),
      reset: document.getElementById('remoteReset'),
      status: document.getElementById('remoteStatus'),
      canvas: document.getElementById('glcanvas')
    };
    if (!els.enable || !els.canvas) return;

    let peer = null;
    const conns = new Set();
    let armed = false;
    let isBusy = false;
    let lastJobAt = 0;
    const JOB_COOLDOWN_MS = 1500;
    const queue = [];
    let qrWin = null;
    let currentPeerId = null;

    const PEERJS_URL = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
    const QR_URL = 'remote-qr.html';
    const PHONE_URL = 'phone.html';

    function setStatus(text, good=true) {
      if (!els.status) return;
      els.status.textContent = `REMOTE: ${text}`;
      els.status.classList.toggle('text-red-400', !good);
      els.status.classList.toggle('text-green-400', good);
    }

    function lazyLoadPeerJS() {
      return new Promise((resolve, reject) => {
        if (window.Peer) return resolve();
        const s = document.createElement('script');
        s.src = PEERJS_URL; s.crossOrigin = 'anonymous';
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('Failed to load PeerJS'));
        document.body.appendChild(s);
      });
    }

    async function armRemote() {
      await lazyLoadPeerJS();
      peer = new window.Peer(undefined, { debug: 1 });
      peer.on('open', id => {
        currentPeerId = id;
        setStatus(`armed @ ${id.slice(0,6)}… ready`);
        els.showQR.disabled = false;
        els.reset.disabled = false;
        if (qrWin && !qrWin.closed) {
          qrWin.postMessage({ type:'setTarget', url: buildPhoneURL(id).toString() }, '*');
        }
      });
      peer.on('connection', (c) => {
        conns.add(c);
        c.on('data', (msg) => onMessage(c, msg));
        c.on('close', () => conns.delete(c));
        c.on('error', () => conns.delete(c));
        c.on('open', () => { try { c.send(JSON.stringify({ type:'helloAck', ok:true })); } catch(e){} });
      });
      peer.on('disconnected', () => setStatus('peer disconnected; reconnecting…', false));
      peer.on('error', (e) => { console.error(e); setStatus('peer error', false); });
      armed = true;
    }

    function disarmRemote() {
      armed = false;
      try { conns.forEach(c => c.close()); } catch {}
      conns.clear();
      try { if (peer) peer.destroy(); } catch {}
      peer = null;
      isBusy = false;
      queue.length = 0;
      els.showQR.disabled = true;
      els.reset.disabled = true;
      setStatus('idle');
    }

    function buildPhoneURL(peerId) {
      const url = new URL(PHONE_URL, location.href);
      url.searchParams.set('host', peerId);
      return url;
    }

    function openQRWindow() {
      const target = buildPhoneURL(currentPeerId || 'pending').toString();
      if (qrWin && !qrWin.closed) {
        qrWin.postMessage({ type:'setTarget', url: target }, '*');
        qrWin.focus();
        return;
      }
      const qrUrl = new URL(QR_URL, location.href);
      qrUrl.searchParams.set('target', target);
      qrWin = window.open(qrUrl.toString(), '_blank', 'noopener,noreferrer,width=520,height=600');
    }

    async function recordCanvas(durationMs, preferMp4=false) {
      const canvas = els.canvas;
      if (!canvas || !canvas.captureStream) throw new Error('Canvas captureStream not supported');
      const stream = canvas.captureStream(30);
      const chunks = [];
      const optionsList = [
        { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2_000_000 },
        { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2_000_000 },
        { mimeType: 'video/webm', videoBitsPerSecond: 2_000_000 },
      ];
      if (preferMp4) optionsList.unshift({ mimeType: 'video/mp4;codecs=h264', videoBitsPerSecond: 2_000_000 });

      let rec = null;
      for (const opt of optionsList) {
        try { rec = new MediaRecorder(stream, opt); var mime = rec.mimeType; break; }
        catch(e){}
      }
      if (!rec) throw new Error('MediaRecorder unavailable for desired formats');

      await new Promise(res => setTimeout(res, 50));
      return await new Promise((resolve, reject) => {
        let stopped = false;
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
        rec.onerror = e => { if (!stopped) reject(e.error || e); };
        rec.onstop = () => {
          stopped = true;
          try { stream.getTracks().forEach(t => t.stop()); } catch {}
          resolve({ blob: new Blob(chunks, { type: mime }), mime });
        };
        rec.start();
        setTimeout(() => { try { rec.stop(); } catch{} }, durationMs);
      });
    }

    async function handleJob(job) {
      const { conn } = job;
      if (!conn || !conn.open) return;
      isBusy = true;
      setStatus('recording…');
      try {
        const preferMp4 = !job.supportsWebM;
        const { blob, mime } = await recordCanvas(5000, preferMp4);
        const arrayBuf = await blob.arrayBuffer();
        const total = arrayBuf.byteLength;
        const filename = `unknown_${Date.now()}.${mime.includes('mp4')?'mp4':'webm'}`;
        safeSend(conn, { type:'recordingMeta', mime, totalBytes: total, filename });
        const CHUNK = 64 * 1024;
        const channel = conn._dc || conn._channel || null;
        const threshold = 1 * 1024 * 1024;
        let sent = 0, seq = 0;
        while (sent < total) {
          const end = Math.min(total, sent + CHUNK);
          const chunk = arrayBuf.slice(sent, end);
          if (channel && channel.bufferedAmount > threshold) {
            await new Promise(r => {
              const h = () => { if (channel.bufferedAmount <= threshold/2) { channel.removeEventListener('bufferedamountlow', h); r(); } };
              channel.addEventListener('bufferedamountlow', h);
            });
          }
          conn.send(chunk);
          sent = end; seq++;
          if (seq % 32 === 0) safeSend(conn, { type:'progress', sent });
        }
        safeSend(conn, { type:'recordingEnd' });
        setStatus('sent ✔');
      } catch (e) {
        console.error(e);
        safeSend(conn, { type:'error', message: String(e) });
        setStatus('record error', false);
      } finally {
        isBusy = false;
        lastJobAt = performance.now();
      }
    }

    function maybeRunNext() {
      if (isBusy) return;
      if (!queue.length) return;
      if (performance.now() - lastJobAt < 1500) {
        setTimeout(maybeRunNext, 1500);
        return;
      }
      const job = queue.shift();
      handleJob(job).then(() => setTimeout(maybeRunNext, 0));
    }

    function safeSend(conn, obj) { try { conn.send(JSON.stringify(obj)); } catch {} }

    function onMessage(conn, msg) {
      try {
        const data = typeof msg === 'string' ? JSON.parse(msg) : msg;
        if (data.type === 'hello') { safeSend(conn, { type:'helloAck', ok:true }); return; }
        if (data.type === 'capabilities') { conn.__supportsWebM = !!data.supportsWebM; return; }
        if (data.type === 'startRecording') {
          queue.push({ conn, supportsWebM: conn.__supportsWebM !== false });
          safeSend(conn, { type:'queued', position: queue.length });
          maybeRunNext();
          return;
        }
      } catch(e) { console.error('Remote message error', e); setStatus('remote error', false); }
    }

    els.enable.addEventListener('change', async () => {
      if (els.enable.checked) { try { await armRemote(); } catch(e){ setStatus('failed to arm', false); els.enable.checked=false; } }
      else { disarmRemote(); }
    });
    els.showQR.addEventListener('click', openQRWindow);
    els.reset.addEventListener('click', () => { disarmRemote(); els.enable.checked=false; });
  })();
  </script>
</body>
</html>
