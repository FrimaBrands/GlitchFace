<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>U N K N O W N // Remote</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root { 
      color-scheme: dark; 
      --bg-color: #101214;
      --surface-color: #1a1c20;
      --border-color: #333;
      --text-color: #EAEAEA;
      --accent-ready: #00ffff;
      --accent-record: #ff3c3c;
      --dim-color: #666666;
      --error-color: #ff4747;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      margin: 0;
      overscroll-behavior: none;
    }
    body { 
      font-family: 'JetBrains Mono', monospace; 
      background-color: var(--bg-color); 
      background-image: 
        linear-gradient(var(--border-color) 1px, transparent 1px),
        linear-gradient(to right, var(--border-color) 1px, transparent 1px);
      background-size: 40px 40px;
      color: var(--text-color);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: bg-pan 30s linear infinite;
    }
    @keyframes bg-pan {
      0% { background-position: 0% 0%; }
      100% { background-position: 40px 40px; }
    }
    .container {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      text-align: center;
    }
    .header {
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 16px;
    }
    .title {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: 0.5em;
      text-indent: 0.5em;
      color: var(--text-color);
      margin: 0 0 8px 0;
    }
    .instructions, .connection-status {
      font-size: 0.8rem;
      color: var(--dim-color);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .connection-status.ok { color: var(--accent-ready); }
    .connection-status.bad { color: var(--error-color); }

    /* --- Interaction Orb & Animation --- */
    .orb-container {
      margin: 20px 0;
      perspective: 1000px;
    }
    .orb {
        position: relative;
        width: 180px;
        height: 180px;
        padding: 0;
        background-color: transparent;
        border: 2px solid var(--accent-ready);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3), inset 0 0 15px rgba(0, 255, 255, 0.2);
        border-radius: 50%;
        color: var(--text-color);
        cursor: pointer;
        transition: all 0.3s ease-in-out;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-style: preserve-3d;
    }
    .orb:not(:disabled):hover {
        background-color: rgba(0, 255, 255, 0.05);
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), inset 0 0 25px rgba(0, 255, 255, 0.3);
        transform: scale(1.05) rotateY(10deg);
    }
    .orb:not(:disabled):active {
        transform: scale(0.98);
        transition-duration: 0.1s;
    }
    .orb:disabled {
        border-color: var(--dim-color);
        box-shadow: none;
        opacity: 0.5;
        cursor: not-allowed;
    }
    .orb__content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 2;
        transition: opacity 0.3s ease;
    }
    .orb__text-primary {
        font-weight: 700;
        font-size: 1.1rem;
        line-height: 1.3;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        transition: all 0.2s ease;
        text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .orb__text-secondary {
        font-size: 0.7rem;
        letter-spacing: 0.1em;
        color: var(--text-color);
        opacity: 0.7;
        margin-top: 4px;
    }
    .progress-ring {
        position: absolute;
        top: -4px;
        left: -4px;
        width: 188px;
        height: 188px;
        z-index: 1;
    }
    .progress-ring__circle, .progress-ring__circle-bg {
        transform: rotate(-90deg);
        transform-origin: 50% 50%;
    }
    .progress-ring__circle-bg {
        stroke: var(--border-color);
        opacity: 0;
        transition: opacity 0.3s;
    }
    .progress-ring__circle {
        stroke: var(--accent-ready);
        stroke-linecap: round;
        transition: stroke-dashoffset 0.3s ease;
    }

    /* Recording State */
    .orb.is-recording {
        border-color: var(--accent-record);
        box-shadow: 0 0 25px rgba(255, 60, 60, 0.5), inset 0 0 25px rgba(255, 60, 60, 0.3);
        animation: pulse 1.5s infinite;
        background-color: rgba(255, 60, 60, 0.05);
        transform: scale(1.05);
    }
    .orb.is-recording .orb__text-primary {
        font-size: 3.5rem;
        letter-spacing: 0;
        color: var(--text-color);
        text-shadow: 0 0 5px var(--text-color), 0 0 15px var(--accent-record);
    }
    .orb.is-recording .orb__text-secondary {
        color: var(--accent-record);
        opacity: 1;
        text-shadow: 0 0 5px var(--accent-record);
    }
    .orb.is-recording .progress-ring__circle {
        stroke: var(--accent-record);
    }
    .orb.is-recording .progress-ring__circle-bg {
        opacity: 0.3;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 25px rgba(255, 60, 60, 0.5), inset 0 0 25px rgba(255, 60, 60, 0.3); }
      50% { box-shadow: 0 0 40px rgba(255, 60, 60, 0.8), inset 0 0 40px rgba(255, 60, 60, 0.5); }
      100% { box-shadow: 0 0 25px rgba(255, 60, 60, 0.5), inset 0 0 25px rgba(255, 60, 60, 0.3); }
    }
    
    /* --- Status and Progress Bar --- */
    .status-bar {
      min-height: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    .status-text {
      font-size: 0.8rem;
      color: var(--dim-color);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    .status-text.ok { color: var(--text-color); }
    .status-text.bad { color: var(--error-color); }
    #progress-container {
        width: 100%;
        display: none;
    }
    progress {
      -webkit-appearance: none; appearance: none;
      width: 100%; height: 4px;
      background-color: var(--border-color);
      border: none;
    }
    progress::-webkit-progress-bar { background-color: var(--border-color); }
    progress::-webkit-progress-value { background-color: var(--accent-ready); transition: width 0.1s linear; }
    progress::-moz-progress-bar { background-color: var(--accent-ready); }

    /* --- Result Area --- */
    .result-ui {
      width: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }
    .result-title {
        font-size: 1.2rem;
        font-weight: 700;
        letter-spacing: 0.2em;
        margin: 0;
        color: var(--accent-ready);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }
    video { 
      width: 100%; 
      border: 1px solid var(--border-color);
      background-color: #000;
    }
    .result-actions {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .btn {
      display: inline-block;
      width: 100%;
      padding: 12px 16px; 
      border: 1px solid var(--border-color);
      color: var(--text-color); 
      background-color: transparent;
      text-decoration: none; 
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
    }
    .btn:hover {
      border-color: var(--accent-ready);
      background-color: rgba(0, 255, 255, 0.1);
      color: var(--accent-ready);
    }
    .btn-primary {
      background-color: var(--accent-ready);
      border-color: var(--accent-ready);
      color: var(--bg-color);
    }
    .btn-primary:hover {
      background-color: transparent;
      border-color: var(--accent-ready);
      color: var(--accent-ready);
    }
    
    /* General UI visibility control */
    .main-ui, .result-ui {
        transition: opacity 0.5s, transform 0.5s;
    }
    .hidden {
        display: none !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="title">U N K N O W N</h1>
      <div id="connState" class="connection-status">INITIALIZING…</div>
    </div>
    
    <div id="main-ui" class="main-ui">
      <p id="instructions" class="instructions">Tap the orb to request a 5‑second capture.</p>
      <div class="orb-container">
        <button id="startBtn" class="orb" disabled>
            <svg class="progress-ring" viewBox="0 0 188 188">
                <circle class="progress-ring__circle-bg" stroke-width="4" fill="transparent" r="90" cx="94" cy="94"/>
                <circle class="progress-ring__circle" stroke-width="4" fill="transparent" r="90" cx="94" cy="94"/>
            </svg>
            <div class="orb__content">
              <span id="startBtnText" class="orb__text-primary">CONNECTING</span>
              <span id="startBtnSubtext" class="orb__text-secondary"></span>
            </div>
        </button>
      </div>
    </div>

    <div id="result-ui" class="result-ui hidden">
      <h2 class="result-title">// CAPTURE COMPLETE</h2>
      <video id="preview" controls playsinline></video>
      <div class="result-actions">
        <a id="download" class="btn btn-primary" href="#" download>Download Video</a>
        <button id="resetBtn" class="btn">Request Another</button>
      </div>
    </div>

    <div class="status-bar">
      <div id="status" class="status-text">—</div>
      <div id="progress-container">
        <progress id="progress" value="0" max="100"></progress>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const els = {
      // Main UI elements
      connState: document.getElementById('connState'),
      instructions: document.getElementById('instructions'),
      mainUI: document.getElementById('main-ui'),
      resultUI: document.getElementById('result-ui'),
      
      // Orb / Button elements
      orb: document.getElementById('startBtn'),
      orbText: document.getElementById('startBtnText'),
      orbSubtext: document.getElementById('startBtnSubtext'),
      progressRing: document.querySelector('.progress-ring__circle'),
      
      // Status elements
      status: document.getElementById('status'),
      progress: document.getElementById('progress'),
      progressContainer: document.getElementById('progress-container'),
      
      // Result elements
      downloadLink: document.getElementById('download'),
      video: document.getElementById('preview'),
      resetBtn: document.getElementById('resetBtn')
    };

    let recordingTimer = null;
    const radius = els.progressRing.r.baseVal.value;
    const circumference = radius * 2 * Math.PI;
    els.progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
    
    function setRingProgress(percent) {
        const offset = circumference - percent / 100 * circumference;
        els.progressRing.style.strokeDashoffset = offset;
    }
    setRingProgress(0);

    function showMainUI() {
        els.resultUI.classList.add('hidden');
        els.mainUI.classList.remove('hidden');
    }
    
    function showResultUI() {
        els.mainUI.classList.add('hidden');
        els.resultUI.classList.remove('hidden');
    }

    function startRecordingAnimation() {
        els.orb.disabled = true;
        els.orb.classList.add('is-recording');
        els.orbSubtext.textContent = 'RECORDING';
        let secondsLeft = 5;
        
        els.orbText.textContent = secondsLeft;
        // The transition is now defined in the CSS for better performance
        els.progressRing.style.transition = 'stroke-dashoffset 5s linear';
        setRingProgress(100);

        recordingTimer = setInterval(() => {
            secondsLeft--;
            if (secondsLeft > 0) {
                els.orbText.textContent = secondsLeft;
            } else {
                els.orbText.textContent = '...';
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
        }, 1000);
    }

    function resetUI() {
        showMainUI();
        els.video.src = '';
        els.downloadLink.href = '#';
        
        els.orb.disabled = false;
        els.orb.classList.remove('is-recording');
        els.orbText.textContent = 'REQUEST CAPTURE';
        els.orbSubtext.textContent = '';


        if (recordingTimer) clearInterval(recordingTimer);
        els.progressRing.style.transition = 'stroke-dashoffset 0.3s ease';
        setRingProgress(0);
        
        setStatus('ready');
        els.progressContainer.style.display = 'none';
        els.progress.value = 0;
    }

    // --- PeerJS Logic (unchanged) ---
    function logMsg(msg) { console.log(msg); }

    els.resetBtn.addEventListener('click', resetUI);

    try {
        const hostId = new URLSearchParams(location.search).get('host');
        const token = new URLSearchParams(location.search).get('token');

        if (!hostId || !token) {
          setStatus('ERROR: Invalid Link', false);
          logMsg('Error: Missing host or token in URL.');
          return;
        }

        function setConn(txt, ok=false){ 
          els.connState.textContent = `// ${txt}`; 
          els.connState.className = ok ? 'connection-status ok' : (txt.includes('error') ? 'connection-status bad' : 'connection-status');
        }
        function setStatus(txt, ok=true){ 
          els.status.textContent = `STATUS: ${txt}`; 
          els.status.className = ok ? 'status-text ok' : 'status-text bad';
        }

        const supportsWebM = (typeof MediaSource !== 'undefined') && MediaSource.isTypeSupported && (MediaSource.isTypeSupported('video/webm;codecs=vp9') || MediaSource.isTypeSupported('video/webm;codecs=vp8'));
        const chunks = [];
        let expectedBytes = 0, received = 0, mime = 'video/webm', filename = 'capture.webm', conn = null;

        logMsg('Initializing PeerJS...');
        const peer = new Peer(undefined, {
          debug: 2,
          config: { 'iceServers': [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] }
        });

        peer.on('open', (id) => {
          logMsg(`PeerJS client open: ${id}`);
          setConn('connecting...');
          conn = peer.connect(hostId, { reliable: true });

          conn.on('open', () => {
            logMsg('Connection established!');
            setConn('connected', true);
            conn.send(JSON.stringify({ type:'hello', token, supportsWebM }));
            els.orb.disabled = false;
            els.orbText.textContent = 'REQUEST CAPTURE';
          });

          conn.on('data', (msg) => {
            if (typeof msg === 'string') {
              const data = JSON.parse(msg);
              if (data.type === 'helloAck') {
                setStatus('ready');
                logMsg('Handshake acknowledged.');
              } else if (data.type === 'recordingMeta') {
                mime = data.mime; expectedBytes = data.totalBytes; filename = data.filename;
                chunks.length = 0; received = 0;
                els.progressContainer.style.display = 'block';
                els.progress.value = 0;
                setStatus('receiving data…');
                logMsg(`Receiving file: ${filename} (${expectedBytes} bytes)`);
              } else if (data.type === 'recordingEnd') {
                if (recordingTimer) clearInterval(recordingTimer);
                const blob = new Blob(chunks, { type: mime });
                const url = URL.createObjectURL(blob);
                els.downloadLink.href = url; els.downloadLink.download = filename;
                els.video.src = url; 
                
                showResultUI();
                
                els.progress.value = 100;
                setTimeout(() => { els.progressContainer.style.display = 'none'; }, 500);
                setStatus('complete', true);
                logMsg('File received successfully.');
              } else if (data.type === 'error') {
                setStatus(data.message || 'error', false);
                logMsg(`Host error: ${data.message}`);
                resetUI();
                els.orbText.textContent = 'RETRY';
              }
            } else {
              chunks.push(new Uint8Array(msg));
              received += msg.byteLength;
              if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*received/expectedBytes));
            }
          });

          conn.on('close', () => { logMsg('Connection closed.'); setConn('disconnected'); setStatus('disconnected', false); els.orb.disabled = true; els.orbText.textContent = 'OFFLINE'; });
          conn.on('error', (err) => { logMsg(`Connection error: ${err}`); setConn('connection error', false); });
        });
        
        peer.on('error', (err) => { logMsg(`Peer error: ${err.type}`); setConn(`peer error: ${err.type}`, false); setStatus('Error', false); });
        peer.on('disconnected', () => { logMsg('Disconnected from server.'); setConn('reconnecting signal...'); });
        
        els.orb.addEventListener('click', () => {
          setStatus('requesting...');
          logMsg('Sent startRecording request.');
          conn && conn.send(JSON.stringify({ type:'startRecording' }));
          startRecordingAnimation();

          setTimeout(() => { 
            if (els.status.textContent === 'STATUS: requesting...') {
              setStatus('request timed out', false);
              resetUI();
              els.orbText.textContent = 'RETRY';
            }
          }, 8000);
        });
    } catch (e) {
        logMsg(`CRITICAL ERROR: ${e.message}.`);
        setConn('Script Error', false);
        setStatus(e.message, false);
    }
  });
  </script>
</body>
</html>
