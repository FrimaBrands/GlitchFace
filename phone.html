<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>U N K N O W N</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root { 
      color-scheme: dark; 
      --bg-color: #000000;
      --text-color: #EAEAEA;
      --accent-color: #FFFFFF;
      --dim-color: #555555;
      --error-color: #ff4747;
    }
    html, body {
      height: 100%;
      margin: 0;
      overscroll-behavior: none;
    }
    body { 
      font-family: 'JetBrains Mono', monospace; 
      background: var(--bg-color); 
      color: var(--text-color);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }
    .title {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: 0.5em;
      text-indent: 0.5em; /* to balance the letter-spacing */
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(255,255,255,0.2);
    }
    .instructions {
      font-size: 0.9rem;
      color: var(--dim-color);
      line-height: 1.6;
      transition: opacity 0.3s ease;
    }
    .trigger-area {
      position: relative;
      width: 160px;
      height: 160px;
      margin: 20px auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #startBtn {
      width: 150px;
      height: 150px;
      font-weight: 700;
      font-size: 1.1rem;
      letter-spacing: 0.1em;
      border: 1px solid var(--dim-color);
      border-radius: 50%;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      animation: pulse 3s infinite ease-in-out;
      z-index: 10;
    }
    #startBtn:not(:disabled):hover {
      background: var(--accent-color);
      color: var(--bg-color);
      border-color: var(--accent-color);
      transform: scale(1.05);
      animation: none;
    }
    #startBtn:disabled {
      opacity: 0.8;
      cursor: not-allowed;
      animation: none;
    }
    .progress-ring {
        position: absolute;
        top: 0;
        left: 0;
        width: 160px;
        height: 160px;
        transform: rotate(-90deg);
        z-index: 5;
    }
    .progress-ring__circle {
        stroke: var(--accent-color);
        stroke-width: 2;
        fill: transparent;
        transition: stroke-dashoffset 0.5s linear;
    }
    .status-area {
      min-height: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    .status-text {
      font-size: 0.9rem;
      color: var(--dim-color);
    }
    .status-text.ok { color: var(--text-color); }
    .status-text.bad { color: var(--error-color); }

    /* Result styling */
    #result-area {
        display: none;
        flex-direction: column;
        width: 100%;
        gap: 16px;
        margin-top: 12px;
    }
    #result-area.visible {
        display: flex;
    }
    video { 
      width: 100%; 
      border: 1px solid var(--dim-color);
      display: block;
    }
    .button-group {
        display: flex;
        gap: 12px;
        width: 100%;
    }
    .btn { 
      flex: 1;
      padding: 12px 16px; 
      border: 1px solid var(--dim-color);
      color: var(--text-color); 
      background: transparent;
      text-decoration: none; 
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 700;
      transition: all 0.2s ease-in-out;
    }
    .btn:hover {
      background: var(--accent-color);
      color: var(--bg-color);
      border-color: var(--accent-color);
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.2); }
      70% { box-shadow: 0 0 0 20px rgba(255, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="title">UNKNOWN</h1>
    <p id="instructions" class="instructions">Tap the orb to request a 5‑second capture from the installation.</p>
    
    <div id="trigger-area" class="trigger-area">
        <button id="startBtn" disabled>CONNECTING</button>
        <svg id="progress-svg" class="progress-ring" viewBox="0 0 160 160">
            <circle
              class="progress-ring__circle"
              r="78"
              cx="80"
              cy="80"
            />
        </svg>
    </div>
    
    <div class="status-area">
      <div id="connState" class="status-text">initializing…</div>
      <div id="status" class="status-text">—</div>
    </div>

    <div id="result-area">
      <video id="preview" controls playsinline></video>
      <div class="button-group">
        <a id="download" class="btn" href="#" download>Download</a>
        <button id="resetBtn" class="btn">Again</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const els = {
      btn: document.getElementById('startBtn'),
      conn: document.getElementById('connState'),
      status: document.getElementById('status'),
      dl: document.getElementById('download'),
      video: document.getElementById('preview'),
      instructions: document.getElementById('instructions'),
      resultArea: document.getElementById('result-area'),
      triggerArea: document.getElementById('trigger-area'),
      resetBtn: document.getElementById('resetBtn'),
      progressSvg: document.getElementById('progress-svg'),
      progressCircle: document.querySelector('.progress-ring__circle')
    };

    const radius = els.progressCircle.r.baseVal.value;
    const circumference = 2 * Math.PI * radius;
    els.progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
    els.progressCircle.style.strokeDashoffset = circumference;

    function setProgress(percent) {
        const offset = circumference - (percent / 100) * circumference;
        els.progressCircle.style.strokeDashoffset = offset;
    }
    
    let recordingInterval;

    function resetUI() {
        clearInterval(recordingInterval);
        els.resultArea.classList.remove('visible');
        els.triggerArea.style.display = 'flex';
        els.instructions.style.opacity = '1';
        els.btn.disabled = false;
        els.btn.textContent = 'INITIATE';
        setStatus('ready');
        setProgress(0);
        // Ensure video is paused to stop network activity
        els.video.pause();
        els.video.src = ""; 
    }

    function qs(k){ return new URLSearchParams(location.search).get(k); }
    const hostId = qs('host'); const token = qs('token');

    if (!hostId || !token) {
      setStatus('ERROR: Invalid Link', false);
      return;
    }

    function setConn(txt, ok=false){ els.conn.textContent = `CONNECTION: ${txt}`; els.conn.className = ok?'status-text ok':'status-text'; }
    function setStatus(txt, ok=true){ els.status.textContent = `STATUS: ${txt}`; els.status.className = ok?'status-text ok':'status-text bad'; }

    const supportsWebM = (typeof MediaSource !== 'undefined') && MediaSource.isTypeSupported && ( MediaSource.isTypeSupported('video/webm;codecs=vp9') || MediaSource.isTypeSupported('video/webm;codecs=vp8') );
    
    const chunks = [];
    let expectedBytes = 0;
    let received = 0;
    let mime = 'video/webm';
    let filename = 'capture.webm';
    let conn = null;

    const peer = new Peer(undefined, {
      debug: 1,
      config: { 'iceServers': [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' } ] }
    });

    peer.on('open', (id) => {
      setConn('connecting...');
      conn = peer.connect(hostId, { reliable: true });

      conn.on('open', () => {
        setConn('connected', true);
        conn.send(JSON.stringify({ type:'hello', token, supportsWebM }));
        resetUI();
      });

      conn.on('data', (msg) => {
        if (typeof msg === 'string') {
          const data = JSON.parse(msg);
          if (data.type === 'helloAck') {
            setStatus('ready');
          } else if (data.type === 'recordingStarted') {
              setStatus('recording...');
              let countdown = 5;
              els.btn.textContent = countdown;
              els.progressCircle.style.transition = 'stroke-dashoffset 1s linear';
              setProgress(100); // Start the animation
              
              recordingInterval = setInterval(() => {
                  countdown--;
                  els.btn.textContent = countdown > 0 ? countdown : '...';
                  if (countdown <= 0) {
                      clearInterval(recordingInterval);
                  }
              }, 1000);

          } else if (data.type === 'recordingMeta') {
            clearInterval(recordingInterval);
            mime = data.mime || 'video/webm';
            expectedBytes = data.totalBytes || 0;
            filename = data.filename || ('capture.'+(mime.includes('mp4')?'mp4':'webm'));
            chunks.length = 0; received = 0;
            setProgress(0); // Reset for download progress
            els.progressCircle.style.transition = 'stroke-dashoffset 0.1s linear';
            setStatus('receiving…');
            els.btn.textContent = '0%';
          } else if (data.type === 'recordingEnd') {
            setProgress(100);
            const blob = new Blob(chunks, { type: mime });
            const url = URL.createObjectURL(blob);
            els.dl.href = url; els.dl.download = filename;
            els.video.src = url; 
            
            els.resultArea.classList.add('visible');
            els.triggerArea.style.display = 'none';
            els.instructions.style.opacity = '0';

            setStatus('complete', true);
          } else if (data.type === 'error') {
            setStatus(data.message || 'error', false);
            resetUI();
          }
        } else {
          chunks.push(new Uint8Array(msg));
          received += msg.byteLength;
          if (expectedBytes > 0) {
            const percent = Math.round(100 * received / expectedBytes);
            setProgress(percent);
            els.btn.textContent = `${percent}%`;
          }
        }
      });

      conn.on('close', () => {
        setConn('disconnected');
        setStatus('disconnected', false);
        els.btn.disabled = true;
        els.btn.textContent = 'OFFLINE';
      });

      conn.on('error', (err) => setConn('connection error', false));
    });

    peer.on('error', (err) => {
      setConn(`peer error: ${err.type}`, false);
      setStatus('Error', false);
    });
    
    els.btn.addEventListener('click', () => {
      els.btn.disabled = true;
      setStatus('requesting...');
      conn?.send(JSON.stringify({ type:'startRecording' }));
    });

    els.resetBtn.addEventListener('click', resetUI);

    setProgress(0); // Initial reset
  });
  </script>
</body>
</html>
