<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>U N K N O W N</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root { 
      color-scheme: dark; 
      --bg-color: #000000;
      --text-color: #EAEAEA;
      --accent-color: #FFFFFF;
      --dim-color: #555555;
      --error-color: #ff4747;
    }
    html, body {
      height: 100%;
      margin: 0;
      overscroll-behavior: none;
    }
    body { 
      font-family: 'JetBrains Mono', monospace; 
      background: var(--bg-color); 
      color: var(--text-color);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .title {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: 0.5em;
      text-indent: 0.5em; /* to balance the letter-spacing */
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(255,255,255,0.2);
    }
    .instructions {
      font-size: 0.9rem;
      color: var(--dim-color);
      line-height: 1.6;
    }
    #startBtn {
      width: 150px;
      height: 150px;
      margin: 20px auto;
      font-weight: 700;
      font-size: 1rem;
      letter-spacing: 0.1em;
      border: 1px solid var(--dim-color);
      border-radius: 50%;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      animation: pulse 3s infinite ease-in-out;
    }
    #startBtn:not(:disabled):hover {
      background: var(--accent-color);
      color: var(--bg-color);
      border-color: var(--accent-color);
      transform: scale(1.05);
      animation: none;
    }
    #startBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      animation: none;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.2); }
      70% { box-shadow: 0 0 0 20px rgba(255, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
    }
    .status-area {
      min-height: 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    .status-text {
      font-size: 0.9rem;
      color: var(--dim-color);
    }
    .status-text.ok { color: var(--text-color); }
    .status-text.bad { color: var(--error-color); }
    progress {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 2px;
      background-color: var(--dim-color);
      border: none;
    }
    progress::-webkit-progress-bar {
      background-color: var(--dim-color);
    }
    progress::-webkit-progress-value {
      background-color: var(--accent-color);
      transition: width 0.1s linear;
    }
    progress::-moz-progress-bar {
      background-color: var(--accent-color);
    }
    video { 
      width: 100%; 
      border: 1px solid var(--dim-color);
      display: none; 
      margin-top: 12px;
    }
    a.dl { 
      display: none;
      margin-top: 12px; 
      padding: 10px 16px; 
      border: 1px solid var(--dim-color);
      color: var(--text-color); 
      text-decoration: none; 
      font-size: 0.9rem;
      transition: all 0.2s ease-in-out;
    }
    a.dl:hover {
      background: var(--accent-color);
      color: var(--bg-color);
    }
    #debugLog { display: none; } /* Hidden for guests */
  </style>
</head>
<body>
  <div class="container">
    <h1 class="title">UNKNOWN</h1>
    <p id="instructions" class="instructions">Tap the orb to request a 5‑second capture from the installation.</p>
    
    <button id="startBtn" disabled>CONNECTING</button>
    
    <div class="status-area">
      <div id="connState" class="status-text">initializing…</div>
      <div id="status" class="status-text">—</div>
      <progress id="progress" value="0" max="100"></progress>
    </div>

    <div id="result-area" style="display: none;">
      <video id="preview" controls playsinline></video>
      <a id="download" class="dl" href="#" download>Download Video</a>
    </div>

    <pre id="debugLog"></pre>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
  // --- All JavaScript functionality remains unchanged. ---
  document.addEventListener('DOMContentLoaded', () => {
    const els = {
      btn: document.getElementById('startBtn'),
      conn: document.getElementById('connState'),
      status: document.getElementById('status'),
      progress: document.getElementById('progress'),
      dl: document.getElementById('download'),
      video: document.getElementById('preview'),
      debug: document.getElementById('debugLog'),
      instructions: document.getElementById('instructions'),
      resultArea: document.getElementById('result-area')
    };

    if (!els.debug) {
        // Non-critical for guest UI
        console.error('Debug log element not found.');
    }

    function logMsg(msg) {
        console.log(msg);
        if (!els.debug) return;
        const time = new Date().toLocaleTimeString();
        els.debug.textContent = `${time}: ${msg}\n${els.debug.textContent}`;
    }

    logMsg('DOM is ready. Starting script.');

    try {
        function qs(k){ return new URLSearchParams(location.search).get(k); }
        const hostId = qs('host'); const token = qs('token');

        if (!hostId || !token) {
          els.status.textContent = 'ERROR: Invalid Link'; els.status.className='status-text bad';
          logMsg('Error: Missing host or token in URL.');
          return;
        }

        function setConn(txt, ok=false){ els.conn.textContent = `CONNECTION: ${txt}`; els.conn.className = ok?'status-text ok':'status-text'; }
        function setStatus(txt, ok=true){ els.status.textContent = `STATUS: ${txt}`; els.status.className = ok?'status-text ok':'status-text bad'; }

        const supportsWebM = (typeof MediaSource !== 'undefined') && MediaSource.isTypeSupported && ( MediaSource.isTypeSupported('video/webm;codecs=vp9') || MediaSource.isTypeSupported('video/webm;codecs=vp8') );
        
        const chunks = [];
        let expectedBytes = 0;
        let received = 0;
        let mime = 'video/webm';
        let filename = 'capture.webm';
        let conn = null;

        logMsg('Initializing PeerJS with STUN servers...');
        
        const peer = new Peer(undefined, {
          debug: 2,
          config: {
            'iceServers': [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ]
          }
        });

        peer.on('open', (id) => {
          logMsg(`PeerJS client is open with ID: ${id}`);
          setConn('connecting...');
          logMsg(`Attempting to connect to host: ${hostId}`);
          
          conn = peer.connect(hostId, { reliable: true });

          conn.on('open', () => {
            logMsg('Connection established with host!');
            setConn('connected', true);
            logMsg('Sending handshake (hello) with token...');
            conn.send(JSON.stringify({ type:'hello', token, supportsWebM }));
            els.btn.disabled = false;
            els.btn.textContent = 'INITIATE';
          });

          conn.on('data', (msg) => {
            if (typeof msg === 'string') {
              const data = JSON.parse(msg);
              if (data.type === 'helloAck') {
                setStatus('ready');
                logMsg('Handshake acknowledged by host. Ready.');
              } else if (data.type === 'recordingMeta') {
                mime = data.mime || 'video/webm';
                expectedBytes = data.totalBytes || 0;
                filename = data.filename || ('capture.'+(mime.includes('mp4')?'mp4':'webm'));
                chunks.length = 0; received = 0;
                els.progress.value = 0;
                setStatus('receiving…');
                logMsg(`Receiving file: ${filename} (${expectedBytes} bytes)`);
              } else if (data.type === 'progress') {
                if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*data.sent/expectedBytes));
              } else if (data.type === 'recordingEnd') {
                const blob = new Blob(chunks, { type: mime });
                const url = URL.createObjectURL(blob);
                els.dl.href = url; els.dl.download = filename;
                els.video.src = url; 
                
                // Show results
                els.resultArea.style.display = 'block';
                els.dl.style.display='inline-block';
                els.video.style.display='block';
                
                // Hide button and instructions
                els.btn.style.display = 'none';
                els.instructions.style.display = 'none';

                els.progress.value = 100;
                setStatus('complete', true);
                logMsg('File received successfully.');
              } else if (data.type === 'error') {
                setStatus(data.message || 'error', false);
                logMsg(`Host sent error: ${data.message}`);
                els.btn.disabled = false;
                els.btn.textContent = 'RETRY';
              }
            } else {
              chunks.push(new Uint8Array(msg));
              received += msg.byteLength;
              if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*received/expectedBytes));
            }
          });

          conn.on('close', () => {
            logMsg('Connection closed by host.');
            setConn('disconnected');
            setStatus('disconnected', false);
            els.btn.disabled = true;
            els.btn.textContent = 'OFFLINE';
          });

          conn.on('error', (err) => {
            logMsg(`Connection error: ${err}`);
            setConn('connection error', false);
          });
        });

        peer.on('error', (err) => {
          logMsg(`A peer error occurred: ${err.type} - ${err.message || err}`);
          setConn(`peer error: ${err.type}`, false);
          setStatus('Error', false);
        });

        peer.on('disconnected', () => {
            logMsg('Disconnected from PeerJS server. Attempting to reconnect...');
            setConn('reconnecting signal...');
        });
        
        els.btn.addEventListener('click', () => {
          els.btn.disabled = true;
          els.btn.textContent = 'WAIT';
          setStatus('requesting...');
          logMsg('Sent startRecording request to host.');
          conn && conn.send(JSON.stringify({ type:'startRecording' }));
          setTimeout(() => { 
            if (els.status.textContent === 'STATUS: requesting...') {
              setStatus('request timed out', false);
              els.btn.disabled = false;
              els.btn.textContent = 'RETRY';
            }
          }, 8000);
        });

    } catch (e) {
        logMsg(`CRITICAL ERROR: ${e.name} - ${e.message}.`);
        if (e instanceof ReferenceError) {
            logMsg('This could be due to a missing browser feature or the PeerJS library failing to load.');
        }
        setConn('Script Error', false);
        setStatus(e.message, false);
    }
  });
  </script>
</body>
</html>
