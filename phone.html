<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>U N K N O W N // Remote</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { 
      color-scheme: dark; 
      --bg-color: #000000;
      --text-color: #EAEAEA;
      --accent-color: #FFFFFF;
      --dim-color: #555555;
      --error-color: #ff4747;
      --success-color: #00ff8c;
    }
    html, body {
      height: 100%;
      margin: 0;
      overscroll-behavior: none;
    }
    body { 
      font-family: 'Inter', sans-serif; 
      background: var(--bg-color); 
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      transition: background-color 0.5s ease;
    }
    .container {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }
    .title {
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: 0.3em;
      text-indent: 0.3em;
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(255,255,255,0.2);
      margin-bottom: 24px;
    }
    .instructions {
      font-size: 0.9rem;
      color: var(--dim-color);
      line-height: 1.6;
      min-height: 48px; /* Reserve space */
      transition: opacity 0.3s ease;
    }
    .orb-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 20px 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #orb-svg {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transform: rotate(-90deg); /* Start from the top */
    }
    .progress-ring-bg {
      fill: transparent;
      stroke: var(--dim-color);
      stroke-width: 2;
      opacity: 0.2;
    }
    .progress-ring {
      fill: transparent;
      stroke: var(--accent-color);
      stroke-width: 2;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.1s linear, stroke 0.3s ease;
    }
    @keyframes countdown-animation {
        from { stroke-dashoffset: 0; }
        to { stroke-dashoffset: var(--circumference); }
    }
    .is-recording .progress-ring {
        animation: countdown-animation 5s linear forwards;
    }
    #startBtn {
      width: 100%;
      height: 100%;
      font-weight: 600;
      font-size: 1rem;
      letter-spacing: 0.1em;
      border: 1px solid var(--dim-color);
      border-radius: 50%;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px;
      line-height: 1.4;
    }
    #startBtn:not(:disabled):hover {
      background: rgba(255,255,255,0.1);
      border-color: var(--accent-color);
      transform: scale(1.05);
    }
    #startBtn:disabled {
      cursor: not-allowed;
      color: var(--dim-color);
      border-color: var(--dim-color);
    }
    #status-text {
        font-size: 0.8rem;
        color: var(--dim-color);
        margin-top: 4px;
    }
    #result-area {
      display: none;
      flex-direction: column;
      gap: 16px;
      width: 100%;
      animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    video { 
      width: 100%; 
      border-radius: 8px;
      border: 1px solid var(--dim-color);
      display: none; 
    }
    a.dl { 
      display: none;
      padding: 12px 20px; 
      border: 1px solid var(--dim-color);
      color: var(--text-color); 
      text-decoration: none; 
      font-size: 0.9rem;
      font-weight: 600;
      border-radius: 8px;
      transition: all 0.2s ease-in-out;
      background: rgba(255,255,255,0.05);
    }
    a.dl:hover {
      background: var(--accent-color);
      color: var(--bg-color);
      border-color: var(--accent-color);
    }
    #debugLog { display: none; } /* Hidden for guests */
  </style>
</head>
<body>
  <div class="container">
    <h1 class="title">UNKNOWN</h1>
    <p id="instructions" class="instructions">Tap the orb to request a 5â€‘second capture from the installation.</p>
    
    <div id="main-interface">
        <div class="orb-container">
            <svg id="orb-svg" viewBox="0 0 100 100">
                <circle class="progress-ring-bg" cx="50" cy="50" r="48"/>
                <circle id="progress-ring" class="progress-ring" cx="50" cy="50" r="48"/>
            </svg>
            <button id="startBtn" disabled>
                <span id="btn-main-text">CONNECTING</span>
                <span id="status-text">Initializing...</span>
            </button>
        </div>
    </div>
    
    <div id="result-area">
      <video id="preview" controls playsinline></video>
      <a id="download" class="dl" href="#" download>Download Video</a>
    </div>

    <pre id="debugLog"></pre>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const els = {
      container: document.querySelector('.container'),
      btn: document.getElementById('startBtn'),
      btnMainText: document.getElementById('btn-main-text'),
      statusText: document.getElementById('status-text'),
      progressRing: document.getElementById('progress-ring'),
      instructions: document.getElementById('instructions'),
      mainInterface: document.getElementById('main-interface'),
      resultArea: document.getElementById('result-area'),
      dl: document.getElementById('download'),
      video: document.getElementById('preview'),
      debug: document.getElementById('debugLog'),
    };

    // --- SVG Progress Ring Setup ---
    const radius = els.progressRing.r.baseVal.value;
    const circumference = 2 * Math.PI * radius;
    els.progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
    els.progressRing.style.setProperty('--circumference', circumference);

    function setProgress(percent) {
        const offset = circumference - (percent / 100) * circumference;
        els.progressRing.style.strokeDashoffset = offset;
    }
    setProgress(0); // Start empty

    // --- UI State Machine ---
    let recordingTimeout = null;
    let requestTimeout = null;

    function updateUI(state, data = {}) {
        // Reset all animations and styles first
        els.container.classList.remove('is-recording');
        els.progressRing.style.animation = '';
        els.progressRing.style.transition = 'stroke-dashoffset 0.1s linear, stroke 0.3s ease';
        els.progressRing.style.stroke = 'var(--accent-color)';
        
        clearTimeout(recordingTimeout);
        clearTimeout(requestTimeout);

        switch(state) {
            case 'connecting':
                els.btn.disabled = true;
                els.btnMainText.textContent = 'CONNECTING';
                els.statusText.textContent = data.message || 'Initializing...';
                break;
            
            case 'ready':
                els.btn.disabled = false;
                els.btnMainText.textContent = 'TAP TO CAPTURE';
                els.statusText.textContent = 'Connection: OK';
                els.instructions.textContent = 'Tap the orb to request a 5-second capture from the installation.';
                setProgress(0);
                break;

            case 'requesting':
                els.btn.disabled = true;
                els.btnMainText.textContent = 'REQUESTING';
                els.statusText.textContent = 'Waiting for host...';
                // Optimistically start recording animation
                updateUI('recording');
                break;

            case 'recording':
                els.btn.disabled = true;
                els.btnMainText.textContent = 'RECORDING';
                els.statusText.textContent = '00:05';
                els.container.classList.add('is-recording');
                els.progressRing.style.transition = 'none'; // Use animation instead
                setProgress(circumference); // Set to full
                els.progressRing.style.animation = 'countdown-animation 5s linear forwards';
                
                // After 5s, assume it's processing
                recordingTimeout = setTimeout(() => updateUI('processing'), 5000);
                break;

            case 'processing':
                els.btn.disabled = true;
                els.btnMainText.textContent = 'PROCESSING';
                els.statusText.textContent = 'Preparing your file...';
                setProgress(100);
                break;

            case 'receiving':
                els.btn.disabled = true;
                els.btnMainText.textContent = 'RECEIVING';
                els.statusText.textContent = `0%`;
                setProgress(0);
                break;
            
            case 'progress':
                const percent = Math.round(data.percent);
                els.statusText.textContent = `${percent}%`;
                setProgress(percent);
                break;

            case 'complete':
                els.instructions.textContent = 'Capture complete.';
                els.mainInterface.style.display = 'none';
                els.resultArea.style.display = 'flex';
                els.dl.style.display='inline-block';
                els.video.style.display='block';
                els.progressRing.style.stroke = 'var(--success-color)';
                setProgress(100);
                break;

            case 'error':
                els.btn.disabled = false;
                els.btnMainText.textContent = 'RETRY';
                els.statusText.textContent = `Error: ${data.message}`;
                els.instructions.textContent = 'Something went wrong. Please try again.';
                els.progressRing.style.stroke = 'var(--error-color)';
                setProgress(100);
                // After a delay, reset to ready
                setTimeout(() => updateUI('ready'), 3000);
                break;
        }
    }

    // --- PeerJS Logic ---
    function logMsg(msg) { console.log(msg); if(els.debug) els.debug.textContent = `${new Date().toLocaleTimeString()}: ${msg}\n${els.debug.textContent}`; }

    try {
        logMsg('DOM is ready. Starting script.');
        const hostId = new URLSearchParams(location.search).get('host');
        const token = new URLSearchParams(location.search).get('token');

        if (!hostId || !token) {
          updateUI('error', { message: 'Invalid Link' });
          return;
        }
        
        updateUI('connecting', { message: 'Awaiting signal...' });

        const supportsWebM = (typeof MediaSource !== 'undefined') && MediaSource.isTypeSupported && ( MediaSource.isTypeSupported('video/webm;codecs=vp9') || MediaSource.isTypeSupported('video/webm;codecs=vp8') );
        
        const chunks = [];
        let expectedBytes = 0;
        let received = 0;
        let mime = 'video/webm';
        let filename = 'capture.webm';
        let conn = null;

        const peer = new Peer(undefined, {
          debug: 2,
          config: { 'iceServers': [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] }
        });

        peer.on('open', (id) => {
          logMsg(`PeerJS client open with ID: ${id}`);
          updateUI('connecting', { message: 'Contacting host...' });
          conn = peer.connect(hostId, { reliable: true });

          conn.on('open', () => {
            logMsg('Connection established!');
            conn.send(JSON.stringify({ type:'hello', token, supportsWebM }));
          });

          conn.on('data', (msg) => {
            if (typeof msg === 'string') {
              const data = JSON.parse(msg);
              if (data.type === 'helloAck') {
                logMsg('Handshake acknowledged. Ready.');
                updateUI('ready');
              } else if (data.type === 'recordingMeta') {
                mime = data.mime || 'video/webm';
                expectedBytes = data.totalBytes || 0;
                filename = data.filename || ('capture.'+(mime.includes('mp4')?'mp4':'webm'));
                chunks.length = 0; received = 0;
                updateUI('receiving');
                logMsg(`Receiving file: ${filename} (${expectedBytes} bytes)`);
              } else if (data.type === 'recordingEnd') {
                updateUI('progress', { percent: 100 });
                const blob = new Blob(chunks, { type: mime });
                const url = URL.createObjectURL(blob);
                els.dl.href = url; els.dl.download = filename;
                els.video.src = url; 
                setTimeout(() => updateUI('complete'), 500);
                logMsg('File received successfully.');
              } else if (data.type === 'error') {
                updateUI('error', { message: data.message || 'Host error' });
                logMsg(`Host sent error: ${data.message}`);
              }
            } else {
              chunks.push(new Uint8Array(msg));
              received += msg.byteLength;
              if (expectedBytes) {
                const percent = Math.min(100, (100 * received / expectedBytes));
                updateUI('progress', { percent });
              }
            }
          });

          conn.on('close', () => { logMsg('Connection closed.'); updateUI('error', { message: 'Disconnected' }); });
          conn.on('error', (err) => { logMsg(`Connection error: ${err}`); updateUI('error', { message: 'Connection failed' }); });
        });

        peer.on('error', (err) => { logMsg(`Peer error: ${err.type}`); updateUI('error', { message: `Peer Error: ${err.type}` }); });
        peer.on('disconnected', () => { logMsg('Disconnected from PeerJS server.'); updateUI('connecting', { message: 'Reconnecting signal...' }); });
        
        els.btn.addEventListener('click', () => {
          updateUI('requesting');
          logMsg('Sent startRecording request.');
          conn && conn.send(JSON.stringify({ type:'startRecording' }));
          
          requestTimeout = setTimeout(() => { 
            if (els.btnMainText.textContent === 'PROCESSING') {
              updateUI('error', { message: 'Request timed out' });
            }
          }, 8000);
        });

    } catch (e) {
        logMsg(`CRITICAL ERROR: ${e.message}.`);
        updateUI('error', { message: 'Script failure' });
    }
  });
  </script>
</body>
</html>
