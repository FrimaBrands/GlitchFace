<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UNKNOWN // Visitor Phone</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    body { background:#0b0d11; color:#e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
    .muted{color:#9aa0aa}
    .ok{color:#6ee7b7}
    .bad{color:#f87171}
    a.btn{display:inline-block;padding:.6rem 1rem;border-radius:.75rem;background:#2563eb}
  </style>
</head>
<body class="min-h-screen">
  <div class="max-w-md mx-auto p-6 space-y-6">
    <header>
      <h1 class="text-xl font-bold">UNKNOWN // Visitor</h1>
      <!-- Version string bumped in the HTML body -->
      <p class="text-xs text-gray-400 mono">UNKNOWN_V5.4_BODY</p>
    </header>

    <div class="rounded-xl border border-[#1f2430] bg-[#11141a] p-4 space-y-3">
      <div class="text-sm"><span class="muted">connection:</span> <span id="connState" class="mono">—</span></div>
      <div class="text-sm"><span class="muted">status:</span> <span id="status" class="mono">—</span></div>
      <button id="startBtn" disabled class="w-full py-3 rounded-lg bg-emerald-600 disabled:opacity-50">Start recording</button>
      <progress id="progress" max="100" value="0" class="w-full"></progress>
      <a id="download" class="btn" style="display:none">Download</a>
      <video id="preview" playsinline controls style="width:100%;display:none;border-radius:.75rem"></video>
      <p id="note" class="text-xs text-gray-400"></p>
    </div>

    <footer class="text-xs text-gray-500">
      Scanned from on-site display. If connection stalls, wait a few seconds — it retries automatically.
    </footer>
  </div>

  <script>
    // ----------- Helpers -----------
    function qs(k){ return new URLSearchParams(location.search).get(k); }
    const els = {
      btn: document.getElementById('startBtn'),
      conn: document.getElementById('connState'),
      status: document.getElementById('status'),
      progress: document.getElementById('progress'),
      dl: document.getElementById('download'),
      video: document.getElementById('preview'),
      note: document.getElementById('note')
    };
    function setConn(txt, ok=false){ els.conn.textContent = txt; els.conn.className = ok?'ok mono':'muted mono'; }
    function setStatus(txt, ok=true){ els.status.textContent = txt; els.status.className = ok?'ok mono':'bad mono'; }

    const hostId = qs('host'); const token = qs('token');
    if (!hostId || !token){ setStatus('missing params', false); throw new Error('missing host/token'); }

    // Detect WebM playback support — Safari on some versions can’t play inline, but download still works
    const supportsWebM = (window.MediaSource && MediaSource.isTypeSupported) &&
      (MediaSource.isTypeSupported('video/webm;codecs=vp9') || MediaSource.isTypeSupported('video/webm;codecs=vp8'));
    if (!supportsWebM) els.note.textContent = 'Your browser may not preview WebM inline. Use the download button to save/open the file.';

    const ICE_SERVERS = [
      { urls: [
        'stun:stun.l.google.com:19302',
        'stun:stun1.l.google.com:19302',
        'stun:stun2.l.google.com:19302',
        'stun:stun.cloudflare.com:3478'
      ] }
    ];

    let conn = null;
    let chunks = [];
    let expectedBytes = 0, received = 0;
    let mime = 'video/webm';
    let filename = 'capture.webm';

    const peer = new Peer(undefined, {
      debug: 1,
      config: { iceServers: ICE_SERVERS, iceTransportPolicy: 'all' }
    });

    function attachConnHandlers(dc){
      dc.on('open', () => {
        setConn('connected', true);
        dc.send(JSON.stringify({ type:'hello', token, supportsWebM }));
        els.btn.disabled = false;
      });

      dc.on('data', (msg) => {
        if (typeof msg === 'string'){
          const data = JSON.parse(msg);
          if (data.type === 'helloAck'){
            setStatus('ready');
          } else if (data.type === 'recordingMeta'){
            mime = data.mime || 'video/webm';
            filename = data.filename || (mime.includes('mp4') ? 'capture.mp4' : 'capture.webm');
            expectedBytes = data.totalBytes || 0;
            received = 0; chunks = []; els.progress.value = 0;
            setStatus('receiving…');
          } else if (data.type === 'progress'){
            if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*(data.sent/expectedBytes)));
          } else if (data.type === 'recordingEnd'){
            const blob = new Blob(chunks, { type: mime });
            const url = URL.createObjectURL(blob);
            els.dl.href = url; els.dl.download = filename; els.dl.style.display = 'inline-block';
            els.video.src = url; els.video.style.display = supportsWebM ? 'block' : 'none';
            els.progress.value = 100;
            setStatus('done ✔', true);
          } else if (data.type === 'error'){
            setStatus(data.message || 'error', false);
          }
        } else {
          // Binary: ArrayBuffer or typed array
          const arrayBuffer = msg instanceof ArrayBuffer ? msg : msg.buffer;
          chunks.push(new Uint8Array(arrayBuffer));
          received += arrayBuffer.byteLength || msg.byteLength || 0;
          if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*received/expectedBytes));
        }
      });

      dc.on('close', () => setConn('disconnected'));
      dc.on('error', () => setConn('error'));
    }

    function connectWithTimeout(ms=8000){
      return new Promise((resolve, reject) => {
        let done = false;
        const dc = peer.connect(hostId, { reliable: true });
        conn = dc;
        attachConnHandlers(dc);

        const t = setTimeout(() => {
          if (done) return;
          try { dc.close(); } catch {}
          done = true; reject(new Error('connect-timeout'));
        }, ms);

        dc.on('open', () => { if (done) return; clearTimeout(t); done = true; resolve(dc); });
        dc.on('error', (e) => { if (done) return; clearTimeout(t); done = true; reject(e); });
      });
    }

    peer.on('open', async () => {
      setConn('connecting…');
      try {
        await connectWithTimeout(8000);
      } catch {
        setConn('retrying…');
        setTimeout(() => connectWithTimeout(8000).catch(()=>setConn('failed')), 500);
      }
    });

    peer.on('disconnected', () => {
      setConn('reconnecting…');
      try { peer.reconnect(); } catch {}
    });

    els.btn.addEventListener('click', () => {
      els.btn.disabled = true;
      setStatus('asking host…');
      conn && conn.send(JSON.stringify({ type:'startRecording' }));
      setTimeout(() => { els.btn.disabled = false; }, 8000);
    });
  </script>
</body>
</html>
