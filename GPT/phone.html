<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
(function(){
  function qs(k){ return new URLSearchParams(location.search).get(k); }
  const hostId = qs('host'); const token = qs('token');
  const els = {
    btn: document.getElementById('startBtn'),
    conn: document.getElementById('connState'),
    status: document.getElementById('status'),
    progress: document.getElementById('progress'),
    dl: document.getElementById('download'),
    video: document.getElementById('preview')
  };
  function setConn(txt, ok=false){ els.conn.textContent = txt; els.conn.className = ok?'ok':'muted'; }
  function setStatus(txt, ok=true){ els.status.textContent = txt; els.status.className = ok?'ok':'bad'; }
  function log(...a){ console.log('[PHONE]', ...a); }

  if (!hostId || !token) { setStatus('Missing host or token', false); return; }

  // Detect WebM support
  const supportsWebM = !!(window.MediaSource && MediaSource.isTypeSupported &&
    (MediaSource.isTypeSupported('video/webm;codecs=vp9') || MediaSource.isTypeSupported('video/webm;codecs=vp8')));

  // ✅ Same ICE config as host
  const ICE_CONFIG = {
    iceServers: [
      { urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302'] },
      { urls: 'stun:stun.cloudflare.com:3478' },
    ],
    iceCandidatePoolSize: 4
  };

  const peer = new Peer(undefined, { debug: 2, config: ICE_CONFIG });

  // Reconnect helper if first attempt times out on iOS
  function attemptConnect(){
    setConn('connecting…');
    const conn = peer.connect(hostId, { reliable: true });
    const t = setTimeout(() => {
      if (!conn.open) {
        try { conn.close(); } catch {}
        setConn('timeout, retrying…');
        setTimeout(attemptConnect, 800);
      }
    }, 8000);

    conn.on('open', () => {
      clearTimeout(t);
      setConn('connected', true);
      conn.send(JSON.stringify({ type:'hello', token, supportsWebM }));
      els.btn.disabled = false;
      const pc = conn.peerConnection || conn._pc;
      if (pc) {
        pc.oniceconnectionstatechange = ()=> setStatus('ICE: '+pc.iceConnectionState);
      }
    });

    const chunks = [];
    let expectedBytes = 0, received = 0, mime = 'video/webm', filename = 'capture.webm';

    conn.on('data', (msg) => {
      if (typeof msg === 'string') {
        const data = JSON.parse(msg);
        if (data.type === 'helloAck') setStatus('ready');
        else if (data.type === 'recordingMeta') {
          mime = data.mime || 'video/webm';
          expectedBytes = data.totalBytes || 0;
          filename = data.filename || ('capture.'+(mime.includes('mp4')?'mp4':'webm'));
          chunks.length = 0; received = 0;
          els.progress.value = 0;
          setStatus('receiving…');
        } else if (data.type === 'progress') {
          if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*data.sent/expectedBytes));
        } else if (data.type === 'recordingEnd') {
          const blob = new Blob(chunks, { type: mime });
          const url = URL.createObjectURL(blob);
          els.dl.href = url; els.dl.download = filename; els.dl.style.display='inline-block';
          els.video.src = url; els.video.style.display='block';
          els.progress.value = 100;
          setStatus('done ✔', true);
        } else if (data.type === 'error') {
          setStatus(data.message || 'error', false);
        }
      } else {
        chunks.push(new Uint8Array(msg));
        received += msg.byteLength;
        if (expectedBytes) els.progress.value = Math.min(100, Math.round(100*received/expectedBytes));
      }
    });

    conn.on('close', () => setConn('disconnected'));
    conn.on('error', (e) => { setConn('error'); log('conn error', e); });

    els.btn.onclick = () => {
      els.btn.disabled = true;
      setStatus('asking host…');
      conn && conn.send(JSON.stringify({ type:'startRecording' }));
      setTimeout(() => { els.btn.disabled = false; }, 8000);
    };
  }

  peer.on('open', () => attemptConnect());
  peer.on('error', (e)=> { setStatus('peer error', false); log('peer error', e); });
  peer.on('disconnected', ()=> { setStatus('peer disconnected', false); });
})();
</script>
