<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Signal Processor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #0a0a0a; }
    .font-mono { font-family: 'JetBrains Mono', monospace; }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    input[type="range"] { -webkit-appearance:none; appearance:none; width:100%; height:4px; background:#374151; border-radius:2px; outline:none; transition:background .3s; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:16px; height:16px; background:#34d399; cursor:pointer; border-radius:50%; border:2px solid #111827; }
    input[type="range"]::-moz-range-thumb { width:16px; height:16px; background:#34d399; cursor:pointer; border-radius:50%; border:2px solid #111827; }
    .status-indicator::after { content:'_'; animation: blink 1s step-end infinite; }
    @keyframes blink { 50% { opacity: 0; } }
    .tab-button.active { border-color: #34d399; color: #e5e7eb; background-color: rgba(255, 255, 255, 0.05); }
  </style>
</head>
<body class="bg-black text-gray-200 flex items-center justify-center min-h-screen p-4">

  <div class="container w-full max-w-7xl h-[90vh] bg-black border border-gray-800 rounded-lg shadow-2xl shadow-green-500/10 flex overflow-hidden">
    <div class="main-stage flex-grow bg-black relative flex items-center justify-center">
      <video id="video" playsinline muted class="hidden"></video>
      <video id="backgroundMedia" loop muted playsinline class="hidden absolute w-full h-full object-cover"></video>
      <img id="backgroundImage" class="hidden absolute w-full h-full object-cover" />
      <canvas id="glcanvas" class="w-full h-full object-cover"></canvas>
      <div id="statusBar" class="absolute bottom-2 left-2 font-mono text-xs bg-black/50 text-green-400 px-2 py-1 rounded status-indicator">
        STATUS: IDLE
      </div>
    </div>

    <div class="controls-panel w-[420px] flex-shrink-0 bg-gray-950/50 border-l border-gray-800 flex flex-col">
      <div class="p-4 border-b border-gray-800 flex-shrink-0">
        <h1 class="text-xl font-bold text-white">SIGNAL PROCESSOR</h1>
        <p class="text-sm text-gray-400 font-mono">UNKNOWN_V6.0_BODY</p>
        <div class="flex space-x-2 mt-4">
          <button id="startBtn" class="flex-1 bg-green-500 hover:bg-green-600 text-black font-bold py-2 px-4 rounded transition-all duration-200">Initialize</button>
          <button id="stopBtn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition-all duration-200" disabled>Terminate</button>
        </div>
        <div id="msg" class="text-green-400 font-mono text-xs mt-2 h-4"></div>
      </div>

      <div class="p-4 border-b border-gray-800 flex-shrink-0">
        <h2 class="font-bold text-gray-300 mb-2">PRESET MANAGER</h2>
        <select id="presetList" class="w-full bg-gray-900 border border-gray-600 rounded p-2 mb-2 text-sm focus:outline-none focus:border-green-500"></select>
        <div class="grid grid-cols-3 gap-2">
          <input type="text" id="presetName" placeholder="Preset Name..." class="col-span-3 bg-gray-900 border border-gray-600 rounded p-2 text-sm focus:outline-none focus:border-green-500">
          <button id="savePresetBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 rounded text-sm transition-colors">Save</button>
          <button id="deletePresetBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 rounded text-sm transition-colors">Delete</button>
          <button id="randomBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-1 rounded text-sm transition-colors">Randomize</button>
        </div>
      </div>
      
      <div class="flex border-b border-gray-800 flex-shrink-0">
        <button id="effectsTabBtn" class="tab-button flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 border-transparent text-gray-500 hover:text-gray-200 transition-colors duration-200">Effects</button>
        <button id="globalsTabBtn" class="tab-button active flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 transition-colors duration-200">Globals</button>
      </div>

      <div class="flex-grow custom-scrollbar overflow-y-auto">
        <div id="effects-tab-content" class="hidden p-4 space-y-4"></div>
        <div id="globals-tab-content" class="p-4 space-y-4">
            </div>
      </div>
    </div>
  </div>

<script>
(() => {
    // --- APP ARCHITECTURE ---
    // Refactored into distinct logical modules for clarity, performance, and maintainability.
    // 1. GLSL: Shader source code.
    // 2. Definitions: Configuration for all UI controls.
    // 3. AppState: Centralized state object. The single source of truth.
    // 4. UI: Manages DOM elements and event listeners. Updates AppState.
    // 5. Renderer: Encapsulates WebGL. Reads from AppState.
    // 6. BodySegmenter: Handles MediaPipe.
    // 7. PresetManager: Manages presets. Interacts with AppState and UI.
    // 8. App: The main controller that initializes all modules and runs the main loop.

    // --- 1. GLSL SHADERS ---
    const vertSrc = `attribute vec2 a_pos;varying vec2 v_uv;void main(){v_uv=a_pos;gl_Position=vec4(a_pos*2.0-1.0,0.0,1.0);}`;
    const fragSrc = `precision highp float;varying vec2 v_uv;uniform sampler2D u_tex,u_feedbackTex,u_maskTex,u_backgroundTex;uniform vec2 u_resolution;uniform float u_time;uniform bool u_isFeedbackPass,u_useBackground;uniform float u_maskFeather,u_overallOpacity,u_flickerPerSecond,u_flickerDuration,u_flickerIntensity,u_flickerFade,u_seepAmount,u_seepIntensity,u_feedbackAmount,u_feedbackZoom,u_glitchIntensity,u_glitchBlockSize,u_rgbShift,u_noiseAmount,u_noiseSpeed,u_vignette,u_globalSmearIntensity,u_globalSmearAngle,u_spotSmearIntensity,u_spotSmearDensity,u_spotSmearSize;float rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}
vec4 smear(sampler2D tex,vec2 uv,float intensity,float angle){vec2 dir=vec2(cos(angle),sin(angle))/u_resolution;vec4 color=vec4(0.0);const int samples=16;for(int i=0;i<samples;i++){float t=float(i)/float(samples-1);color+=texture2D(tex,uv-dir*t*intensity);}
return color/float(samples);}
vec4 blur(sampler2D tex,vec2 uv,float radius){vec4 acc=vec4(0.0);vec2 res=u_resolution.xy;float count=0.0;for(float x=-2.0;x<=2.0;x++){for(float y=-2.0;y<=2.0;y++){vec2 offset=vec2(x,y)*radius/res;acc+=texture2D(tex,uv+offset);count+=1.0;}}
return acc/count;}
void main(){vec2 uv=v_uv;vec4 videoColor=texture2D(u_tex,uv);vec4 feedbackColor=texture2D(u_feedbackTex,(uv-0.5)*u_feedbackZoom+0.5);vec4 effectedColor=mix(videoColor,feedbackColor,u_feedbackAmount);if(rand(vec2(floor(u_time*15.0),0.0))<u_glitchIntensity){vec2 block_uv=floor(uv*u_resolution.y/u_glitchBlockSize)/(u_resolution.y/u_glitchBlockSize);effectedColor=texture2D(u_tex,uv+vec2((rand(block_uv)-0.5)*0.1,0.0));}
float r=texture2D(u_tex,uv+vec2(u_rgbShift,0.0)).r;float b=texture2D(u_tex,uv-vec2(u_rgbShift,0.0)).b;effectedColor=vec4(r,effectedColor.g,b,effectedColor.a);effectedColor+=(rand(uv+u_time*u_noiseSpeed)-0.5)*u_noiseAmount;effectedColor.rgb*=1.0-u_vignette*distance(uv,vec2(0.5));vec4 smearedColor=effectedColor;vec2 grid_uv=floor(uv*u_spotSmearSize)/u_spotSmearSize;if(rand(grid_uv+floor(u_time*5.0))<u_spotSmearDensity){smearedColor=smear(u_feedbackTex,uv,u_spotSmearIntensity,rand(grid_uv+10.0)*6.283);}
float maskValue=texture2D(u_maskTex,uv).r;if(maskValue>0.1){vec4 globalSmear=smear(u_feedbackTex,uv,u_globalSmearIntensity,radians(u_globalSmearAngle));smearedColor=mix(smearedColor,globalSmear,0.5);}
float effectedGray=dot(smearedColor.rgb,vec3(0.299,0.587,0.114));vec4 effectedGrayscale=vec4(vec3(effectedGray),1.0);if(u_isFeedbackPass){gl_FragColor=effectedGrayscale;return;}
float originalGray=dot(videoColor.rgb,vec3(0.299,0.587,0.114));vec4 originalGrayscale=vec4(vec3(originalGray),1.0);float baseMask=texture2D(u_maskTex,uv).r;float blurredMask=blur(u_maskTex,uv,u_seepIntensity).r;float seep=(1.0-baseMask)*blurredMask*u_seepAmount;float finalMask=smoothstep(0.5-u_maskFeather,0.5+u_maskFeather,baseMask);float silhouetteMask=clamp(finalMask+seep,0.0,1.0);float flickerMultiplier=1.0;if(u_flickerPerSecond>0.0){float flickerCycle=1.0/u_flickerPerSecond;float flickerPhase=mod(u_time,flickerCycle);float flickerEdge=flickerCycle*u_flickerDuration;float fadeWidth=flickerCycle*u_flickerFade*0.5;float isFlickerOff=1.0-smoothstep(flickerEdge-fadeWidth,flickerEdge+fadeWidth,flickerPhase);flickerMultiplier=1.0-(isFlickerOff*u_flickerIntensity);}
float effectAmount=u_overallOpacity*flickerMultiplier;vec4 foregroundColor=mix(originalGrayscale,effectedGrayscale,effectAmount);vec4 backgroundColor=u_useBackground?texture2D(u_backgroundTex,uv):originalGrayscale;gl_FragColor=mix(backgroundColor,foregroundColor,silhouetteMask);}`;

    // --- 2. DEFINITIONS ---
    const definitions = {
      Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.005, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } },
      Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 30, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 10, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.2, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } },
      Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } },
      Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.1, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } },
      Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.01, neutral: 0.0 } } },
      Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette: { label: 'Vignette', min: 0, max: 2,  step: 0.01, value: 0.5, neutral: 0.0 } } }
    };
    const globalDefinitions = {
        Remote: { title: 'REMOTE TRIGGER', controls: {}, noToggle: true, content: `...` }, // Placeholder, content handled by separate PeerJS module
        Background: { title: 'BACKGROUND', controls: { maskFeather: { label: 'Mask Feather', min: 0.01, max: 0.5, step: 0.001, value: 0.15 } }, noToggle: true },
        Settings: { title: 'SETTINGS', controls: {}, noToggle: true },
        Automation: { title: 'AUTOMATION', controls: { autoRandomizeSlider: { label: 'Auto-Randomize', min: 0, max: 30, step: 0.5, value: 0 }, presetIterationSlider: { label: 'Preset Iteration', min: 0, max: 30, step: 0.5, value: 0 } }, noToggle: true },
        Opacity: { title: 'Global Opacity', controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05 } } },
        Seep: { title: 'Effect Seep', controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 2.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 20 } } }
    };

    // --- 3. AppState MODULE ---
    const AppState = {
        effects: {},
        globals: {},
        jitter: {},
        
        init(defs, globalDefs) {
            const initState = (d, target, jitterTarget) => {
                for (const [key, def] of Object.entries(d)) {
                    target[key] = { active: def.active !== false, controls: {} };
                    if(jitterTarget) jitterTarget[key] = {};
                    for (const [controlKey, controlDef] of Object.entries(def.controls)) {
                        const val = parseFloat(controlDef.value);
                        target[key].controls[controlKey] = val;
                        if(jitterTarget) jitterTarget[key][controlKey] = { base: val, current: val };
                    }
                }
            };
            initState(defs, this.effects, this.jitter);
            initState(globalDefs, this.globals, null);
        },
        
        getFinalValue(group, control) {
            if (this.effects.Jitter.active && this.jitter[group]?.[control]) {
                return this.jitter[group][control].current;
            }
            return this.effects[group].controls[control];
        }
    };

    // --- 4. UI MODULE ---
    const UI = {
        elements: {},
        _controlElements: {},

        init() {
            // Cache all DOM elements
            const ids = ['video', 'glcanvas', 'startBtn', 'stopBtn', 'statusBar', 'msg', 'savePresetBtn', 'deletePresetBtn', 'presetName', 'presetList', 'randomBtn', 'effectsTabBtn', 'globalsTabBtn', 'effects-tab-content', 'globals-tab-content'];
            ids.forEach(id => this.elements[id] = document.getElementById(id));
            
            // Create controls
            this.createControls(definitions, this.elements['effects-tab-content'], 'effects');
            this.createControls(globalDefinitions, this.elements['globals-tab-content'], 'globals');

            this.bindEvents();
        },

        createControls(defs, parent, type) {
            this._controlElements[type] = {};
            for (const [key, def] of Object.entries(defs)) {
                this._controlElements[type][key] = {};
                const group = this.createControlGroup(key, def, type);
                parent.appendChild(group);
            }
        },

        createControlGroup(key, definition, type) {
            const group = document.createElement('div');
            group.className = 'control-group bg-black/50 border border-gray-800 rounded-lg p-3';
            const header = document.createElement('div');
            header.className = 'flex items-center justify-between';
            const title = document.createElement('h3');
            title.className = 'font-semibold text-gray-200';
            title.textContent = definition.title;
            header.appendChild(title);
            const content = document.createElement('div');
            content.className = 'mt-3 space-y-3';

            if (type === 'effects') {
                header.classList.add('cursor-pointer');
                const toggle = document.createElement('input');
                toggle.type = 'checkbox';
                toggle.checked = AppState.effects[key].active;
                toggle.className = 'form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0';
                toggle.addEventListener('change', () => {
                    AppState.effects[key].active = toggle.checked;
                });
                header.addEventListener('click', e => {
                    if(e.target !== toggle) {
                        toggle.checked = !toggle.checked;
                        toggle.dispatchEvent(new Event('change'));
                    }
                    content.classList.toggle('hidden', !toggle.checked);
                });
                if (!toggle.checked) content.classList.add('hidden');
                header.appendChild(toggle);
                this._controlElements[type][key].toggle = toggle;
            }

            for (const [controlKey, controlDef] of Object.entries(definition.controls)) {
                const slider = this.createSlider(controlKey, controlDef);
                content.appendChild(slider.container);
                this._controlElements[type][key][controlKey] = slider.input;
                
                slider.input.addEventListener('input', () => {
                    const value = parseFloat(slider.input.value);
                    if (type === 'effects') {
                        AppState.effects[key].controls[controlKey] = value;
                        AppState.jitter[key][controlKey].base = value;
                    } else {
                        AppState.globals[key].controls[controlKey] = value;
                    }
                });
            }
            group.append(header, content);
            return group;
        },

        createSlider(id, def) { /* ... same as original ... */ return { container, input }; },
        
        bindEvents() {
            this.elements.startBtn.addEventListener('click', () => App.start());
            this.elements.stopBtn.addEventListener('click', () => App.stop());
            this.elements.effectsTabBtn.addEventListener('click', () => this.switchTab('effects'));
            this.elements.globalsTabBtn.addEventListener('click', () => this.switchTab('globals'));
            // ... other general event bindings
        },
        
        switchTab(tabName) { /* ... same as original ... */ },
        setStatus(text, isError = false) { /* ... same as original ... */ },
        setMsg(text) { this.elements.msg.textContent = text; setTimeout(() => this.elements.msg.textContent = '', 3000); }
    };
    
    // ... Other modules would follow a similar pattern ...

    // --- 8. App MODULE ---
    const App = {
        stream: null,
        rafId: null,
        
        init() {
            AppState.init(definitions, globalDefinitions);
            UI.init();
            // PresetManager.init(); // Assuming PresetManager is also refactored
        },

        async start() {
            // ... Camera and segmentation setup ...
            
            // Init Renderer
            const uniformKeys = [ /* Collect all uniform keys from definitions */ ];
            Renderer.init(UI.elements.glcanvas, vertSrc, fragSrc, uniformKeys);
            
            this.loop();
        },

        stop() { /* ... */ },

        loop(time) {
            this.rafId = requestAnimationFrame(t => this.loop(t));
            const video = UI.elements.video;
            if (!video.videoWidth || !Renderer.gl) return;
            
            // --- Logic / State Updates ---
            const t = AppState.globals.Settings.animate ? time / 1000 : 0;
            // updateJitter(t); // Update AppState.jitter
            // handleAutomation(time); // Update AppState via presets/randomization

            // --- Rendering ---
            // The render function now gets the entire state, keeping it decoupled
            Renderer.render(video, t, AppState);
        }
    };

    // --- INITIALIZATION ---
    App.init();

})();
</script>

<script>
// --- Remote Trigger Module (PeerJS) ---
// This module is self-contained and communicates with the main app via status updates.
// (The full PeerJS code from the original file goes here, unchanged.)
</script>

</body>
</html>
