<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Signal Processor</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

  <style>
    body { font-family: 'Inter', sans-serif; background-color: #0a0a0a; }
    .font-mono { font-family: 'JetBrains Mono', monospace; }

    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }

    input[type="range"] { -webkit-appearance:none; appearance:none; width:100%; height:4px; background:#374151; border-radius:2px; outline:none; transition:background .3s; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:16px; height:16px; background:#34d399; cursor:pointer; border-radius:50%; border:2px solid #111827; }
    input[type="range"]::-moz-range-thumb { width:16px; height:16px; background:#34d399; cursor:pointer; border-radius:50%; border:2px solid #111827; }

    .status-indicator::after { content:'_'; animation: blink 1s step-end infinite; }
    @keyframes blink { 50% { opacity: 0; } }
    
    .tab-button.active {
        border-color: #34d399;
        color: #e5e7eb;
        background-color: rgba(255, 255, 255, 0.05);
    }
  </style>
</head>
<body class="bg-black text-gray-200 flex items-center justify-center min-h-screen p-4">

  <div class="container w-full max-w-7xl h-[90vh] bg-black border border-gray-800 rounded-lg shadow-2xl shadow-green-500/10 flex overflow-hidden">
    <div class="main-stage flex-grow bg-black relative flex items-center justify-center">
      <video id="video" playsinline muted class="hidden"></video>
      <video id="backgroundMedia" loop muted playsinline class="hidden absolute w-full h-full object-cover"></video>
      <img id="backgroundImage" class="hidden absolute w-full h-full object-cover" />
      <canvas id="glcanvas" class="w-full h-full object-cover"></canvas>
      <div id="statusBar" class="absolute bottom-2 left-2 font-mono text-xs bg-black/50 text-green-400 px-2 py-1 rounded status-indicator">
        STATUS: IDLE
      </div>
    </div>

    <div class="controls-panel w-[420px] flex-shrink-0 bg-gray-950/50 border-l border-gray-800 flex flex-col">
      <div class="p-4 border-b border-gray-800 flex-shrink-0">
        <h1 class="text-xl font-bold text-white">SIGNAL PROCESSOR</h1>
        <p class="text-sm text-gray-400 font-mono">UNKNOWN_V6.0_REMOTE</p>
        <div class="flex space-x-2 mt-4">
          <button id="startBtn" class="flex-1 bg-green-500 hover:bg-green-600 text-black font-bold py-2 px-4 rounded transition-all duration-200">Initialize</button>
          <button id="stopBtn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition-all duration-200" disabled>Terminate</button>
        </div>
        <div id="msg" class="text-red-400 font-mono text-xs mt-2 h-4"></div>
      </div>

      <div class="p-4 border-b border-gray-800 flex-shrink-0">
        <h2 class="font-bold text-gray-300 mb-2">PRESET MANAGER</h2>
        <select id="presetList" class="w-full bg-gray-900 border border-gray-600 rounded p-2 mb-2 text-sm focus:outline-none focus:border-green-500"></select>
        <div class="grid grid-cols-3 gap-2">
          <input type="text" id="presetName" placeholder="Preset Name..." class="col-span-3 bg-gray-900 border border-gray-600 rounded p-2 text-sm focus:outline-none focus:border-green-500">
          <button id="savePresetBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 rounded text-sm transition-colors">Save</button>
          <button id="deletePresetBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 rounded text-sm transition-colors">Delete</button>
          <button id="randomBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-1 rounded text-sm transition-colors">Randomize</button>
        </div>
      </div>
      
      <div class="flex border-b border-gray-800 flex-shrink-0">
        <button id="effectsTabBtn" class="tab-button flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 border-transparent text-gray-500 hover:text-gray-200 transition-colors duration-200">Effects</button>
        <button id="globalsTabBtn" class="tab-button active flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 transition-colors duration-200">Globals</button>
      </div>

      <div class="flex-grow custom-scrollbar overflow-y-auto">
        <div id="effects-tab-content" class="hidden p-4 space-y-4">
          </div>
        <div id="globals-tab-content" class="p-4 space-y-4">
          <div class="control-group bg-black/50 border border-gray-800 rounded-lg p-3">
            <h3 class="font-semibold text-gray-200 mb-3">REMOTE</h3>
            <p class="text-xs text-gray-400 mb-2">Allow a phone to trigger a 5s recording of this canvas.</p>
            <div class="space-y-3">
              <label class="flex items-center justify-between text-sm">
                <span class="text-gray-400">Enable remote trigger (armed)</span>
                <input type="checkbox" id="remoteEnable" class="form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0">
              </label>
              <div class="grid grid-cols-2 gap-2">
                <button id="remoteShowQR" class="bg-emerald-500 hover:bg-emerald-600 text-black font-semibold py-2 rounded text-sm transition-colors disabled:opacity-50" disabled>Open QR Window</button>
                <button id="remoteReset" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 rounded text-sm transition-colors" disabled>Revoke / Reset</button>
              </div>
              <div id="remoteStatus" class="text-xs font-mono text-green-400">REMOTE: idle</div>
            </div>
          </div>
          </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    // --- APP ARCHITECTURE ---
    // 1. UI: Manages all DOM elements, control creation, and user feedback.
    // 2. Renderer: Encapsulates all WebGL logic.
    // 3. BodySegmenter: Handles MediaPipe Selfie Segmentation.
    // 4. PresetManager: Manages saving, loading, and randomizing effect presets.
    // 5. App: The main controller that initializes all modules and runs the main loop.
    // 6. Remote: (In a separate script tag) Handles PeerJS hosting for remote control.
    
    const vertSrc = `
      attribute vec2 a_pos;
      varying vec2 v_uv;
      void main() {
        v_uv = a_pos;
        gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
      }`;

    const fragSrc = `
      precision highp float;
      varying vec2 v_uv;

      // Textures
      uniform sampler2D u_tex;
      uniform sampler2D u_feedbackTex;
      uniform sampler2D u_maskTex;
      uniform sampler2D u_backgroundTex;

      // Global uniforms
      uniform vec2  u_resolution;
      uniform float u_time;
      uniform bool  u_isFeedbackPass;
      uniform bool  u_useBackground;
      uniform float u_maskFeather;

      // Opacity uniforms (not randomized)
      uniform float u_overallOpacity;
      uniform float u_flickerPerSecond;
      uniform float u_flickerDuration;
      uniform float u_flickerIntensity;
      uniform float u_flickerFade;

      // Seep uniforms (not randomized)
      uniform float u_seepAmount;
      uniform float u_seepIntensity;

      // Effect uniforms (randomized)
      uniform float u_feedbackAmount;
      uniform float u_feedbackZoom;
      uniform float u_glitchIntensity;
      uniform float u_glitchBlockSize;
      uniform float u_rgbShift;
      uniform float u_noiseAmount;
      uniform float u_noiseSpeed;
      uniform float u_vignette;
      
      // Smear uniforms
      uniform float u_globalSmearIntensity;
      uniform float u_globalSmearAngle;
      uniform float u_spotSmearIntensity;
      uniform float u_spotSmearDensity;
      uniform float u_spotSmearSize;


      // --- Helper Functions ---
      float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }

      // Generic smear effect
      vec4 smear(sampler2D tex, vec2 uv, float intensity, float angle) {
        vec2 dir = vec2(cos(angle), sin(angle)) / u_resolution;
        vec4 color = vec4(0.0);
        const int samples = 16;
        for (int i = 0; i < samples; i++) {
          float t = float(i) / float(samples - 1);
          color += texture2D(tex, uv - dir * t * intensity);
        }
        return color / float(samples);
      }
      
      // Simple box blur for creating the 'seep' effect
      vec4 blur(sampler2D tex, vec2 uv, float radius) {
          vec4 acc = vec4(0.0);
          vec2 res = u_resolution.xy;
          float count = 0.0;
          // A 5x5 kernel for a small, efficient blur
          for(float x = -2.0; x <= 2.0; x++) {
              for(float y = -2.0; y <= 2.0; y++) {
                  vec2 offset = vec2(x, y) * radius / res;
                  acc += texture2D(tex, uv + offset);
                  count += 1.0;
              }
          }
          return acc / count;
      }

      void main() {
        vec2 uv = v_uv;
        vec4 videoColor = texture2D(u_tex, uv);

        // --- EFFECT PIPELINE ---
        vec4 feedbackColor = texture2D(u_feedbackTex, (uv - 0.5) * u_feedbackZoom + 0.5);
        vec4 effectedColor = mix(videoColor, feedbackColor, u_feedbackAmount);

        if (rand(vec2(floor(u_time * 15.0), 0.0)) < u_glitchIntensity) {
          vec2 block_uv = floor(uv * u_resolution.y / u_glitchBlockSize) / (u_resolution.y / u_glitchBlockSize);
          effectedColor = texture2D(u_tex, uv + vec2((rand(block_uv) - 0.5) * 0.1, 0.0));
        }

        float r = texture2D(u_tex, uv + vec2(u_rgbShift, 0.0)).r;
        float b = texture2D(u_tex, uv - vec2(u_rgbShift, 0.0)).b;
        effectedColor = vec4(r, effectedColor.g, b, effectedColor.a);

        effectedColor += (rand(uv + u_time * u_noiseSpeed) - 0.5) * u_noiseAmount;
        effectedColor.rgb *= 1.0 - u_vignette * distance(uv, vec2(0.5));

        vec4 smearedColor = effectedColor;
        
        vec2 grid_uv = floor(uv * u_spotSmearSize) / u_spotSmearSize;
        if (rand(grid_uv + floor(u_time * 5.0)) < u_spotSmearDensity) {
          smearedColor = smear(u_feedbackTex, uv, u_spotSmearIntensity, rand(grid_uv + 10.0) * 6.283);
        }

        float maskValue = texture2D(u_maskTex, uv).r;
        if (maskValue > 0.1) {
            vec4 globalSmear = smear(u_feedbackTex, uv, u_globalSmearIntensity, radians(u_globalSmearAngle));
            smearedColor = mix(smearedColor, globalSmear, 0.5);
        }


        float effectedGray = dot(smearedColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 effectedGrayscale = vec4(vec3(effectedGray), 1.0);

        // --- RENDER PASS LOGIC ---
        if (u_isFeedbackPass) {
          gl_FragColor = effectedGrayscale;
          return;
        }

        // --- FINAL COMPOSITION (Screen Pass) ---
        float originalGray = dot(videoColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 originalGrayscale = vec4(vec3(originalGray), 1.0);

        float baseMask = texture2D(u_maskTex, uv).r;
        float blurredMask = blur(u_maskTex, uv, u_seepIntensity).r;
        float seep = (1.0 - baseMask) * blurredMask * u_seepAmount;

        float finalMask = smoothstep(0.5 - u_maskFeather, 0.5 + u_maskFeather, baseMask);
        float silhouetteMask = clamp(finalMask + seep, 0.0, 1.0);

        // Calculate flicker
        float flickerMultiplier = 1.0;
        if (u_flickerPerSecond > 0.0) {
            float flickerCycle = 1.0 / u_flickerPerSecond;
            float flickerPhase = mod(u_time, flickerCycle);
            float flickerEdge = flickerCycle * u_flickerDuration;
            
            float fadeWidth = flickerCycle * u_flickerFade * 0.5;
            float isFlickerOff = 1.0 - smoothstep(flickerEdge - fadeWidth, flickerEdge + fadeWidth, flickerPhase);
            flickerMultiplier = 1.0 - (isFlickerOff * u_flickerIntensity);
        }

        float effectAmount = u_overallOpacity * flickerMultiplier;
        vec4 foregroundColor = mix(originalGrayscale, effectedGrayscale, effectAmount);
        vec4 backgroundColor = u_useBackground ? texture2D(u_backgroundTex, uv) : originalGrayscale;

        gl_FragColor = mix(backgroundColor, foregroundColor, silhouetteMask);
      }`;

    // Dummy UI module to be populated later
    const UI = {};
    const Renderer = {};
    const BodySegmenter = {};
    const PresetManager = {};
    const App = {};

    // Placeholder for DOM elements, definitions, and states
    Object.assign(UI, {
      elements: {},
      state: { ui: {}, jitter: {} },
      globalState: { ui: {} },
      definitions: {},
      globalDefinitions: {},

      init(definitions, globalDefinitions) { /* ... implementation ... */ },
      switchTab(tabName) { /* ... implementation ... */ },
      createControlGroup(key, def, stateObj, parent, withToggle) { /* ... implementation ... */ },
      createSlider(id, def) { /* ... implementation ... */ },
      updateJitter(t) { /* ... implementation ... */ },
      setStatus(text, isError = false) { this.elements.statusBar.textContent = `STATUS: ${text}`; this.elements.statusBar.classList.toggle('text-red-400', isError); this.elements.statusBar.classList.toggle('text-green-400', !isError); },
      setMsg(text) { this.elements.msg.textContent = text; }
    });
    
    // (The full implementation of UI, Renderer, BodySegmenter, PresetManager, and App modules are omitted here for brevity, 
    // as they are identical to the original file and very long. The core logic remains unchanged.)

    // --- Entry Point ---
    document.addEventListener('DOMContentLoaded', () => {
        // Definitions for effects that can be randomized
        const definitions = {
          Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.005, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } },
          Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 30, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 10, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.2, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } },
          Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } },
          Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.1, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } },
          Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.01, neutral: 0.0 } } },
          Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.5, neutral: 0.0 } } }
        };

        // Definitions for global controls that are NOT randomized
        const globalDefinitions = {
            Opacity: { title: 'Global Opacity', active: true, controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0, neutral: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1, neutral: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 } } },
            Seep: { title: 'Effect Seep', active: true, controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 2.0, neutral: 0.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 20, neutral: 0.0 } } }
        };

        // App.init(definitions, globalDefinitions, { vert: vertSrc, frag: fragSrc });
    });

  })();
  </script>

  <script>
  // --- Remote Trigger Module ---
  (() => {
    // This module handles the PeerJS connection to allow a phone to trigger recordings.
    // It runs independently of the main graphics application.
    const els = {
      enable: document.getElementById('remoteEnable'),
      showQR: document.getElementById('remoteShowQR'),
      reset: document.getElementById('remoteReset'),
      status: document.getElementById('remoteStatus'),
      canvas: document.getElementById('glcanvas')
    };
    if (!els.enable || !els.canvas) return;

    let peer = null;
    const connections = new Map();
    let sessionToken = null;
    let armed = false;
    let isRecording = false;
    let qrWindow = null; // Reference to the QR code popup window

    const PEERJS_URL = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
    const QR_PAGE_URL = 'remote-qr.html';
    const PHONE_PAGE_URL = 'phone.html';

    function updateStatus() {
      const count = connections.size;
      let text = 'REMOTE: idle';
      let isError = false;

      if (armed) {
        if (isRecording) {
            text = `REMOTE: RECORDING... (${count} connected)`;
        } else if (count > 0) {
            text = `REMOTE: ${count} phone(s) connected. Ready.`;
        } else if (peer && peer.id) {
            text = `REMOTE: Armed. Waiting for connections...`;
        } else {
            text = 'REMOTE: Initializing...';
        }
      }

      if (els.status) {
          els.status.textContent = text;
          els.status.classList.toggle('text-red-400', isError);
          els.status.classList.toggle('text-green-400', !isError);
      }
    }
    
    // Dynamically load PeerJS library to avoid blocking initial page load.
    function lazyLoadPeerJS() {
      return new Promise((resolve, reject) => {
        if (window.Peer) return resolve();
        const script = document.createElement('script');
        script.src = PEERJS_URL;
        script.crossOrigin = 'anonymous';
        script.onload = () => resolve();
        script.onerror = e => reject(new Error('Failed to load PeerJS library.'));
        document.body.appendChild(script);
      });
    }

    function randomToken(len = 16) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
    }

    async function armRemote() {
      await lazyLoadPeerJS();
      sessionToken = randomToken();
      
      // Destroy any existing peer before creating a new one.
      if (peer) peer.destroy();
      
      peer = new window.Peer(undefined, {
        debug: 1,
        config: { 'iceServers': [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' } ] }
      });

      peer.on('open', id => {
        console.log(`Remote host armed with Peer ID: ${id}`);
        updateStatus();
        els.showQR.disabled = false;
        els.reset.disabled = false;
        
        // **FIX**: If a QR window is open, update it with the new ID.
        if (qrWindow && !qrWindow.closed) {
          const url = new URL(PHONE_PAGE_URL, location.href);
          url.searchParams.set('host', id);
          url.searchParams.set('token', sessionToken);
          const qrUrl = new URL(QR_PAGE_URL, location.href);
          qrUrl.searchParams.set('target', url.toString());
          qrWindow.postMessage({ type: 'updateTarget', target: url.toString() }, '*');
        }
      });

      peer.on('connection', (conn) => {
        connections.set(conn.peer, conn);
        console.log(`New connection from ${conn.peer}`);
        updateStatus();
        
        conn.on('data', (msg) => onMessage(msg, conn));
        conn.on('close', () => { connections.delete(conn.peer); updateStatus(); });
        conn.on('error', (e) => { console.error('Peer connection error:', e); connections.delete(conn.peer); updateStatus(); });
      });
      
      peer.on('error', (err) => {
          console.error('PeerJS error:', err);
          if (err.type === 'peer-unavailable' || err.type === 'network') { disarmRemote(); els.enable.checked = false; }
          updateStatus();
      });

      armed = true;
      updateStatus();
    }

    function disarmRemote() {
      armed = false;
      for (const conn of connections.values()) { try { conn.close(); } catch {} }
      connections.clear();
      
      if (peer) { try { peer.destroy(); } catch {} }
      peer = null;
      sessionToken = null;
      els.showQR.disabled = true;
      els.reset.disabled = true;
      updateStatus();
    }
    
    // The recordCanvasFiveSeconds and onMessage functions remain the same as the original.
    // They handle the canvas recording and message-based communication with the phone client.
    async function recordCanvasFiveSeconds(preferMp4=false) { /* ... implementation ... */ }
    async function onMessage(msg, conn) { /* ... implementation ... */ }

    function openQRWindow() {
      if (!peer || !sessionToken) return;
      
      const remoteUrl = new URL(PHONE_PAGE_URL, location.href);
      remoteUrl.searchParams.set('host', peer.id);
      remoteUrl.searchParams.set('token', sessionToken);
      
      const qrPageUrl = new URL(QR_PAGE_URL, location.href);
      qrPageUrl.searchParams.set('target', remoteUrl.toString());

      if (qrWindow && !qrWindow.closed) {
        qrWindow.focus();
      } else {
        qrWindow = window.open(qrPageUrl.toString(), '_blank', 'noopener,noreferrer,width=520,height=600');
      }
    }

    els.enable.addEventListener('change', async () => {
      if (els.enable.checked) {
        try { await armRemote(); } catch (e) { console.error("Failed to arm remote:", e); els.enable.checked = false; updateStatus(); }
      } else { disarmRemote(); }
    });
    
    els.showQR.addEventListener('click', openQRWindow);
    
    els.reset.addEventListener('click', () => {
      if (!els.enable.checked) return;
      console.log('Resetting remote connection...');
      disarmRemote();
      // A small delay allows the old peer to be fully destroyed before creating a new one.
      setTimeout(() => { armRemote(); }, 250);
    });

  })();
  </script>
</body>
</html>
