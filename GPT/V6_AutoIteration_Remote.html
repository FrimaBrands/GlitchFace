<script>
/* --- Remote Trigger Module (iOS-friendly, extra debugging) --- */
(() => {
  const els = {
    enable: document.getElementById('remoteEnable'),
    showQR: document.getElementById('remoteShowQR'),
    reset: document.getElementById('remoteReset'),
    status: document.getElementById('remoteStatus'),
    canvas: document.getElementById('glcanvas')
  };
  if (!els.enable || !els.canvas) return;

  let peer = null;
  const connections = new Map();
  let sessionToken = null;
  let armed = false;
  let isRecording = false;
  let qrWin = null;

  // ✅ Explicit ICE config (STUN only; TURN optional hook left below)
  const ICE_CONFIG = {
    iceServers: [
      { urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302'] },
      { urls: 'stun:stun.cloudflare.com:3478' },
      // { urls: 'turn:YOUR_TURN_HOST', username: 'USER', credential: 'PASS' }, // optional
    ],
    iceCandidatePoolSize: 4
  };

  const PEER_JS_URL = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
  const QR_URL = 'remote-qr.html';
  const PHONE_URL = 'phone.html';

  function log(...a){ console.log('[HOST]', ...a); }
  function warn(...a){ console.warn('[HOST]', ...a); }
  function err(...a){ console.error('[HOST]', ...a); }

  function updateStatus() {
    const count = connections.size;
    let text = 'REMOTE: idle';
    let good = true;

    if (armed) {
      if (isRecording) {
        text = `REMOTE: RECORDING... (${count} connected)`;
      } else if (count > 0) {
        text = `REMOTE: ${count} phone(s) connected. Ready.`;
      } else if (peer && peer.id) {
        text = `REMOTE: armed @ ${peer.id.slice(0,6)}… waiting for connections`;
      } else {
        text = 'REMOTE: arming...';
      }
    }

    if (els.status) {
      els.status.textContent = text;
      els.status.classList.toggle('text-red-400', !good);
      els.status.classList.toggle('text-green-400', good);
    }
  }

  function lazyLoadPeerJS() {
    return new Promise((resolve, reject) => {
      if (window.Peer) return resolve();
      const s = document.createElement('script');
      s.src = PEER_JS_URL; s.crossOrigin = 'anonymous';
      s.onload = resolve;
      s.onerror = () => reject(new Error('Failed to load PeerJS'));
      document.body.appendChild(s);
    });
  }

  function randomToken(len=24) {
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    return Array.from(arr, b => b.toString(16).padStart(2,'0')).join('');
  }

  async function armRemote() {
    await lazyLoadPeerJS();
    sessionToken = randomToken(16);

    // ✅ Provide ICE config + higher debug for iOS
    peer = new window.Peer(undefined, {
      debug: 2,
      config: ICE_CONFIG
    });

    peer.on('open', id => {
      log('Peer open:', id);
      updateStatus();
      els.showQR.disabled = false;
      els.reset.disabled = false;

      // If QR window is already open, update it in-place (no need to reopen)
      if (qrWin && !qrWin.closed) {
        const url = new URL(PHONE_URL, location.href);
        url.searchParams.set('host', id);
        url.searchParams.set('token', sessionToken);
        qrWin.postMessage({ type: 'updateTarget', target: url.toString() }, '*');
      }
    });

    peer.on('connection', (conn) => {
      log('Incoming connection from', conn.peer);
      connections.set(conn.peer, conn);
      attachConnDebug(conn);
      updateStatus();

      conn.on('data', (msg) => onMessage(msg, conn));
      conn.on('close', () => {
        log('Conn closed', conn.peer);
        connections.delete(conn.peer);
        updateStatus();
      });
      conn.on('error', (e) => {
        err('Peer connection error:', e);
        connections.delete(conn.peer);
        updateStatus();
      });
    });

    peer.on('disconnected', ()=> { warn('Peer disconnected from server'); updateStatus(); });
    peer.on('close', ()=> { warn('Peer closed'); updateStatus(); });
    peer.on('error', (e)=> { err('PeerJS error:', e); });

    armed = true;
    updateStatus();
  }

  function disarmRemote() {
    armed = false;
    for (const conn of connections.values()) { try { conn.close(); } catch {} }
    connections.clear();

    if (peer) try { peer.destroy(); } catch {}
    peer = null;
    sessionToken = null;

    els.showQR.disabled = true;
    els.reset.disabled = true;
    updateStatus();
  }

  // Small helper: add deep ICE debugging (Safari helpful)
  function attachConnDebug(conn){
    const pc = conn.peerConnection || conn._pc;
    if (pc) {
      pc.oniceconnectionstatechange = () => log('ICE state:', pc.iceConnectionState);
      pc.onconnectionstatechange = () => log('PC state:', pc.connectionState);
      pc.onicegatheringstatechange = () => log('ICE gathering:', pc.iceGatheringState);
    }
    conn.on('open', ()=> log('DataConnection open to', conn.peer));
  }

  async function recordCanvasFiveSeconds(preferMp4=false) {
    const canvas = els.canvas;
    if (!canvas || !canvas.captureStream) throw new Error('Canvas captureStream not supported');
    const stream = canvas.captureStream(30);
    const chunks = [];

    // Try H.264 MP4 first only if caller prefers (iOS Safari)
    const optionsList = [
      ...(preferMp4 ? [{ mimeType: 'video/mp4;codecs=h264', videoBitsPerSecond: 2_000_000 }] : []),
      { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2_000_000 },
      { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2_000_000 },
      { mimeType: 'video/webm', videoBitsPerSecond: 2_000_000 },
    ];

    let rec = null, mime = '';
    for (const opt of optionsList) {
      try {
        if (MediaRecorder.isTypeSupported(opt.mimeType)) {
          rec = new MediaRecorder(stream, opt);
          mime = rec.mimeType;
          break;
        }
      } catch {}
    }
    if (!rec) throw new Error('MediaRecorder unavailable for desired formats');

    await new Promise(res => setTimeout(res, 50));
    return await new Promise((resolve, reject) => {
      let stopped = false;
      rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      rec.onerror = e => { if (!stopped) reject(e.error || e); };
      rec.onstop = () => {
        stopped = true;
        try { stream.getTracks().forEach(t => t.stop()); } catch {}
        const blob = new Blob(chunks, { type: mime });
        resolve({ blob, mime });
      };
      rec.start();
      setTimeout(() => { try { rec.stop(); } catch {} }, 5000);
    });
  }

  async function onMessage(msg, conn) {
    try {
      const data = typeof msg === 'string' ? JSON.parse(msg) : msg;

      if (data.type === 'hello') {
        if (data.token !== sessionToken) {
          conn.send(JSON.stringify({ type:'error', message: 'Invalid token.' }));
          setTimeout(() => { try { conn.close(); } catch {} }, 100);
          return;
        }
        conn.capabilities = { supportsWebM: !!data.supportsWebM };
        conn.send(JSON.stringify({ type:'helloAck', ok:true }));
        return;
      }

      if (data.type === 'startRecording') {
        if (!armed) return conn.send(JSON.stringify({ type: 'error', message: 'Remote is not armed.' }));
        if (isRecording) return conn.send(JSON.stringify({ type: 'error', message: 'Host is busy recording.' }));

        isRecording = true;
        updateStatus();

        const preferMp4 = conn.capabilities ? !conn.capabilities.supportsWebM : false;
        let recording;
        try {
          recording = await recordCanvasFiveSeconds(preferMp4);
        } catch (e) {
          conn.send(JSON.stringify({ type:'error', message: String(e) }));
          isRecording = false;
          updateStatus();
          return;
        }

        const { blob, mime } = recording;
        const arrayBuf = await blob.arrayBuffer();
        const total = arrayBuf.byteLength;
        const filename = `unknown_${Date.now()}.${mime.includes('mp4')?'mp4':'webm'}`;

        conn.send(JSON.stringify({ type:'recordingMeta', mime, totalBytes: total, filename }));

        // ✅ Safari/iOS backpressure-safe sending
        const CHUNK = 64 * 1024;
        let sent = 0;

        // Prefer the real RTCDataChannel; fall back gracefully
        const channel = conn._dc || conn.dataChannel || null;
        const threshold = 512 * 1024; // lower threshold works better on iOS

        if (channel && 'bufferedAmountLowThreshold' in channel) {
          channel.bufferedAmountLowThreshold = threshold;
        }

        while (sent < total) {
          if (channel && channel.bufferedAmount > threshold) {
            await new Promise(r => {
              const handler = () => { channel.removeEventListener('bufferedamountlow', handler); r(); };
              channel.addEventListener('bufferedamountlow', handler, { once: true });
            });
          }
          const end = Math.min(total, sent + CHUNK);
          const chunk = arrayBuf.slice(sent, end);
          conn.send(chunk);
          sent = end;
          if (sent % (CHUNK * 10) === 0) {
            conn.send(JSON.stringify({ type:'progress', sent }));
          }
        }
        conn.send(JSON.stringify({ type:'recordingEnd' }));
        isRecording = false;
        updateStatus();
        return;
      }
    } catch (e) {
      err('Remote message error', e);
      isRecording = false;
      updateStatus();
    }
  }

  function openQRWindow() {
    if (!peer || !sessionToken) return;
    const url = new URL(PHONE_URL, location.href);
    url.searchParams.set('host', peer.id);
    url.searchParams.set('token', sessionToken);
    const qrUrl = new URL(QR_URL, location.href);
    qrUrl.searchParams.set('target', url.toString());
    // Keep a handle so we can live-update without closing
    qrWin = window.open(qrUrl.toString(), '_blank', 'noopener,noreferrer,width=520,height=600');
  }

  els.enable.addEventListener('change', async () => {
    if (els.enable.checked) {
      try { await armRemote(); }
      catch (e) { err('Failed to arm remote:', e); els.enable.checked = false; updateStatus(); }
    } else {
      disarmRemote();
    }
  });

  els.showQR.addEventListener('click', openQRWindow);
  els.reset.addEventListener('click', () => {
    const wasEnabled = els.enable.checked;
    disarmRemote();
    if (wasEnabled) { els.enable.checked = true; armRemote(); }
  });

})();
</script>
