<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UNKNOWN // Remote Host (V6)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark; }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji; }
    .chip{padding:.25rem .5rem;border:1px solid #2b2f38;border-radius:.375rem;font-variant-numeric:tabular-nums}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
  </style>
</head>
<body class="bg-[#0b0d11] text-gray-200 min-h-screen">
  <div class="max-w-5xl mx-auto p-6 space-y-6">
    <header class="flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-extrabold tracking-tight">UNKNOWN // Remote Host</h1>
        <!-- Version string bumped in the HTML body (as requested) -->
        <p class="text-sm text-gray-400 mono">UNKNOWN_V5.4_BODY • iOS WebRTC fix + auto-rotating QR</p>
      </div>
      <div class="flex items-center gap-2">
        <span id="peerId" class="chip mono">peer: —</span>
        <span id="tokenChip" class="chip mono">token: —</span>
        <span id="statusChip" class="chip mono">status: idle</span>
      </div>
    </header>

    <section class="grid md:grid-cols-2 gap-6">
      <div class="space-y-4">
        <div class="rounded-xl border border-[#1f2430] bg-[#11141a] p-4">
          <h2 class="font-semibold mb-2">Remote pairing</h2>
          <div class="flex flex-wrap gap-2">
            <button id="armBtn" class="px-3 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50">1) Arm screen capture</button>
            <button id="showQR" class="px-3 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 disabled:opacity-50">2) Open QR window</button>
            <button id="resetBtn" class="px-3 py-2 rounded-lg bg-rose-600 hover:bg-rose-500">Rotate token</button>
          </div>
          <p class="text-xs text-gray-400 mt-2">Tip: keep the QR window on a separate display. Each time a recording finishes, the token rotates automatically and the QR updates — no manual reset.</p>
          <label class="flex items-center gap-2 mt-3 text-sm">
            <input type="checkbox" id="autoOpenQR" class="accent-emerald-500" checked />
            Keep QR window always open
          </label>
        </div>

        <div class="rounded-xl border border-[#1f2430] bg-[#11141a] p-4">
          <h2 class="font-semibold mb-2">Connection log</h2>
          <pre id="log" class="mono text-sm whitespace-pre-wrap max-h-64 overflow-auto bg-black/30 p-3 rounded-lg">boot…</pre>
        </div>
      </div>

      <div class="space-y-4">
        <div class="rounded-xl border border-[#1f2430] bg-[#11141a] p-4">
          <h2 class="font-semibold mb-2">Recording</h2>
          <div class="grid grid-cols-2 gap-3 text-sm">
            <div><span class="text-gray-400">Armed:</span> <span id="armed" class="mono">no</span></div>
            <div><span class="text-gray-400">Recording:</span> <span id="rec" class="mono">no</span></div>
            <div><span class="text-gray-400">Phone WebM support:</span> <span id="webm" class="mono">unknown</span></div>
            <div><span class="text-gray-400">Chunks sent:</span> <span id="chunks" class="mono">0</span></div>
          </div>
          <p class="text-xs text-gray-400 mt-2">The first time, you’ll be asked to select which screen/window/tab to capture. After that, the phone can trigger recording without more prompts.</p>
        </div>

        <div class="rounded-xl border border-[#1f2430] bg-[#11141a] p-4">
          <h2 class="font-semibold mb-2">What visitors see</h2>
          <p class="text-sm text-gray-300">Visitors scan the QR → <span class="mono">phone.html</span> opens with your <span class="mono">peerId</span> and ephemeral <span class="mono">token</span>. They tap “Start recording”, you record for 5s, and the file streams back.</p>
        </div>
      </div>
    </section>
  </div>

  <script>
    // ---------- Utilities ----------
    const $ = sel => document.querySelector(sel);
    const els = {
      armBtn: $('#armBtn'),
      showQR: $('#showQR'),
      resetBtn: $('#resetBtn'),
      autoOpenQR: $('#autoOpenQR'),
      peerId: $('#peerId'),
      tokenChip: $('#tokenChip'),
      statusChip: $('#statusChip'),
      armed: $('#armed'),
      rec: $('#rec'),
      webm: $('#webm'),
      chunks: $('#chunks'),
      log: $('#log')
    };
    const log = (...a) => { els.log.textContent += "\n" + a.join(' '); els.log.scrollTop = els.log.scrollHeight; };

    const ICE_SERVERS = [
      { urls: [
        'stun:stun.l.google.com:19302',
        'stun:stun1.l.google.com:19302',
        'stun:stun2.l.google.com:19302',
        'stun:stun.cloudflare.com:3478'
      ] }
    ];

    const PEERJS_URL = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
    const PHONE_PAGE = 'phone.html';
    const QR_PAGE = 'remote-qr.html';

    let peer = null;
    let qrWin = null;
    let screenStream = null;
    let recorder = null;
    let chunks = [];
    let isRecording = false;
    let phoneSupportsWebM = null;

    let token = null;         // rotates per visitor/recording
    let currentConn = null;   // active DataConnection
    let chunkCount = 0;

    function randomToken(n=16){
      const abc = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let s = '';
      for (let i=0; i<n; i++) s += abc[Math.floor(Math.random()*abc.length)];
      return s;
    }

    function updateBadges(){
      els.tokenChip.textContent = `token: ${token ?? '—'}`;
      els.armed.textContent = screenStream ? 'yes' : 'no';
      els.rec.textContent = isRecording ? 'yes' : 'no';
      els.chunks.textContent = String(chunkCount);
      els.statusChip.textContent = `status: ${peer?.id ? 'online' : 'offline'}`;
    }

    function setStatus(s){ els.statusChip.textContent = `status: ${s}`; }

    function buildPhoneURL(){
      const url = new URL(location.origin + location.pathname.replace(/[^/]+$/, '') + PHONE_PAGE);
      url.searchParams.set('host', peer.id);
      url.searchParams.set('token', token);
      return url.toString();
    }

    function openOrFocusQR(){
      const qrURL = new URL(location.origin + location.pathname.replace(/[^/]+$/, '') + QR_PAGE);
      qrURL.searchParams.set('host', peer.id);
      qrURL.searchParams.set('token', token);
      qrURL.searchParams.set('phone', PHONE_PAGE);
      if (!qrWin || qrWin.closed){
        qrWin = window.open(qrURL.toString(), 'qr', 'popup,width=520,height=640');
      } else {
        qrWin.location.replace(qrURL.toString());
        try { qrWin.focus(); } catch {}
      }
    }

    function maybeAutoOpenQR(){
      if (els.autoOpenQR.checked && peer?.id) openOrFocusQR();
    }

    function rotateToken(){
      token = randomToken(16);
      updateBadges();
      if (els.autoOpenQR.checked && peer?.id && qrWin && !qrWin.closed) {
        openOrFocusQR(); // refresh params (new token)
      }
      log('token→', token);
    }

    // ---------- PeerJS bootstrap ----------
    async function lazyLoadPeer(){
      if (window.Peer) return;
      await new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = PEERJS_URL; s.onload = res; s.onerror = rej;
        document.head.appendChild(s);
      });
    }

    async function ensurePeer(){
      await lazyLoadPeer();
      peer = new window.Peer(undefined, {
        debug: 1,
        config: { iceServers: ICE_SERVERS, iceTransportPolicy: 'all' }
      });

      peer.on('open', (id) => {
        log('peer open', id);
        els.peerId.textContent = `peer: ${id}`;
        setStatus('online');
        rotateToken();
        maybeAutoOpenQR();
        els.showQR.disabled = false;
      });

      peer.on('disconnected', () => {
        setStatus('reconnecting…');
        try { peer.reconnect(); } catch {}
      });

      peer.on('close', () => setStatus('closed'));
      peer.on('error', (e) => { log('peer error:', e?.message || e); setStatus('error'); });

      peer.on('connection', (conn) => {
        log('incoming conn from', conn.peer);
        currentConn = conn;
        attachConnHandlers(conn);
      });
    }

    function attachConnHandlers(conn){
      conn.on('open', () => {
        log('dc open');
        conn.send(JSON.stringify({ type: 'helloHost', requireToken: true }));
      });

      conn.on('data', async (msg) => {
        try {
          if (typeof msg === 'string') {
            const data = JSON.parse(msg);
            if (data.type === 'hello') {
              // token gate
              if (data.token !== token) {
                log('bad token from phone');
                conn.send(JSON.stringify({ type: 'error', message: 'invalid token' }));
                conn.close();
                return;
              }
              phoneSupportsWebM = !!data.supportsWebM;
              els.webm.textContent = phoneSupportsWebM ? 'yes' : 'no';
              conn.send(JSON.stringify({ type: 'helloAck' }));
              setStatus('paired');
            } else if (data.type === 'startRecording') {
              await beginRecording(conn);
            }
          }
        } catch (e) {
          log('data error', e?.message || e);
        }
      });

      conn.on('close', () => { log('dc close'); if (currentConn === conn) currentConn = null; });
      conn.on('error', (e) => log('dc error', e?.message || e));
    }

    // ---------- Recording pipeline ----------
    async function armScreenCapture(){
      try {
        // Ask once; visitor triggers later
        screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: { frameRate: 30 },
          audio: false
        });
        log('screen armed');
        updateBadges();

        // If the user stops sharing manually, un-arm.
        screenStream.getVideoTracks()[0].addEventListener('ended', () => {
          screenStream = null;
          updateBadges();
          log('screen stream ended');
        });
      } catch (e) {
        log('arm failed:', e?.message || e);
      }
    }

    async function beginRecording(conn){
      if (!screenStream) { conn.send(JSON.stringify({ type: 'error', message: 'Host not armed' })); return; }
      if (isRecording) return;

      isRecording = true;
      chunkCount = 0; chunks = [];
      updateBadges();
      setStatus('recording');

      // Chrome prefers webm; we’ll advertise mime to phone
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
        ? 'video/webm;codecs=vp9'
        : (MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm');

      recorder = new MediaRecorder(screenStream, { mimeType: mime, videoBitsPerSecond: 6_000_000 });
      const fileName = 'capture.webm';

      conn.send(JSON.stringify({ type: 'recordingMeta', mime, filename: fileName, totalBytes: 0 }));

      recorder.ondataavailable = async (e) => {
        if (e.data && e.data.size) {
          const ab = await e.data.arrayBuffer();
          conn.send(ab);
          chunkCount++;
          els.chunks.textContent = String(chunkCount);
          conn.send(JSON.stringify({ type: 'progress', sent: 0 })); // size unknown; just trigger client UI updates
        }
      };

      recorder.onstop = async () => {
        try { conn.send(JSON.stringify({ type: 'recordingEnd' })); } catch {}
        isRecording = false; updateBadges(); setStatus('paired');
        // Rotate token for the next visitor and refresh QR
        rotateToken();
      };

      recorder.start(250); // small timeslice so chunks stream during the 5s
      // Stop after 5 seconds
      setTimeout(() => { try { recorder.stop(); } catch {} }, 5000);
    }

    // ---------- UI bindings ----------
    els.armBtn.addEventListener('click', armScreenCapture);
    els.showQR.addEventListener('click', openOrFocusQR);
    els.resetBtn.addEventListener('click', () => { rotateToken(); maybeAutoOpenQR(); });

    // Boot
    (async () => {
      await ensurePeer();
      // Keep the QR window sticky if the user wants it
      setInterval(() => { if (els.autoOpenQR.checked && peer?.id) { if (!qrWin || qrWin.closed) openOrFocusQR(); } }, 1500);
    })();
  </script>
</body>
</html>
