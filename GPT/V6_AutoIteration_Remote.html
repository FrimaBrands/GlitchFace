<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Signal Processor</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

  <style>
    body { font-family: 'Inter', sans-serif; background-color: #0a0a0a; }
    .font-mono { font-family: 'JetBrains Mono', monospace; }

    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }

    input[type="range"] { -webkit-appearance:none; appearance:none; width:100%; height:4px; background:#374151; border-radius:2px; outline:none; transition:background .3s; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:16px; height:16px; background:#34d399; cursor:pointer; border-radius:50%; border:2px solid #111827; }
    input[type="range"]::-moz-range-thumb { width:16px; height:16px; background:#34d399; cursor:pointer; border-radius:50%; border:2px solid #111827; }

    .status-indicator::after { content:'_'; animation: blink 1s step-end infinite; }
    @keyframes blink { 50% { opacity: 0; } }
    
    .tab-button.active {
        border-color: #34d399;
        color: #e5e7eb;
        background-color: rgba(255, 255, 255, 0.05);
    }
  </style>
</head>
<body class="bg-black text-gray-200 flex items-center justify-center min-h-screen p-4">

  <div class="container w-full max-w-7xl h-[90vh] bg-black border border-gray-800 rounded-lg shadow-2xl shadow-green-500/10 flex overflow-hidden">
    <div class="main-stage flex-grow bg-black relative flex items-center justify-center">
      <video id="video" playsinline muted class="hidden"></video>
      <video id="backgroundMedia" loop muted playsinline class="hidden absolute w-full h-full object-cover"></video>
      <img id="backgroundImage" class="hidden absolute w-full h-full object-cover" />
      <canvas id="glcanvas" class="w-full h-full object-cover"></canvas>
      <div id="statusBar" class="absolute bottom-2 left-2 font-mono text-xs bg-black/50 text-green-400 px-2 py-1 rounded status-indicator">
        STATUS: IDLE
      </div>
    </div>

    <div class="controls-panel w-[420px] flex-shrink-0 bg-gray-950/50 border-l border-gray-800 flex flex-col">
      <div class="p-4 border-b border-gray-800 flex-shrink-0">
        <h1 class="text-xl font-bold text-white">SIGNAL PROCESSOR</h1>
        <p class="text-sm text-gray-400 font-mono">UNKNOWN_V5.5_BODY</p>
        <div class="flex space-x-2 mt-4">
          <button id="startBtn" class="flex-1 bg-green-500 hover:bg-green-600 text-black font-bold py-2 px-4 rounded transition-all duration-200">Initialize</button>
          <button id="stopBtn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition-all duration-200" disabled>Terminate</button>
        </div>
        <div id="msg" class="text-red-400 font-mono text-xs mt-2 h-4"></div>
      </div>

      <div class="p-4 border-b border-gray-800 flex-shrink-0">
        <h2 class="font-bold text-gray-300 mb-2">PRESET MANAGER</h2>
        <select id="presetList" class="w-full bg-gray-900 border border-gray-600 rounded p-2 mb-2 text-sm focus:outline-none focus:border-green-500"></select>
        <div class="grid grid-cols-3 gap-2">
          <input type="text" id="presetName" placeholder="Preset Name..." class="col-span-3 bg-gray-900 border border-gray-600 rounded p-2 text-sm focus:outline-none focus:border-green-500">
          <button id="savePresetBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 rounded text-sm transition-colors">Save</button>
          <button id="deletePresetBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 rounded text-sm transition-colors">Delete</button>
          <button id="randomBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-1 rounded text-sm transition-colors">Randomize</button>
        </div>
      </div>
      
      <div class="flex border-b border-gray-800 flex-shrink-0">
        <button id="effectsTabBtn" class="tab-button flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 border-transparent text-gray-500 hover:text-gray-200 transition-colors duration-200">Effects</button>
        <button id="globalsTabBtn" class="tab-button active flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 transition-colors duration-200">Globals</button>
      </div>

      <div class="flex-grow custom-scrollbar overflow-y-auto">
        <div id="effects-tab-content" class="hidden p-4 space-y-4">
          </div>
        <div id="globals-tab-content" class="p-4 space-y-4">
<div class="control-group bg-black/50 border border-gray-800 rounded-lg p-3">
  <h3 class="font-semibold text-gray-200 mb-3">REMOTE</h3>
  <p class="text-xs text-gray-400 mb-2">Allow a visitor's phone to trigger a 5s recording of this canvas. Recording is canvas-only (no screen/mic).</p>
  <div class="space-y-3">
    <label class="flex items-center justify-between text-sm">
      <span class="text-gray-400">Enable remote trigger (armed)</span>
      <input type="checkbox" id="remoteEnable" class="form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0">
    </label>
    <div class="grid grid-cols-2 gap-2">
      <button id="remoteShowQR" class="bg-emerald-500 hover:bg-emerald-600 text-black font-semibold py-2 rounded text-sm transition-colors disabled:opacity-50" disabled>Open QR Window</button>
      <button id="remoteReset" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 rounded text-sm transition-colors" disabled>Revoke / Reset</button>
    </div>
    <div id="remoteStatus" class="text-xs font-mono text-green-400">REMOTE: idle</div>
  </div>
</div>

          <div class="control-group bg-black/50 border border-gray-800 rounded-lg p-3">
            <h3 class="font-semibold text-gray-200 mb-3">BACKGROUND</h3>
            <div class="space-y-3">
                <button id="bgUploadBtn" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 rounded text-sm transition-colors">Upload Image/Video</button>
                <input type="file" id="bgUpload" accept="image/*,video/*" class="hidden">
                <label class="flex items-center justify-between text-sm">
                    <span class="text-gray-400">Use Custom Background</span>
                    <input type="checkbox" id="useBgChk" class="form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0" disabled>
                </label>
                <div class="control-item space-y-2">
                    <div class="flex justify-between items-center">
                        <label for="maskFeather" class="text-sm font-medium text-gray-300">Mask Feather</label>
                        <span id="maskFeatherValue" class="text-sm font-mono text-green-400">0.150</span>
                    </div>
                    <input type="range" id="maskFeather" min="0.01" max="0.5" step="0.001" value="0.15">
                </div>
            </div>
          </div>
          <div class="control-group bg-black/50 border border-gray-800 rounded-lg p-3">
            <h3 class="font-semibold text-gray-200 mb-3">SETTINGS</h3>
            <div class="space-y-3">
              <label class="flex items-center justify-between text-sm">
                <span class="text-gray-400">Animate Effects</span>
                <input type="checkbox" id="animateChk" class="form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0" checked>
              </label>
              <label class="flex items-center justify-between text-sm">
                <span class="text-gray-400">Mirror Camera</span>
                <input type="checkbox" id="mirrorChk" class="form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0" checked>
              </label>
            </div>
          </div>
          <div class="control-group bg-black/50 border border-gray-800 rounded-lg p-3">
            <h3 class="font-semibold text-gray-200 mb-3">AUTOMATION</h3>
            <div class="control-item space-y-2">
              <div class="flex justify-between items-center">
                <label for="autoRandomizeSlider" class="text-sm font-medium text-gray-300">Auto-Randomize</label>
                <span id="autoRandomizeValue" class="text-sm font-mono text-green-400">Off</span>
              </div>
              <input type="range" id="autoRandomizeSlider" min="0" max="30" step="0.5" value="0">
            </div>
            <div class="control-item space-y-2 mt-3">
              <div class="flex justify-between items-center">
                <label for="presetIterationSlider" class="text-sm font-medium text-gray-300">Preset Iteration</label>
                <span id="presetIterationValue" class="text-sm font-mono text-green-400">Off</span>
              </div>
              <input type="range" id="presetIterationSlider" min="0" max="30" step="0.5" value="0">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    // --- APP ARCHITECTURE ---
    // This script is organized into several modules, each handling a specific concern.
    // 1. UI: Manages all DOM elements, control creation, and user feedback.
    // 2. Renderer: Encapsulates all WebGL logic, including setup, shaders, and the render pipeline.
    // 3. BodySegmenter: Handles the MediaPipe Selfie Segmentation setup and result processing.
    // 4. PresetManager: Manages saving, loading, and randomizing effect presets.
    // 5. App: The main controller that initializes all modules and runs the main loop.
    
    const vertSrc = `
      attribute vec2 a_pos;
      varying vec2 v_uv;
      void main() {
        v_uv = a_pos;
        gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
      }`;

    const fragSrc = `
      precision highp float;
      varying vec2 v_uv;

      // Textures
      uniform sampler2D u_tex;
      uniform sampler2D u_feedbackTex;
      uniform sampler2D u_maskTex;
      uniform sampler2D u_backgroundTex;

      // Global uniforms
      uniform vec2  u_resolution;
      uniform float u_time;
      uniform bool  u_isFeedbackPass;
      uniform bool  u_useBackground;
      uniform float u_maskFeather;

      // Opacity uniforms (not randomized)
      uniform float u_overallOpacity;
      uniform float u_flickerPerSecond;
      uniform float u_flickerDuration;
      uniform float u_flickerIntensity;
      uniform float u_flickerFade;

      // Seep uniforms (not randomized)
      uniform float u_seepAmount;
      uniform float u_seepIntensity;

      // Effect uniforms (randomized)
      uniform float u_feedbackAmount;
      uniform float u_feedbackZoom;
      uniform float u_glitchIntensity;
      uniform float u_glitchBlockSize;
      uniform float u_rgbShift;
      uniform float u_noiseAmount;
      uniform float u_noiseSpeed;
      uniform float u_vignette;
      
      // Smear uniforms
      uniform float u_globalSmearIntensity;
      uniform float u_globalSmearAngle;
      uniform float u_spotSmearIntensity;
      uniform float u_spotSmearDensity;
      uniform float u_spotSmearSize;


      // --- Helper Functions ---
      float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }

      // Generic smear effect
      vec4 smear(sampler2D tex, vec2 uv, float intensity, float angle) {
        vec2 dir = vec2(cos(angle), sin(angle)) / u_resolution;
        vec4 color = vec4(0.0);
        const int samples = 16;
        for (int i = 0; i < samples; i++) {
          float t = float(i) / float(samples - 1);
          color += texture2D(tex, uv - dir * t * intensity);
        }
        return color / float(samples);
      }
      
      // Simple box blur for creating the 'seep' effect
      vec4 blur(sampler2D tex, vec2 uv, float radius) {
          vec4 acc = vec4(0.0);
          vec2 res = u_resolution.xy;
          float count = 0.0;
          // A 5x5 kernel for a small, efficient blur
          for(float x = -2.0; x <= 2.0; x++) {
              for(float y = -2.0; y <= 2.0; y++) {
                  vec2 offset = vec2(x, y) * radius / res;
                  acc += texture2D(tex, uv + offset);
                  count += 1.0;
              }
          }
          return acc / count;
      }

      void main() {
        vec2 uv = v_uv;
        vec4 videoColor = texture2D(u_tex, uv);

        // --- EFFECT PIPELINE ---
        vec4 feedbackColor = texture2D(u_feedbackTex, (uv - 0.5) * u_feedbackZoom + 0.5);
        vec4 effectedColor = mix(videoColor, feedbackColor, u_feedbackAmount);

        if (rand(vec2(floor(u_time * 15.0), 0.0)) < u_glitchIntensity) {
          vec2 block_uv = floor(uv * u_resolution.y / u_glitchBlockSize) / (u_resolution.y / u_glitchBlockSize);
          effectedColor = texture2D(u_tex, uv + vec2((rand(block_uv) - 0.5) * 0.1, 0.0));
        }

        float r = texture2D(u_tex, uv + vec2(u_rgbShift, 0.0)).r;
        float b = texture2D(u_tex, uv - vec2(u_rgbShift, 0.0)).b;
        effectedColor = vec4(r, effectedColor.g, b, effectedColor.a);

        effectedColor += (rand(uv + u_time * u_noiseSpeed) - 0.5) * u_noiseAmount;
        effectedColor.rgb *= 1.0 - u_vignette * distance(uv, vec2(0.5));

        vec4 smearedColor = effectedColor;
        
        vec2 grid_uv = floor(uv * u_spotSmearSize) / u_spotSmearSize;
        if (rand(grid_uv + floor(u_time * 5.0)) < u_spotSmearDensity) {
          smearedColor = smear(u_feedbackTex, uv, u_spotSmearIntensity, rand(grid_uv + 10.0) * 6.283);
        }

        float maskValue = texture2D(u_maskTex, uv).r;
        if (maskValue > 0.1) {
            vec4 globalSmear = smear(u_feedbackTex, uv, u_globalSmearIntensity, radians(u_globalSmearAngle));
            smearedColor = mix(smearedColor, globalSmear, 0.5);
        }


        float effectedGray = dot(smearedColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 effectedGrayscale = vec4(vec3(effectedGray), 1.0);

        // --- RENDER PASS LOGIC ---
        if (u_isFeedbackPass) {
          gl_FragColor = effectedGrayscale;
          return;
        }

        // --- FINAL COMPOSITION (Screen Pass) ---
        float originalGray = dot(videoColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 originalGrayscale = vec4(vec3(originalGray), 1.0);

        float baseMask = texture2D(u_maskTex, uv).r;
        float blurredMask = blur(u_maskTex, uv, u_seepIntensity).r;
        float seep = (1.0 - baseMask) * blurredMask * u_seepAmount;

        float finalMask = smoothstep(0.5 - u_maskFeather, 0.5 + u_maskFeather, baseMask);
        float silhouetteMask = clamp(finalMask + seep, 0.0, 1.0);

        // Calculate flicker
        float flickerMultiplier = 1.0;
        if (u_flickerPerSecond > 0.0) {
            float flickerCycle = 1.0 / u_flickerPerSecond;
            float flickerPhase = mod(u_time, flickerCycle);
            float flickerEdge = flickerCycle * u_flickerDuration;
            
            float fadeWidth = flickerCycle * u_flickerFade * 0.5;
            float isFlickerOff = 1.0 - smoothstep(flickerEdge - fadeWidth, flickerEdge + fadeWidth, flickerPhase);
            flickerMultiplier = 1.0 - (isFlickerOff * u_flickerIntensity);
        }

        // 'effectAmount' now combines opacity and flicker. This controls HOW MUCH effect is applied.
        float effectAmount = u_overallOpacity * flickerMultiplier;

        // The foreground color is a mix of the original body and the fully effected body.
        vec4 foregroundColor = mix(originalGrayscale, effectedGrayscale, effectAmount);
        
        // Determine the background color
        vec4 backgroundColor = u_useBackground ? texture2D(u_backgroundTex, uv) : originalGrayscale;

        // Mix the background with the calculated foreground color using the silhouette mask.
        gl_FragColor = mix(backgroundColor, foregroundColor, silhouetteMask);
      }`;

    const UI = {
      elements: {},
      state: { ui: {}, jitter: {} },
      globalState: { ui: {} }, // State for non-randomized controls
      definitions: {},
      globalDefinitions: {},

      init(definitions, globalDefinitions) {
        this.definitions = definitions;
        this.globalDefinitions = globalDefinitions;
        const ids = ['video', 'glcanvas', 'startBtn', 'stopBtn', 'statusBar', 'msg', 'savePresetBtn', 'deletePresetBtn', 'presetName', 'presetList', 'randomBtn', 'animateChk', 'mirrorChk', 'backgroundMedia', 'backgroundImage', 'bgUploadBtn', 'bgUpload', 'useBgChk', 'maskFeather', 'maskFeatherValue', 'effectsTabBtn', 'globalsTabBtn', 'effects-tab-content', 'globals-tab-content', 'autoRandomizeSlider', 'autoRandomizeValue', 'presetIterationSlider', 'presetIterationValue'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        // Create randomized controls in the 'Effects' tab
        for (const [key, definition] of Object.entries(this.definitions)) {
          this.createControlGroup(key, definition, this.state, this.elements['effects-tab-content'], true);
        }
        // Create global controls in the 'Globals' tab
        for (const [key, definition] of Object.entries(this.globalDefinitions)) {
            this.createControlGroup(key, definition, this.globalState, this.elements['globals-tab-content'], false);
        }

        // --- Event Listeners ---
        this.elements.mirrorChk.addEventListener('change', () => this.elements.glcanvas.style.transform = this.elements.mirrorChk.checked ? 'scaleX(-1)' : 'none');
        this.elements.glcanvas.style.transform = this.elements.mirrorChk.checked ? 'scaleX(-1)' : 'none';
        
        // Tab switching logic
        this.elements.effectsTabBtn.addEventListener('click', () => this.switchTab('effects'));
        this.elements.globalsTabBtn.addEventListener('click', () => this.switchTab('globals'));

        // Background controls
        this.elements.bgUploadBtn.addEventListener('click', () => this.elements.bgUpload.click());
        this.elements.bgUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);

            if (file.type.startsWith('image/')) {
                this.elements.backgroundImage.src = url;
                this.elements.backgroundImage.classList.remove('hidden');
                this.elements.backgroundMedia.classList.add('hidden');
                this.elements.backgroundMedia.pause();
                this.elements.backgroundMedia.src = '';
            } else if (file.type.startsWith('video/')) {
                this.elements.backgroundMedia.src = url;
                this.elements.backgroundMedia.play();
                this.elements.backgroundMedia.classList.remove('hidden');
                this.elements.backgroundImage.classList.add('hidden');
                this.elements.backgroundImage.src = '';
            }

            this.elements.useBgChk.disabled = false;
            this.elements.useBgChk.checked = true;
            this.setMsg(`Loaded background: ${file.name}`);
        });
        this.elements.maskFeather.addEventListener('input', () => {
            this.elements.maskFeatherValue.textContent = parseFloat(this.elements.maskFeather.value).toFixed(3);
        });
        
        // Automation controls
        this.elements.autoRandomizeSlider.addEventListener('input', () => {
            const val = parseFloat(this.elements.autoRandomizeSlider.value);
            this.elements.autoRandomizeValue.textContent = val === 0 ? 'Off' : `${val.toFixed(1)}s`;
        });
        this.elements.presetIterationSlider.addEventListener('input', () => {
            const val = parseFloat(this.elements.presetIterationSlider.value);
            this.elements.presetIterationValue.textContent = val === 0 ? 'Off' : `${val.toFixed(1)}s`;
        });
      },

      switchTab(tabName) {
        if (tabName === 'effects') {
            this.elements.effectsTabBtn.classList.add('active');
            this.elements.globalsTabBtn.classList.remove('active');
            this.elements['effects-tab-content'].classList.remove('hidden');
            this.elements['globals-tab-content'].classList.add('hidden');
        } else {
            this.elements.effectsTabBtn.classList.remove('active');
            this.elements.globalsTabBtn.classList.add('active');
            this.elements['effects-tab-content'].classList.add('hidden');
            this.elements['globals-tab-content'].classList.remove('hidden');
        }
      },

      createControlGroup(key, definition, stateObject, parentElement, withToggle) {
        const group = document.createElement('div');
        group.className = 'control-group bg-black/50 border border-gray-800 rounded-lg p-3';
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between';
        
        const title = document.createElement('h3');
        title.className = 'font-semibold text-gray-200';
        title.textContent = definition.title;
        header.appendChild(title);

        const content = document.createElement('div');
        content.className = 'mt-3 space-y-3';
        
        if (withToggle) {
            header.classList.add('cursor-pointer');
            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.checked = definition.active;
            toggle.className = 'form-checkbox h-4 w-4 text-green-500 bg-gray-700 border-gray-600 rounded focus:ring-0';
            if (!definition.active) content.classList.add('hidden');
            
            toggle.addEventListener('change', () => {
              definition.active = toggle.checked;
            });
            header.addEventListener('click', (e) => {
                if(e.target !== toggle) {
                    toggle.checked = !toggle.checked;
                    toggle.dispatchEvent(new Event('change'));
                }
                content.classList.toggle('hidden', !toggle.checked);
            });
            definition.toggleElement = toggle;
            header.appendChild(toggle);
        }

        stateObject.ui[key] = {};
        if (stateObject.jitter) {
            stateObject.jitter[key] = {};
        }

        for (const [controlKey, controlDef] of Object.entries(definition.controls)) {
          const slider = this.createSlider(controlKey, controlDef);
          content.appendChild(slider.container);
          stateObject.ui[key][controlKey] = slider.input;
          if (stateObject.jitter) {
              stateObject.jitter[key][controlKey] = { base: controlDef.value, current: controlDef.value };
              slider.input.addEventListener('input', () => {
                stateObject.jitter[key][controlKey].base = parseFloat(slider.input.value);
              });
          }
        }
        
        group.append(header, content);
        parentElement.appendChild(group);
      },

      createSlider(id, def) {
        const container = document.createElement('div');
        container.className = 'control-item space-y-2';
        const labelContainer = document.createElement('div');
        labelContainer.className = 'flex justify-between items-center';
        const label = document.createElement('label');
        label.className = 'text-sm font-medium text-gray-300';
        label.textContent = def.label;
        const valueSpan = document.createElement('span');
        valueSpan.className = 'text-sm font-mono text-green-400';
        const input = document.createElement('input');
        input.type = 'range';
        Object.assign(input, { min: def.min, max: def.max, step: def.step, value: def.value });
        
        const updateValue = () => valueSpan.textContent = parseFloat(input.value).toFixed(String(def.step).includes('.') ? 3 : 0);
        input.addEventListener('input', updateValue);
        updateValue();
        
        labelContainer.append(label, valueSpan);
        container.append(labelContainer, input);
        return { container, input };
      },

      updateJitter(t) {
        if (!this.definitions.Jitter.active) return;
        const { jitterAmount, jitterSpeed } = this.state.ui.Jitter;
        const amount = parseFloat(jitterAmount.value);
        const speed = parseFloat(jitterSpeed.value);
        for (const [groupKey, group] of Object.entries(this.state.jitter)) {
          if (groupKey === 'Jitter' || !this.definitions[groupKey].active) continue;
          for (const [controlKey, state] of Object.entries(group)) {
            const slider = this.state.ui[groupKey][controlKey];
            const range = parseFloat(slider.max) - parseFloat(slider.min);
            const offset = (Math.sin(t * speed + controlKey.length) * Math.cos(t * speed * 0.7 + groupKey.length)) * amount * range;
            state.current = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), state.base + offset));
          }
        }
      },

      setStatus(text, isError = false) {
        this.elements.statusBar.textContent = `STATUS: ${text}`;
        this.elements.statusBar.classList.toggle('text-red-400', isError);
        this.elements.statusBar.classList.toggle('text-green-400', !isError);
      },
      setMsg(text) { this.elements.msg.textContent = text; }
    };

    const Renderer = {
      gl: null,
      program: null,
      textures: {},
      framebuffers: {},
      uniforms: {},
      maskCanvas: document.createElement('canvas'),

      init(canvas, vsSrc, fsSrc, uniformKeys) {
        this.gl = canvas.getContext('webgl', { premultipliedAlpha: false, antialias: true });
        if (!this.gl) throw new Error('WebGL not available');

        const compile = (type, src) => {
          const s = this.gl.createShader(type);
          this.gl.shaderSource(s, src);
          this.gl.compileShader(s);
          if (!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) throw new Error(`Shader compile error: ${this.gl.getShaderInfoLog(s)}`);
          return s;
        };
        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, compile(this.gl.VERTEX_SHADER, vsSrc));
        this.gl.attachShader(this.program, compile(this.gl.FRAGMENT_SHADER, fsSrc));
        this.gl.linkProgram(this.program);
        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) throw new Error(`Program link error: ${this.gl.getProgramInfoLog(this.program)}`);
        
        const buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), this.gl.STATIC_DRAW);
        const posLoc = this.gl.getAttribLocation(this.program, 'a_pos');
        this.gl.enableVertexAttribArray(posLoc);
        this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);

        const createTex = () => {
          const tex = this.gl.createTexture();
          this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          return tex;
        };
        this.textures = { video: createTex(), feedbackA: createTex(), feedbackB: createTex(), mask: createTex(), background: createTex() };
        this.framebuffers.feedback = this.gl.createFramebuffer();
        
        this.gl.useProgram(this.program);
        uniformKeys.forEach(key => this.uniforms[key] = this.gl.getUniformLocation(this.program, key));
      },

      fit(video) {
        if (!video.videoWidth) return;
        const { videoWidth: w, videoHeight: h } = video;
        const canvas = this.gl.canvas;
        if (canvas.width === w && canvas.height === h) return;
        canvas.width = w;
        canvas.height = h;
        // Don't resize background texture here, it has its own dimensions
        const resizableTextures = [this.textures.video, this.textures.feedbackA, this.textures.feedbackB, this.textures.mask];
        for (const tex of resizableTextures) {
          this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, w, h, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
        }
        this.gl.viewport(0, 0, w, h);
      },

      drawMask(video, segmentationMask) {
        const { videoWidth: W, videoHeight: H } = video;
        const ctx = this.maskCanvas.getContext('2d');
        if (this.maskCanvas.width !== W || this.maskCanvas.height !== H) {
          this.maskCanvas.width = W;
          this.maskCanvas.height = H;
        }
        
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, W, H);
        if (segmentationMask) {
          ctx.drawImage(segmentationMask, 0, 0, W, H);
        }

        this.gl.activeTexture(this.gl.TEXTURE2);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.mask);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.maskCanvas);
      },

      render(appState) {
        const { video, t, uiState, globalUiState, backgroundMedia, useBg, maskFeather } = appState;
        this.gl.useProgram(this.program);
        
        // Main video texture
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.video);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, video);
        
        // Background texture
        if (useBg && (backgroundMedia.videoWidth || backgroundMedia.naturalWidth || backgroundMedia.width)) {
            this.gl.activeTexture(this.gl.TEXTURE3);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.background);
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, backgroundMedia);
        }

        this.gl.uniform2f(this.uniforms.u_resolution, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform1f(this.uniforms.u_time, t);

        // Set randomized effect uniforms
        for (const [groupKey, group] of Object.entries(uiState.ui)) {
          const groupIsActive = UI.definitions[groupKey].active;
          for (const [controlKey, control] of Object.entries(group)) {
            let val = groupIsActive ? parseFloat(control.value) : UI.definitions[groupKey].controls[controlKey].neutral;
            if (groupIsActive && UI.definitions.Jitter.active && uiState.jitter[groupKey]?.[controlKey]) {
              val = uiState.jitter[groupKey][controlKey].current;
            }
            this.gl.uniform1f(this.uniforms[`u_${controlKey}`], val);
          }
        }

        // Set global (non-randomized) uniforms
        for (const [groupKey, group] of Object.entries(globalUiState.ui)) {
            for (const [controlKey, control] of Object.entries(group)) {
                const val = parseFloat(control.value);
                this.gl.uniform1f(this.uniforms[`u_${controlKey}`], val);
            }
        }
        
        // Set background-specific uniforms
        this.gl.uniform1i(this.uniforms.u_useBackground, useBg);
        this.gl.uniform1f(this.uniforms.u_maskFeather, maskFeather);

        this.gl.uniform1i(this.uniforms.u_tex, 0);
        this.gl.uniform1i(this.uniforms.u_feedbackTex, 1);
        this.gl.uniform1i(this.uniforms.u_maskTex, 2);
        this.gl.uniform1i(this.uniforms.u_backgroundTex, 3);
        
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.feedbackA);

        this.gl.uniform1i(this.uniforms.u_isFeedbackPass, 1);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffers.feedback);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.textures.feedbackB, 0);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

        this.gl.uniform1i(this.uniforms.u_isFeedbackPass, 0);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

        [this.textures.feedbackA, this.textures.feedbackB] = [this.textures.feedbackB, this.textures.feedbackA];
      }
    };

    const BodySegmenter = {
      segmenter: null,
      lastResult: null,
      isReady: false,
      isBusy: false,
      lastUpdateTime: 0,
      minInterval: 60,

      async init() {
        if (this.isReady) return true;
        try {
          this.segmenter = new window.SelfieSegmentation({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}` });
          this.segmenter.setOptions({ modelSelection: 1 });
          this.segmenter.onResults(res => {
            this.lastResult = res.segmentationMask;
            this.isBusy = false;
          });
          await this.segmenter.initialize();
          this.isReady = true;
          return true;
        } catch (err) {
          console.error("Selfie Segmentation initialization failed:", err);
          return false;
        }
      },

      update(video) {
        const now = performance.now();
        if (this.isReady && !this.isBusy && (now - this.lastUpdateTime) > this.minInterval) {
          this.isBusy = true;
          this.lastUpdateTime = now;
          this.segmenter.send({ image: video });
        }
      }
    };

    const PresetManager = {
      init() {
        this.populateList();
        UI.elements.savePresetBtn.addEventListener('click', () => this.save());
        UI.elements.deletePresetBtn.addEventListener('click', () => this.delete());
        UI.elements.presetList.addEventListener('change', () => this.load());
        UI.elements.randomBtn.addEventListener('click', () => this.randomize());
      },
      
      getPresets: () => JSON.parse(localStorage.getItem('bodyGlitchV5.0Presets') || '{}'),
      savePresets: (p) => localStorage.setItem('bodyGlitchV5.0Presets', JSON.stringify(p)),

      getAppState() {
        const state = { controls: {}, toggles: {}, checkboxes: {}, globalControls: {}, misc: {} };
        for (const [groupKey, group] of Object.entries(UI.state.ui)) {
          state.controls[groupKey] = {};
          state.toggles[groupKey] = UI.definitions[groupKey].active;
          for (const [controlKey, control] of Object.entries(group)) {
            state.controls[groupKey][controlKey] = control.value;
          }
        }
        for (const [groupKey, group] of Object.entries(UI.globalState.ui)) {
            state.globalControls[groupKey] = {};
            for (const [controlKey, control] of Object.entries(group)) {
                state.globalControls[groupKey][controlKey] = control.value;
            }
        }
        state.checkboxes = { 
            animateChk: UI.elements.animateChk.checked, 
            mirrorChk: UI.elements.mirrorChk.checked,
            useBgChk: UI.elements.useBgChk.checked
        };
        state.misc = {
            maskFeather: UI.elements.maskFeather.value,
        };
        return state;
      },

      setAppState(state) {
        if (!state) return;
        if (state.controls) {
          for (const [groupKey, group] of Object.entries(state.controls)) {
            if (UI.state.ui[groupKey]) {
              for (const [controlKey, value] of Object.entries(group)) {
                const el = UI.state.ui[groupKey][controlKey];
                if (el) {
                  el.value = value;
                  el.dispatchEvent(new Event('input'));
                  if (UI.state.jitter[groupKey]?.[controlKey]) UI.state.jitter[groupKey][controlKey].base = parseFloat(el.value);
                }
              }
            }
          }
        }
        if (state.toggles) {
          for (const [groupKey, isChecked] of Object.entries(state.toggles)) {
            const def = UI.definitions[groupKey];
            if (def && def.toggleElement) {
              def.toggleElement.checked = isChecked;
              def.toggleElement.dispatchEvent(new Event('change'));
            }
          }
        }
        if (state.globalControls) {
            for (const [groupKey, group] of Object.entries(state.globalControls)) {
                if (UI.globalState.ui[groupKey]) {
                    for (const [controlKey, value] of Object.entries(group)) {
                        const el = UI.globalState.ui[groupKey][controlKey];
                        if (el) {
                            el.value = value;
                            el.dispatchEvent(new Event('input'));
                        }
                    }
                }
            }
        }
        if (state.checkboxes) {
          UI.elements.animateChk.checked = state.checkboxes.animateChk ?? true;
          UI.elements.mirrorChk.checked  = state.checkboxes.mirrorChk ?? true;
          UI.elements.useBgChk.checked = state.checkboxes.useBgChk ?? false;
        }
        if (state.misc) {
            const featherSlider = UI.elements.maskFeather;
            if (featherSlider) {
                featherSlider.value = state.misc.maskFeather ?? '0.15';
                featherSlider.dispatchEvent(new Event('input'));
            }
        }
      },

      populateList() {
        const presets = this.getPresets();
        const { presetList } = UI.elements;
        const currentVal = presetList.value;
        presetList.innerHTML = '<option value="">-- LOAD PRESET --</option>';
        for (const name in presets) {
          const opt = document.createElement('option');
          opt.value = name; opt.textContent = name; presetList.appendChild(opt);
        }
        presetList.value = currentVal;
      },

      save() {
        const { presetName } = UI.elements;
        const name = presetName.value.trim();
        if (!name) return UI.setMsg('Enter a preset name.');
        const presets = this.getPresets();
        presets[name] = this.getAppState();
        this.savePresets(presets);
        this.populateList();
        UI.elements.presetList.value = name;
        UI.setMsg(`Preset '${name}' saved.`);
      },

      delete() {
        const { presetList, presetName } = UI.elements;
        const name = presetList.value;
        if (!name) return UI.setMsg('Select a preset to delete.');
        const presets = this.getPresets();
        delete presets[name];
        this.savePresets(presets);
        this.populateList();
        presetName.value = '';
        UI.setMsg(`Preset '${name}' deleted.`);
      },

      load(name) {
        const { presetList, presetName } = UI.elements;
        const presetToLoad = name || presetList.value;
        if (!presetToLoad) return;
        const presets = this.getPresets();
        if (presets[presetToLoad]) {
          this.setAppState(presets[presetToLoad]);
          presetName.value = presetToLoad;
          presetList.value = presetToLoad;
          UI.setMsg(`Preset '${presetToLoad}' loaded.`);
        }
      },

      randomize() {
        for (const groupKey in UI.state.ui) {
          const def = UI.definitions[groupKey];
          if(def && def.toggleElement){
            def.toggleElement.checked = Math.random() > 0.3;
            def.toggleElement.dispatchEvent(new Event('change'));
          }
          for (const controlKey in UI.state.ui[groupKey]) {
            const el = UI.state.ui[groupKey][controlKey];
            const min = parseFloat(el.min), max = parseFloat(el.max), step = parseFloat(el.step);
            el.value = Math.round((min + Math.random() * (max - min)) / step) * step;
            el.dispatchEvent(new Event('input'));
          }
        }
        UI.setMsg('Parameters randomized!');
      }
    };

    const App = {
      stream: null,
      rafId: null,
      shaders: {},
      definitions: {},
      globalDefinitions: {},
      lastRandomizeTime: 0,
      lastPresetIterateTime: 0,
      currentPresetIndex: 0,

      async start() {
        if (!navigator.mediaDevices?.getUserMedia) {
          return UI.setMsg('getUserMedia not supported.');
        }
        try {
          UI.setStatus('Requesting camera...');
          this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 1280, height: 720 }, audio: false });
          UI.elements.video.srcObject = this.stream;
          await UI.elements.video.play();
          await new Promise(res => { UI.elements.video.onloadedmetadata = res; });

          UI.setStatus('Initializing GL...');
          const uniformKeys = ['u_resolution', 'u_time', 'u_isFeedbackPass', 'u_tex', 'u_feedbackTex', 'u_maskTex', 'u_backgroundTex', 'u_useBackground', 'u_maskFeather'];
          Object.values(this.definitions).forEach(def => uniformKeys.push(...Object.keys(def.controls).map(c => `u_${c}`)));
          Object.values(this.globalDefinitions).forEach(def => uniformKeys.push(...Object.keys(def.controls).map(c => `u_${c}`)));
          Renderer.init(UI.elements.glcanvas, this.shaders.vert, this.shaders.frag, uniformKeys);
          Renderer.fit(UI.elements.video);

          UI.setStatus('Initializing Body Segmentation...');
          if (!(await BodySegmenter.init())) return UI.setStatus('Segmentation Failed', true);

          UI.elements.startBtn.disabled = true;
          UI.elements.stopBtn.disabled = false;
          UI.setMsg('');
          UI.setStatus('Running');
          this.loop();
        } catch (err) {
          console.error(err);
          UI.setMsg(`Camera error: ${(err.name === 'NotAllowedError') ? 'Permission denied.' : err.message}`);
          UI.setStatus('Error', true);
        }
      },

      stop() {
        if (this.rafId) cancelAnimationFrame(this.rafId);
        this.rafId = null;
        if (this.stream) this.stream.getTracks().forEach(t => t.stop());
        this.stream = null;
        UI.elements.startBtn.disabled = false;
        UI.elements.stopBtn.disabled = true;
        UI.setStatus('Terminated');
      },

      loop(time) {
        this.rafId = requestAnimationFrame(t => this.loop(t));
        const video = UI.elements.video;
        if (!video.videoWidth || !Renderer.gl) return;
        
        Renderer.fit(video);
        BodySegmenter.update(video);
        Renderer.drawMask(video, BodySegmenter.lastResult);
        
        const t = UI.elements.animateChk.checked ? time / 1000 : 0;
        UI.updateJitter(t);

        // Auto-Randomize Logic
        const autoRandomizeInterval = parseFloat(UI.elements.autoRandomizeSlider.value);
        if (autoRandomizeInterval > 0) {
            if (this.lastRandomizeTime === 0) this.lastRandomizeTime = time;
            if ((time - this.lastRandomizeTime) > autoRandomizeInterval * 1000) {
                PresetManager.randomize();
                this.lastRandomizeTime = time;
            }
        } else {
            this.lastRandomizeTime = 0; // Reset timer if disabled
        }
        
        // Preset Iteration Logic
        const presetIterationInterval = parseFloat(UI.elements.presetIterationSlider.value);
        if (presetIterationInterval > 0) {
            if (this.lastPresetIterateTime === 0) this.lastPresetIterateTime = time;
            if ((time - this.lastPresetIterateTime) > presetIterationInterval * 1000) {
                const presets = PresetManager.getPresets();
                const presetNames = Object.keys(presets);
                if (presetNames.length > 0) {
                    this.currentPresetIndex = (this.currentPresetIndex + 1) % presetNames.length;
                    const nextPresetName = presetNames[this.currentPresetIndex];
                    PresetManager.load(nextPresetName);
                }
                this.lastPresetIterateTime = time;
            }
        } else {
            this.lastPresetIterateTime = 0; // Reset timer if disabled
        }

        const backgroundEl = !UI.elements.backgroundImage.classList.contains('hidden')
            ? UI.elements.backgroundImage
            : UI.elements.backgroundMedia;

        Renderer.render({
          video: video,
          t: t,
          uiState: UI.state,
          globalUiState: UI.globalState,
          backgroundMedia: backgroundEl,
          useBg: UI.elements.useBgChk.checked,
          maskFeather: parseFloat(UI.elements.maskFeather.value)
        });
        
        const statusText = BodySegmenter.lastResult
          ? `BODY DETECTED [${Renderer.gl.canvas.width}x${Renderer.gl.canvas.height}]` 
          : `NO SIGNAL...`;
        UI.setStatus(statusText);
      },

      init(definitions, globalDefinitions, shaders) {
        this.shaders = shaders;
        this.definitions = definitions;
        this.globalDefinitions = globalDefinitions;
        UI.init(definitions, globalDefinitions);
        PresetManager.init();
        UI.elements.startBtn.addEventListener('click', () => this.start());
        UI.elements.stopBtn.addEventListener('click', () => this.stop());
      }
    };
    
    // --- Entry Point ---
    // Definitions for effects that can be randomized
    const definitions = {
      Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.005, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } },
      Smear: { 
        title: 'Smearing', 
        active: true, 
        controls: { 
          globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 30, neutral: 0.0 }, 
          globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, 
          spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 10, neutral: 0.0 }, 
          spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.2, neutral: 0.0 }, 
          spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } 
        } 
      },
      Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } },
      Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.1, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } },
      Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.01, neutral: 0.0 } } },
      Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.5, neutral: 0.0 } } }
    };

    // Definitions for global controls that are NOT randomized
    const globalDefinitions = {
        Opacity: {
            title: 'Global Opacity',
            active: true,
            controls: {
                overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 },
                flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0, neutral: 0 },
                flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1, neutral: 0.1 },
                flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 },
                flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }
            }
        },
        Seep: {
            title: 'Effect Seep',
            active: true,
            controls: {
              seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 2.0, neutral: 0.0 },
              seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 20, neutral: 0.0 }
            }
        }
    };

    App.init(definitions, globalDefinitions, { vert: vertSrc, frag: fragSrc });

  })();
  </script>

<script>
// --- Remote Trigger Module (PeerJS over PeerServer Cloud; no sign-in required) ---
(() => {
  const els = {
    enable: document.getElementById('remoteEnable'),
    showQR: document.getElementById('remoteShowQR'),
    reset: document.getElementById('remoteReset'),
    status: document.getElementById('remoteStatus'),
    canvas: document.getElementById('glcanvas')
  };
  if (!els.enable || !els.canvas) return; // page shape changed

  let peer = null;
  // Use a Map to store multiple connections, keyed by their peer ID.
  const connections = new Map();
  let sessionToken = null;
  let armed = false;
  let isRecording = false;

  const PEERJS_URL = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
  const QR_URL = 'remote-qr.html';
  const PHONE_URL = 'phone.html';

  function updateStatus() {
    const count = connections.size;
    let text = 'REMOTE: idle';
    let good = true;

    if (armed) {
        if (isRecording) {
            text = `REMOTE: RECORDING... (${count} connected)`;
        } else if (count > 0) {
            text = `REMOTE: ${count} phone(s) connected. Ready.`;
        } else if (peer && peer.id) {
            text = `REMOTE: armed @ ${peer.id.slice(0,6)} waiting for connections`;
        } else {
            text = 'REMOTE: arming...';
        }
    }

    if (els.status) {
        els.status.textContent = text;
        els.status.classList.toggle('text-red-400', !good);
        els.status.classList.toggle('text-green-400', good);
    }
  }

  function lazyLoadPeerJS() {
    return new Promise((resolve, reject) => {
      if (window.Peer) return resolve();
      const s = document.createElement('script');
      s.src = PEERJS_URL; s.crossOrigin = 'anonymous';
      s.onload = () => resolve();
      s.onerror = e => reject(new Error('Failed to load PeerJS'));
      document.body.appendChild(s);
    });
  }

  function randomToken(len=24) {
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    return Array.from(arr, b => b.toString(16).padStart(2,'0')).join('');
  }

  async function armRemote() {
    await lazyLoadPeerJS();
    sessionToken = randomToken(16);
    
    // MODIFIED: Added iceServers config for better reliability
    peer = new window.Peer(undefined, {
      debug: 1,
      config: {
        'iceServers': [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ]
      }
    });

    peer.on('open', id => {
      updateStatus();
      els.showQR.disabled = false;
      els.reset.disabled = false;
    });

    peer.on('connection', (conn) => {
      connections.set(conn.peer, conn);
      updateStatus();
      
      conn.on('data', (msg) => onMessage(msg, conn));
      
      conn.on('close', () => {
        connections.delete(conn.peer);
        updateStatus();
      });
      
      conn.on('error', (e) => {
        console.error('Peer connection error:', e);
        connections.delete(conn.peer);
        updateStatus();
      });
    });
    
    peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        // Handle peer destruction on critical errors
        if (err.type === 'peer-unavailable' || err.type === 'network') {
            disarmRemote();
            els.enable.checked = false;
            updateStatus();
        }
    });

    armed = true;
    updateStatus();
  }

  function disarmRemote() {
    armed = false;
    for (const conn of connections.values()) {
      try { conn.close(); } catch {}
    }
    connections.clear();
    
    if (peer) try { peer.destroy(); } catch {}
    peer = null;
    sessionToken = null;
    els.showQR.disabled = true;
    els.reset.disabled = true;
    updateStatus();
  }

  async function recordCanvasFiveSeconds(preferMp4=false) {
    const canvas = els.canvas;
    if (!canvas || !canvas.captureStream) throw new Error('Canvas captureStream not supported');
    const stream = canvas.captureStream(30);
    const chunks = [];
    const optionsList = [
      { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2_000_000 },
      { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2_000_000 },
      { mimeType: 'video/webm', videoBitsPerSecond: 2_000_000 },
    ];
    if (preferMp4) optionsList.unshift({ mimeType: 'video/mp4;codecs=h264', videoBitsPerSecond: 2_000_000 });

    let rec = null;
    var mime = '';
    for (const opt of optionsList) {
      try {
        if (MediaRecorder.isTypeSupported(opt.mimeType)) {
            rec = new MediaRecorder(stream, opt);
            mime = rec.mimeType;
            break;
        }
      } catch (e) { /* try next */ }
    }
    if (!rec) throw new Error('MediaRecorder unavailable for desired formats');

    await new Promise(res => setTimeout(res, 50));
    return await new Promise((resolve, reject) => {
      let stopped = false;
      rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      rec.onerror = e => { if (!stopped) reject(e.error || e); };
      rec.onstop = () => {
        stopped = true;
        try { stream.getTracks().forEach(t => t.stop()); } catch {}
        const blob = new Blob(chunks, { type: mime });
        resolve({ blob, mime });
      };
      rec.start();
      setTimeout(() => { try { rec.stop(); } catch {} }, 5000);
    });
  }

  async function onMessage(msg, conn) {
    try {
      const data = typeof msg === 'string' ? JSON.parse(msg) : msg;
      if (data.type === 'hello') {
        if (data.token !== sessionToken) {
          conn.send(JSON.stringify({ type:'error', message: 'Invalid token.' }));
          setTimeout(() => { try { conn.close(); } catch {} }, 100);
          return;
        }
        conn.capabilities = { supportsWebM: !!data.supportsWebM };
        conn.send(JSON.stringify({ type:'helloAck', ok:true }));
        return;
      }

      if (data.type === 'startRecording') {
        if (!armed) return conn.send(JSON.stringify({ type: 'error', message: 'Remote is not armed.' }));
        if (isRecording) return conn.send(JSON.stringify({ type: 'error', message: 'Host is busy recording.' }));
        
        isRecording = true;
        updateStatus();
        
        const preferMp4 = conn.capabilities ? !conn.capabilities.supportsWebM : false;
        let recording;
        try {
          recording = await recordCanvasFiveSeconds(preferMp4);
        } catch (e) {
          conn.send(JSON.stringify({ type:'error', message: String(e) }));
          isRecording = false;
          updateStatus();
          return;
        }
        
        const { blob, mime } = recording;
        const arrayBuf = await blob.arrayBuffer();
        const total = arrayBuf.byteLength;
        const filename = `unknown_${Date.now()}.${mime.includes('mp4')?'mp4':'webm'}`;

        conn.send(JSON.stringify({ type:'recordingMeta', mime, totalBytes: total, filename }));

        const CHUNK = 64 * 1024;
        let sent = 0;
        const channel = conn.dataChannel;
        const threshold = 1 * 1024 * 1024;

        while (sent < total) {
          if (channel && channel.bufferedAmount > threshold) {
            await new Promise(r => { channel.onbufferedamountlow = r; });
          }
          const end = Math.min(total, sent + CHUNK);
          const chunk = arrayBuf.slice(sent, end);
          conn.send(chunk);
          sent = end;
          if (sent % (CHUNK * 10) === 0) {
             conn.send(JSON.stringify({ type:'progress', sent }));
          }
        }
        conn.send(JSON.stringify({ type:'recordingEnd' }));
        isRecording = false;
        updateStatus();
        return;
      }
    } catch (e) {
      console.error('Remote message error', e);
      isRecording = false;
      updateStatus();
    }
  }

  function openQRWindow() {
    if (!peer || !sessionToken) return;
    const url = new URL(PHONE_URL, location.href);
    url.searchParams.set('host', peer.id);
    url.searchParams.set('token', sessionToken);
    const qrUrl = new URL(QR_URL, location.href);
    qrUrl.searchParams.set('target', url.toString());
    window.open(qrUrl.toString(), '_blank', 'noopener,noreferrer,width=520,height=600');
  }

  els.enable.addEventListener('change', async () => {
    if (els.enable.checked) {
      try {
        await armRemote();
      } catch (e) {
        console.error("Failed to arm remote:", e);
        els.enable.checked = false;
        updateStatus();
      }
    } else {
      disarmRemote();
    }
  });
  
  els.showQR.addEventListener('click', openQRWindow);
  
  els.reset.addEventListener('click', () => {
    const wasEnabled = els.enable.checked;
    disarmRemote();
    if (wasEnabled) {
      els.enable.checked = true;
      armRemote();
    }
  });

})();
</script>

</body>
</html>
