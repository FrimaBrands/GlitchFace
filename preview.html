<script>
  (() => {
    // --- CORRECTED SCRIPT FOR PREVIEW WINDOW ---
    // This version fixes the race condition, re-implements jitter, and uses a more robust rendering method.

    const channel = new BroadcastChannel('unknown_signal_processor');
    let currentState = {}; // This will hold the latest state from the controls window.
    let jitterState = {}; // Holds the dynamic jitter values

    const DOM = {
        video: document.getElementById('video'),
        glcanvas: document.getElementById('glcanvas'),
        backgroundMedia: document.getElementById('backgroundMedia'),
        backgroundImage: document.getElementById('backgroundImage'),
    };
    
    // --- SHADERS AND CORE DEFINITIONS (Needed for Jitter & Renderer) ---
    const vertSrc = `attribute vec2 a_pos; varying vec2 v_uv; void main() { v_uv = a_pos; gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0); }`;
    const fragSrc = `precision highp float; varying vec2 v_uv; uniform sampler2D u_tex; uniform sampler2D u_feedbackTex; uniform sampler2D u_maskTex; uniform sampler2D u_backgroundTex; uniform vec2 u_resolution; uniform float u_time; uniform bool u_isFeedbackPass; uniform bool u_useBackground; uniform float u_maskFeather; uniform float u_overallOpacity; uniform float u_flickerPerSecond; uniform float u_flickerDuration; uniform float u_flickerIntensity; uniform float u_flickerFade; uniform float u_seepAmount; uniform float u_seepIntensity; uniform float u_feedbackAmount; uniform float u_feedbackZoom; uniform float u_glitchIntensity; uniform float u_glitchBlockSize; uniform float u_rgbShift; uniform float u_noiseAmount; uniform float u_noiseSpeed; uniform float u_vignette; uniform float u_globalSmearIntensity; uniform float u_globalSmearAngle; uniform float u_spotSmearIntensity; uniform float u_spotSmearDensity; uniform float u_spotSmearSize; uniform float u_jitterAmount; uniform float u_jitterSpeed; float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); } vec4 smear(sampler2D tex, vec2 uv, float intensity, float angle) { vec2 dir = vec2(cos(angle), sin(angle)) / u_resolution; vec4 color = vec4(0.0); const int samples = 16; for (int i = 0; i < samples; i++) { float t = float(i) / float(samples - 1); color += texture2D(tex, uv - dir * t * intensity); } return color / float(samples); } vec4 blur(sampler2D tex, vec2 uv, float radius) { vec4 acc = vec4(0.0); vec2 res = u_resolution.xy; float count = 0.0; for(float x = -2.0; x <= 2.0; x++) { for(float y = -2.0; y <= 2.0; y++) { vec2 offset = vec2(x, y) * radius / res; acc += texture2D(tex, uv + offset); count += 1.0; } } return acc / count; } void main() { vec2 uv = v_uv; vec4 videoColor = texture2D(u_tex, uv); vec4 feedbackColor = texture2D(u_feedbackTex, (uv - 0.5) * u_feedbackZoom + 0.5); vec4 effectedColor = mix(videoColor, feedbackColor, u_feedbackAmount); if (rand(vec2(floor(u_time * 15.0), 0.0)) < u_glitchIntensity) { vec2 block_uv = floor(uv * u_resolution.y / u_glitchBlockSize) / (u_resolution.y / u_glitchBlockSize); effectedColor = texture2D(u_tex, uv + vec2((rand(block_uv) - 0.5) * 0.1, 0.0)); } float r = texture2D(u_tex, uv + vec2(u_rgbShift, 0.0)).r; float b = texture2D(u_tex, uv - vec2(u_rgbShift, 0.0)).b; effectedColor = vec4(r, effectedColor.g, b, effectedColor.a); effectedColor += (rand(uv + u_time * u_noiseSpeed) - 0.5) * u_noiseAmount; effectedColor.rgb *= 1.0 - u_vignette * distance(uv, vec2(0.5)); vec4 smearedColor = effectedColor; vec2 grid_uv = floor(uv * u_spotSmearSize) / u_spotSmearSize; if (rand(grid_uv + floor(u_time * 5.0)) < u_spotSmearDensity) { smearedColor = smear(u_feedbackTex, uv, u_spotSmearIntensity, rand(grid_uv + 10.0) * 6.283); } float maskValue = texture2D(u_maskTex, uv).r; if (maskValue > 0.1) { vec4 globalSmear = smear(u_feedbackTex, uv, u_globalSmearIntensity, radians(u_globalSmearAngle)); smearedColor = mix(smearedColor, globalSmear, 0.5); } float effectedGray = dot(smearedColor.rgb, vec3(0.299, 0.587, 0.114)); vec4 effectedGrayscale = vec4(vec3(effectedGray), 1.0); if (u_isFeedbackPass) { gl_FragColor = effectedGrayscale; return; } float originalGray = dot(videoColor.rgb, vec3(0.299, 0.587, 0.114)); vec4 originalGrayscale = vec4(vec3(originalGray), 1.0); float baseMask = texture2D(u_maskTex, uv).r; float blurredMask = blur(u_maskTex, uv, u_seepIntensity).r; float seep = (1.0 - baseMask) * blurredMask * u_seepAmount; float finalMask = smoothstep(0.5 - u_maskFeather, 0.5 + u_maskFeather, baseMask); float silhouetteMask = clamp(finalMask + seep, 0.0, 1.0); float flickerMultiplier = 1.0; if (u_flickerPerSecond > 0.0) { float flickerCycle = 1.0 / u_flickerPerSecond; float flickerPhase = mod(u_time, flickerCycle); float flickerEdge = flickerCycle * u_flickerDuration; float fadeWidth = flickerCycle * u_flickerFade * 0.5; float isFlickerOff = 1.0 - smoothstep(flickerEdge - fadeWidth, flickerEdge + fadeWidth, flickerPhase); flickerMultiplier = 1.0 - (isFlickerOff * u_flickerIntensity); } float effectAmount = u_overallOpacity * flickerMultiplier; vec4 foregroundColor = mix(originalGrayscale, effectedGrayscale, effectAmount); vec4 backgroundColor = u_useBackground ? texture2D(u_backgroundTex, uv) : originalGrayscale; gl_FragColor = mix(backgroundColor, foregroundColor, silhouetteMask); }`;
    const definitions = { Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.005, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } }, Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 30, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 10, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.2, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } }, Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } }, Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.1, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } }, Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.01, neutral: 0.0 } } }, Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.5, neutral: 0.0 } } } };
    const globalDefinitions = { Opacity: { title: 'Global Opacity', active: true, controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0, neutral: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1, neutral: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 } } }, Seep: { title: 'Effect Seep', active: true, controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 2.0, neutral: 0.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 20, neutral: 0.0 } } } };

    const Renderer = { /* ... Unchanged Renderer object, but its `render` method is now corrected below ... */ 
      gl: null, program: null, textures: {}, framebuffers: {}, uniforms: {}, maskCanvas: document.createElement('canvas'),
      init(canvas, vsSrc, fsSrc, uniformKeys) { this.gl = canvas.getContext('webgl', { premultipliedAlpha: false, antialias: true }); if (!this.gl) throw new Error('WebGL not available'); const compile = (type, src) => { const s = this.gl.createShader(type); this.gl.shaderSource(s, src); this.gl.compileShader(s); if (!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) throw new Error(`Shader compile error: ${this.gl.getShaderInfoLog(s)}`); return s; }; this.program = this.gl.createProgram(); this.gl.attachShader(this.program, compile(this.gl.VERTEX_SHADER, vsSrc)); this.gl.attachShader(this.program, compile(this.gl.FRAGMENT_SHADER, fsSrc)); this.gl.linkProgram(this.program); if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) throw new Error(`Program link error: ${this.gl.getProgramInfoLog(this.program)}`); const buffer = this.gl.createBuffer(); this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer); this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), this.gl.STATIC_DRAW); const posLoc = this.gl.getAttribLocation(this.program, 'a_pos'); this.gl.enableVertexAttribArray(posLoc); this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0); const createTex = () => { const tex = this.gl.createTexture(); this.gl.bindTexture(this.gl.TEXTURE_2D, tex); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); return tex; }; this.textures = { video: createTex(), feedbackA: createTex(), feedbackB: createTex(), mask: createTex(), background: createTex() }; this.framebuffers.feedback = this.gl.createFramebuffer(); this.gl.useProgram(this.program); uniformKeys.forEach(key => this.uniforms[key] = this.gl.getUniformLocation(this.program, key)); },
      fit(video) { if (!video.videoWidth) return; const { videoWidth: w, videoHeight: h } = video; const canvas = this.gl.canvas; if (canvas.width === w && canvas.height === h) return; canvas.width = w; canvas.height = h; const resizableTextures = [this.textures.video, this.textures.feedbackA, this.textures.feedbackB, this.textures.mask]; for (const tex of resizableTextures) { this.gl.bindTexture(this.gl.TEXTURE_2D, tex); this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, w, h, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null); } this.gl.viewport(0, 0, w, h); },
      drawMask(video, segmentationMask) { const { videoWidth: W, videoHeight: H } = video; const ctx = this.maskCanvas.getContext('2d'); if (this.maskCanvas.width !== W || this.maskCanvas.height !== H) { this.maskCanvas.width = W; this.maskCanvas.height = H; } ctx.fillStyle = 'black'; ctx.fillRect(0, 0, W, H); if (segmentationMask) { ctx.drawImage(segmentationMask, 0, 0, W, H); } this.gl.activeTexture(this.gl.TEXTURE2); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.mask); this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true); this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.maskCanvas); },
      render(appState) {
        const { video, t, state, backgroundMedia } = appState;
        if (!state.controls) return; // Safety check
        this.gl.useProgram(this.program);
        this.gl.activeTexture(this.gl.TEXTURE0); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.video); this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true); this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, video);
        const useBg = state.checkboxes ? state.checkboxes.useBgChk : false;
        if (useBg && (backgroundMedia.videoWidth || backgroundMedia.naturalWidth || backgroundMedia.width)) { this.gl.activeTexture(this.gl.TEXTURE3); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.background); this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true); this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, backgroundMedia); }
        this.gl.uniform2f(this.uniforms.u_resolution, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform1f(this.uniforms.u_time, t);

        // --- CORRECTED DYNAMIC UNIFORM SETTING ---
        for (const [groupKey, def] of Object.entries(definitions)) {
            const groupIsActive = state.toggles[groupKey];
            for (const controlKey in def.controls) {
                let val;
                const useJitter = groupIsActive && state.toggles.Jitter && jitterState[groupKey]?.[controlKey];
                if (useJitter) {
                    val = jitterState[groupKey][controlKey].current;
                } else if (groupIsActive) {
                    val = parseFloat(state.controls[groupKey][controlKey]);
                } else {
                    val = def.controls[controlKey].neutral;
                }
                this.gl.uniform1f(this.uniforms[`u_${controlKey}`], val);
            }
        }
        for (const [groupKey, def] of Object.entries(globalDefinitions)) {
            for (const controlKey in def.controls) {
                const val = parseFloat(state.globalControls[groupKey][controlKey]);
                this.gl.uniform1f(this.uniforms[`u_${controlKey}`], val);
            }
        }
        
        this.gl.uniform1i(this.uniforms.u_useBackground, useBg);
        this.gl.uniform1f(this.uniforms.u_maskFeather, state.misc ? parseFloat(state.misc.maskFeather) : 0.15);
        this.gl.uniform1i(this.uniforms.u_tex, 0); this.gl.uniform1i(this.uniforms.u_feedbackTex, 1); this.gl.uniform1i(this.uniforms.u_maskTex, 2); this.gl.uniform1i(this.uniforms.u_backgroundTex, 3);
        this.gl.activeTexture(this.gl.TEXTURE1); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.feedbackA); this.gl.uniform1i(this.uniforms.u_isFeedbackPass, 1); this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffers.feedback); this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.textures.feedbackB, 0); this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4); this.gl.uniform1i(this.uniforms.u_isFeedbackPass, 0); this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null); this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        [this.textures.feedbackA, this.textures.feedbackB] = [this.textures.feedbackB, this.textures.feedbackA];
      }
    };
    const BodySegmenter = { /* ... Full, unchanged BodySegmenter object ... */
      segmenter: null, lastResult: null, isReady: false, isBusy: false, lastUpdateTime: 0, minInterval: 60,
      async init() { if (this.isReady) return true; try { this.segmenter = new window.SelfieSegmentation({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}` }); this.segmenter.setOptions({ modelSelection: 1 }); this.segmenter.onResults(res => { this.lastResult = res.segmentationMask; this.isBusy = false; }); await this.segmenter.initialize(); this.isReady = true; return true; } catch (err) { console.error("Selfie Segmentation initialization failed:", err); return false; } },
      update(video) { const now = performance.now(); if (this.isReady && !this.isBusy && (now - this.lastUpdateTime) > this.minInterval) { this.isBusy = true; this.lastUpdateTime = now; this.segmenter.send({ image: video }); } }
    };

    const App = {
      stream: null, rafId: null,
      setStatus(text, isError = false) {
        channel.postMessage({ type: 'statusUpdate', payload: { text, isError } });
      },
      updateJitter(t) {
          if (!currentState.controls || !currentState.toggles.Jitter) return;
          const jitterAmount = parseFloat(currentState.controls.Jitter.jitterAmount);
          const jitterSpeed = parseFloat(currentState.controls.Jitter.jitterSpeed);
          for (const [groupKey, groupDef] of Object.entries(definitions)) {
              if (groupKey === 'Jitter' || !currentState.toggles[groupKey]) continue;
              for (const [controlKey, controlDef] of Object.entries(groupDef.controls)) {
                  const baseVal = parseFloat(currentState.controls[groupKey][controlKey]);
                  const range = controlDef.max - controlDef.min;
                  const offset = (Math.sin(t * jitterSpeed + controlKey.length) * Math.cos(t * jitterSpeed * 0.7 + groupKey.length)) * jitterAmount * range;
                  jitterState[groupKey][controlKey].current = Math.max(controlDef.min, Math.min(controlDef.max, baseVal + offset));
              }
          }
      },
      async start() {
        if (!navigator.mediaDevices?.getUserMedia) return this.setStatus('getUserMedia not supported.', true);
        try {
          this.setStatus('Requesting camera...');
          this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 1280, height: 720 }, audio: false });
          DOM.video.srcObject = this.stream;
          await new Promise(resolve => { DOM.video.onloadedmetadata = resolve; });
          await DOM.video.play();
          this.setStatus('Initializing GL...');
          const uniformKeys = [ 'u_resolution', 'u_time', 'u_isFeedbackPass', 'u_tex', 'u_feedbackTex', 'u_maskTex', 'u_backgroundTex', 'u_useBackground', 'u_maskFeather' ];
          Object.values(definitions).forEach(def => Object.keys(def.controls).forEach(key => uniformKeys.push(`u_${key}`)));
          Object.values(globalDefinitions).forEach(def => Object.keys(def.controls).forEach(key => uniformKeys.push(`u_${key}`)));
          Renderer.init(DOM.glcanvas, vertSrc, fragSrc, uniformKeys);
          Renderer.fit(DOM.video);
          this.setStatus('Initializing Body Segmentation...');
          if (!(await BodySegmenter.init())) return this.setStatus('Segmentation Failed', true);
          this.setStatus('Running');
          if (this.rafId) cancelAnimationFrame(this.rafId);
          this.loop();
        } catch (err) { this.setStatus(`Error: ${err.message}`, true); }
      },
      stop() {
        if (this.rafId) cancelAnimationFrame(this.rafId); this.rafId = null;
        if (this.stream) this.stream.getTracks().forEach(t => t.stop()); this.stream = null;
        this.setStatus('Terminated');
      },
      loop(time) {
        this.rafId = requestAnimationFrame(t => this.loop(t));
        if (!DOM.video.videoWidth || !Renderer.gl || !currentState.checkboxes) return;
        Renderer.fit(DOM.video);
        BodySegmenter.update(DOM.video);
        Renderer.drawMask(DOM.video, BodySegmenter.lastResult);
        const t = currentState.checkboxes.animateChk ? time / 1000 : 0;
        this.updateJitter(t);
        const backgroundEl = !DOM.backgroundImage.classList.contains('hidden') ? DOM.backgroundImage : DOM.backgroundMedia;
        Renderer.render({ video: DOM.video, t: t, state: currentState, backgroundMedia: backgroundEl });
        const statusText = BodySegmenter.lastResult ? `BODY DETECTED [${Renderer.gl.canvas.width}x${Renderer.gl.canvas.height}]` : 'NO SIGNAL...';
        this.setStatus(statusText);
      },
      handleCommand(command) {
        if (command === 'start') this.start();
        else if (command === 'stop') this.stop();
      },
      handleStateUpdate(newState) {
          currentState = newState;
          // Initialize jitter state object based on the definitions
          for (const groupKey in definitions) {
              if (!jitterState[groupKey]) jitterState[groupKey] = {};
              for (const controlKey in definitions[groupKey].controls) {
                  if (!jitterState[groupKey][controlKey]) jitterState[groupKey][controlKey] = { current: 0 };
              }
          }
          if (currentState.checkboxes) {
            DOM.glcanvas.style.transform = currentState.checkboxes.mirrorChk ? 'scaleX(-1)' : 'none';
          }
      },
       handleBackgroundUpdate(bg) {
          const url = URL.createObjectURL(bg.file);
          if (bg.file.type.startsWith('image/')) {
              DOM.backgroundImage.src = url;
              DOM.backgroundImage.classList.remove('hidden');
              DOM.backgroundMedia.classList.add('hidden');
              DOM.backgroundMedia.pause();
              DOM.backgroundMedia.src = '';
          } else if (bg.file.type.startsWith('video/')) {
              DOM.backgroundMedia.src = url;
              DOM.backgroundMedia.play();
              DOM.backgroundMedia.classList.remove('hidden');
              DOM.backgroundImage.classList.add('hidden');
              DOM.backgroundImage.src = '';
          }
      }
    };

    // --- Main Communication Logic ---
    channel.addEventListener('message', (event) => {
      const { type, payload } = event.data;
      if (type === 'command') App.handleCommand(payload);
      if (type === 'stateUpdate') App.handleStateUpdate(payload);
      if (type === 'backgroundUpdate') App.handleBackgroundUpdate(payload);
    });

    // When this window is ready, ask the controls for the current state.
    channel.postMessage({ type: 'requestState' });
    App.setStatus('IDLE');
    
  })();
</script>
