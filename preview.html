<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Preview</title>
  <style>
    :root{
      --bg:#000;--fg:#eaeaea;--muted:#888;--accent:#fff;--panel:#0a0a0a;
      --border:#2a2a2a;--ok:#33d17a;--warn:#f6c945;--err:#ff6464;
    }
    html,body{margin:0;padding:0;height:100%;background:#000;color:#eaeaea;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .stage{position:fixed;inset:0;display:grid;grid-template-rows:1fr;grid-template-columns:1fr;place-items:center;background:#000}
    canvas{display:block;max-width:100%;max-height:100%}
    .hud{position:fixed;left:0;right:0;bottom:0;display:flex;gap:8px;align-items:center;padding:10px 12px;background:linear-gradient(180deg,transparent,rgba(0,0,0,.45))}
    .hud .btn{background:#111;border:1px solid #333;color:#eaeaea;border-radius:8px;padding:6px 10px}
    .hud .btn:hover{background:#1b1b1b}
    .hud .k{color:#aaa}
    .logos{position:fixed;inset:0;pointer-events:none}
    .logos img{position:absolute;opacity:.85;filter:drop-shadow(0 2px 6px rgba(0,0,0,.4))}
  </style>
</head>
<body>
  <div class="stage">
    <canvas id="glcanvas" width="720" height="1280"></canvas>
  </div>

  <div class="logos">
    <img id="logoTopLeft" style="top:16px;left:16px;width:200px;height:auto" src="assets/logo1.png" alt="">
    <img id="logoTopRight" style="top:16px;right:16px;width:200px;height:auto" src="assets/logo2.png" alt="">
  </div>

  <div class="hud">
    <button id="btnStart" class="btn">Start Recording</button>
    <button id="btnStop" class="btn">Stop</button>
    <span id="status" class="k">idle</span>
  </div>

  <script>
  (() => {
    // ------- minimal demo GL scene (placeholder) -------
    const App = {
      elements: {},
      state: {
        showLogos: true,
      },

      init() {
        this.elements.glcanvas = document.getElementById('glcanvas');
        this.elements.logoTopLeft = document.getElementById('logoTopLeft');
        this.elements.logoTopRight = document.getElementById('logoTopRight');
        this.elements.btnStart = document.getElementById('btnStart');
        this.elements.btnStop = document.getElementById('btnStop');
        this.elements.status = document.getElementById('status');

        this.channel = new BroadcastChannel('unknown_signal');
        this.channel.onmessage = (e)=>this.handleMessage(e.data);

        this.elements.btnStart.addEventListener('click', async () => {
          this.elements.status.textContent = 'recording…';
          this.channel.postMessage({ type:'record_start' });
        });
        this.elements.btnStop.addEventListener('click', ()=> {
          this.elements.status.textContent = 'stopping…';
          this.stopRecording();
        });

        this.setupCanvas();
        this.render();
      },

      setupCanvas() {
        const c = this.elements.glcanvas;
        const ctx = c.getContext('2d');
        this._ctx2d = ctx;
        this._t0 = performance.now();
      },

      render() {
        const ctx = this._ctx2d;
        const c = this.elements.glcanvas;
        const t = (performance.now() - this._t0)/1000;
        ctx.clearRect(0,0,c.width,c.height);
        // simple animated background
        const g = ctx.createLinearGradient(0,0,c.width,c.height);
        g.addColorStop(0, `hsl(${(t*20)%360} 80% 50%)`);
        g.addColorStop(1, `hsl(${((t*20)+120)%360} 80% 50%)`);
        ctx.fillStyle = g; ctx.fillRect(0,0,c.width,c.height);
        // text
        ctx.fillStyle = 'rgba(0,0,0,.2)';
        ctx.font = '80px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('PREVIEW', c.width/2, c.height/2);
        requestAnimationFrame(this.render.bind(this));
      },

      handleMessage(data) {
        if (data.type === 'record_start') {
          // host asked us to record for some time / until stop
          this.recordCanvasFiveSeconds(/* preferMp4: */ true).then(({blob,mime}) => {
            this.channel.postMessage({ type:'recording_complete', payload:{ blob }});
            this.elements.status.textContent = 'done';
          }).catch(err => {
            this.channel.postMessage({ type:'recording_error', payload:{ message:String(err) }});
            this.elements.status.textContent = 'error';
          });
        } else if (data.type === 'record_stop') {
          this.stopRecording();
        } else if (data.type === 'state_update') {
          const st = data.payload || {};
          this.state.showLogos = !!(st.checkboxes?.logoChk ?? true);
        }
      },

      // Recording function used by Controls
      async recordCanvasFiveSeconds(preferMp4 = false) {
        const glCanvas = this.elements.glcanvas;
        const logoTopLeft = this.elements.logoTopLeft;
        const logoTopRight = this.elements.logoTopRight;

        const compositeCanvas = document.createElement('canvas');
        compositeCanvas.width = glCanvas.width;
        compositeCanvas.height = glCanvas.height;
        const ctx = compositeCanvas.getContext('2d');

        // 30fps capture
        const stream = compositeCanvas.captureStream(30);
        const chunks = [];

        const optionsList = [
          { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2_000_000 },
          { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2_000_000 },
        ];

        // ✅ FIXED: 'codeacs' → 'codecs'
        if (preferMp4) optionsList.unshift({ mimeType: 'video/mp4;codecs=h264' });

        let rec = null, mime = '';
        for (const opt of optionsList) {
          try {
            if (MediaRecorder.isTypeSupported(opt.mimeType)) {
              rec = new MediaRecorder(stream, opt);
              mime = rec.mimeType;
              break;
            }
          } catch {}
        }
        if (!rec) throw new Error('MediaRecorder unavailable');

        return await new Promise((resolve, reject) => {
          let stopped = false, rafId = null;

          function drawCompositeFrame() {
            if (stopped) return;
            ctx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            ctx.drawImage(glCanvas, 0, 0);
            if (App.state.showLogos) {
              const logo1Width = logoTopLeft.naturalWidth * 0.75;
              const logo1Height = logoTopLeft.naturalHeight * 0.75;
              ctx.drawImage(logoTopLeft, 20, 20, logo1Width, logo1Height);

              const logo2Width = logoTopRight.naturalWidth * 0.75;
              const logo2Height = logoTopRight.naturalHeight * 0.75;
              ctx.drawImage(logoTopRight, compositeCanvas.width - 20 - logo2Width, 20, logo2Width, logo2Height);
            }
            rafId = requestAnimationFrame(drawCompositeFrame);
          }

          rec.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
          rec.onerror = (e) => { stopped = true; if (rafId) cancelAnimationFrame(rafId); reject(e.error || e); };
          rec.onstop = () => {
            stopped = true;
            if (rafId) cancelAnimationFrame(rafId);
            resolve({ blob: new Blob(chunks, { type: mime }), mime });
          };

          rec.start();

          drawCompositeFrame();

          // stop when host sends stop, or after 5 seconds (safety)
          setTimeout(() => { try { rec.stop(); } catch {} }, 5000);

          this._activeRecorder = rec;
          this._stopComposite = () => { try { rec.stop(); } catch {} };
        });
      },

      stopRecording() {
        if (this._stopComposite) this._stopComposite();
        this.channel?.postMessage({ type:'record_stop_ack' });
      }
    };

    window.addEventListener('load', () => App.init());
  })();
  </script>
</body>
</html>
