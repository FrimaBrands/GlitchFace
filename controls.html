// Replace the Remote.handleRecordingBlob function in controls.html with this updated version:

async handleRecordingBlob(blob) {
    const conn = this.activeConnection;
    if (!conn) { 
        this.isRecording = false; 
        this.updateStatus(); 
        return; 
    }
    
    const { type: mime } = blob;
    const arrayBuf = await blob.arrayBuffer(); 
    const total = arrayBuf.byteLength;
    
    // Always use .mp4 extension if MP4 was successfully used, otherwise fallback to .webm
    const fileExt = mime.includes('mp4') ? 'mp4' : 'webm';
    const filename = `unknown_${Date.now()}.${fileExt}`;
    
    console.log(`Sending file: ${filename}, MIME: ${mime}, Size: ${total} bytes`);
    
    conn.send(JSON.stringify({ 
        type: 'recordingMeta', 
        mime, 
        totalBytes: total, 
        filename 
    }));
    
    const CHUNK = 64 * 1024; 
    let sent = 0; 
    const channel = conn.dataChannel;
    
    while (sent < total) {
        if (channel && channel.bufferedAmount > 1024 * 1024) { 
            await new Promise(r => { 
                channel.onbufferedamountlow = r; 
            }); 
        }
        const end = Math.min(total, sent + CHUNK); 
        conn.send(arrayBuf.slice(sent, end)); 
        sent = end;
    }
    
    conn.send(JSON.stringify({ type: 'recordingEnd' }));
    this.isRecording = false; 
    this.activeConnection = null; 
    this.updateStatus();
},

// Also update the onMessage function to always request MP4:

async onMessage(msg, conn) {
    try {
        const data = typeof msg === 'string' ? JSON.parse(msg) : msg;
        if (data.type === 'hello') {
            if (data.token !== this.sessionToken) { 
                conn.send(JSON.stringify({ type:'error', message: 'Invalid token.' })); 
                setTimeout(() => { try { conn.close(); } catch {} }, 100); 
                return; 
            }
            // Store capability but always prefer MP4
            conn.capabilities = { supportsWebM: !!data.supportsWebM, supportsMp4: true };
            conn.send(JSON.stringify({ type:'helloAck', ok:true }));
        } else if (data.type === 'startRecording') {
            if (!this.armed) return conn.send(JSON.stringify({ type: 'error', message: 'Remote not armed.' }));
            if (this.isRecording) return conn.send(JSON.stringify({ type: 'error', message: 'Host busy.' }));
            this.isRecording = true; 
            this.activeConnection = conn; 
            this.updateStatus();
            
            // Always prefer MP4
            const preferMp4 = true;
            App.channel.postMessage({ 
                type: 'start_recording', 
                payload: { preferMp4 } 
            });
        }
    } catch (e) { 
        console.error('Remote message error', e); 
        this.isRecording = false; 
        this.updateStatus(); 
    }
}
