<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Controls</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'JetBrains Mono', monospace; background-color: #0a0a0a; color: #EAEAEA; }
    .custom-scrollbar::-webkit-scrollbar { width: 4px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; }
    input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 2px; background: #333; outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: #EAEAEA; cursor: pointer; border: none; border-radius: 0; }
    input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; background: #EAEAEA; cursor: pointer; border: none; border-radius: 0; }
    .status-indicator::after { content: '■'; display: inline-block; margin-left: 6px; animation: blink 0.7s step-end infinite; color: #00ff00; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    .status-indicator.error::after { color: #ff0000; }
    .tab-button { border-color: #333; transition: all 0.2s ease-in-out; }
    .tab-button.active { border-color: #EAEAEA; color: #FFFFFF; background-color: #1a1a1a; }
    .btn { border: 1px solid #555; transition: all 0.2s ease-in-out; }
    .btn:hover { background-color: #EAEAEA; color: #000; border-color: #EAEAEA; }
    .btn:disabled { opacity: 0.4; pointer-events: none; }
    .btn-primary { background-color: #EAEAEA; color: #000; border-color: #EAEAEA; }
    .btn-primary:hover { background-color: #000; color: #EAEAEA; }
    .form-checkbox { appearance: none; -webkit-appearance: none; height: 14px; width: 14px; background-color: transparent; border: 1px solid #555; cursor: pointer; }
    .form-checkbox:checked { background-color: #EAEAEA; }
  </style>
</head>
<body class="h-screen flex flex-col">
  <div class="controls-panel w-full h-full flex flex-col bg-[#0a0a0a]">
    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h1 class="text-xl font-bold text-white tracking-widest">U N K N O W N</h1>
      <p class="text-sm text-gray-400 font-mono">// CONTROLS</p>
      <div id="msg" class="text-red-400 font-mono text-xs mt-2 h-4"></div>
      <div id="statusBar" class="font-mono text-xs status-indicator mt-2">STATUS: READY</div>
    </div>

    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h2 class="font-bold text-gray-300 mb-2">// PRESET_MANAGER</h2>
      <select id="presetList" class="w-full bg-black border border-gray-700 p-2 mb-2 text-sm"></select>
      <div class="grid grid-cols-3 gap-2">
        <input type="text" id="presetName" placeholder="> Preset Name..." class="col-span-3 bg-black border border-gray-700 p-2 text-sm">
        <button id="savePresetBtn" class="btn font-semibold py-1 text-sm">Save</button>
        <button id="deletePresetBtn" class="btn font-semibold py-1 text-sm">Delete</button>
        <button id="randomBtn" class="btn font-semibold py-1 text-sm">Randomize</button>
      </div>
    </div>

    <div class="flex border-b border-gray-800 flex-shrink-0">
      <button id="globalsTabBtn" class="tab-button active flex-1 py-2 text-sm font-semibold">Globals</button>
      <button id="effectsTabBtn" class="tab-button flex-1 py-2 text-sm font-semibold">Effects</button>
    </div>

    <div class="flex-grow custom-scrollbar overflow-y-auto">
      <div id="effects-tab-content" class="hidden p-4 space-y-4"></div>
      <div id="globals-tab-content" class="p-4 space-y-4">
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// REMOTE_TRIGGER</h3>
          <div class="space-y-3">
            <div class="grid grid-cols-2 gap-2">
              <button id="remoteShowQR" class="btn font-semibold py-2 text-sm">Open QR</button>
              <button id="remoteReset" class="btn font-semibold py-2 text-sm" disabled>Disarm</button>
            </div>
            <div id="remoteStatus" class="text-xs font-mono text-green-400">REMOTE: idle</div>
          </div>
        </div>

        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// BACKGROUND_SOURCE</h3>
          <div class="space-y-3">
            <button id="bgUploadBtn" class="w-full btn font-semibold py-2 text-sm">Upload Image/Video</button>
            <input type="file" id="bgUpload" accept="image/*,video/*" class="hidden">
            <label class="flex items-center justify-between text-sm cursor-pointer"><span>USE CUSTOM BG</span><input type="checkbox" id="useBgChk" class="form-checkbox" disabled></label>
            <div class="space-y-2">
              <div class="flex justify-between items-center"><label class="text-sm">MASK FEATHER</label><span id="maskFeatherValue" class="text-sm font-mono">0.150</span></div>
              <input type="range" id="maskFeather" min="0.01" max="0.5" step="0.001" value="0.15">
            </div>
          </div>
        </div>

        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// SYSTEM_SETTINGS</h3>
          <div class="space-y-3">
            <label class="flex items-center justify-between text-sm cursor-pointer"><span>ANIMATE EFFECTS</span><input type="checkbox" id="animateChk" class="form-checkbox" checked></label>
            <label class="flex items-center justify-between text-sm cursor-pointer"><span>MIRROR PREVIEW</span><input type="checkbox" id="mirrorChk" class="form-checkbox" checked></label>
            <label class="flex items-center justify-between text-sm cursor-pointer"><span>SHOW LOGOS</span><input type="checkbox" id="logoChk" class="form-checkbox" checked></label>
          </div>
        </div>

        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// AUTOMATION_MODULE</h3>
          <div class="space-y-2">
            <div class="flex justify-between items-center"><label class="text-sm">AUTO-RANDOMIZE</label><span id="autoRandomizeValue" class="text-sm font-mono">1.0s</span></div>
            <input type="range" id="autoRandomizeSlider" min="0" max="30" step="0.5" value="1">
          </div>
          <div class="space-y-2 mt-3">
            <div class="flex justify-between items-center"><label class="text-sm">PRESET-ITERATION</label><span id="presetIterationValue" class="text-sm font-mono">Off</span></div>
            <input type="range" id="presetIterationSlider" min="0" max="30" step="0.5" value="0">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // --- CONTROLS logic ---
  (() => {
    const UI = {
      elements: {}, state: { ui: {}, jitter: {} }, globalState: { ui: {} },
      definitions: {}, globalDefinitions: {},
      init(definitions, globalDefinitions) {
        this.definitions = definitions; this.globalDefinitions = globalDefinitions;
        const ids = ['statusBar','msg','savePresetBtn','deletePresetBtn','presetName','presetList','randomBtn','animateChk','mirrorChk','logoChk','bgUploadBtn','bgUpload','useBgChk','maskFeather','maskFeatherValue','effectsTabBtn','globalsTabBtn','effects-tab-content','globals-tab-content','autoRandomizeSlider','autoRandomizeValue','presetIterationSlider','presetIterationValue'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        for (const [k,def] of Object.entries(this.definitions)) this.createControlGroup(k,def,this.state,this.elements['effects-tab-content'],true);
        for (const [k,def] of Object.entries(this.globalDefinitions)) this.createControlGroup(k,def,this.globalState,this.elements['globals-tab-content'],false);
        this.elements.effectsTabBtn.addEventListener('click', () => this.switchTab('effects'));
        this.elements.globalsTabBtn.addEventListener('click', () => this.switchTab('globals'));
        this.elements.bgUploadBtn.addEventListener('click', () => this.elements.bgUpload.click());
        this.elements.maskFeather.addEventListener('input', () => { this.elements.maskFeatherValue.textContent = parseFloat(this.elements.maskFeather.value).toFixed(3); });
        this.elements.autoRandomizeSlider.addEventListener('input', () => { const v = parseFloat(this.elements.autoRandomizeSlider.value); this.elements.autoRandomizeValue.textContent = v===0?'Off':`${v.toFixed(1)}s`; });
        this.elements.presetIterationSlider.addEventListener('input', () => { const v = parseFloat(this.elements.presetIterationSlider.value); this.elements.presetIterationValue.textContent = v===0?'Off':`${v.toFixed(1)}s`; });
        document.querySelectorAll('input, select').forEach(el => el.addEventListener('change', () => App.broadcastState()));
        document.querySelectorAll('input[type="range"]').forEach(el => el.addEventListener('input', () => App.broadcastState()));
      },
      switchTab(tab){ const eff=tab==='effects'; this.elements.effectsTabBtn.classList.toggle('active',eff); this.elements.globalsTabBtn.classList.toggle('active',!eff); this.elements['effects-tab-content'].classList.toggle('hidden',!eff); this.elements['globals-tab-content'].classList.toggle('hidden',eff); },
      createControlGroup(key, def, stateObj, parent, withToggle){
        const group=document.createElement('div'); group.className='control-group bg-black/50 border border-gray-800 p-3';
        const header=document.createElement('div'); header.className='flex items-center justify-between';
        const title=document.createElement('h3'); title.className='font-semibold text-gray-200'; title.textContent=`// ${def.title.toUpperCase()}`; header.appendChild(title);
        const content=document.createElement('div'); content.className='mt-3 space-y-3';
        if(withToggle){ header.classList.add('cursor-pointer'); const toggle=document.createElement('input'); toggle.type='checkbox'; toggle.checked=def.active; toggle.className='form-checkbox';
          if(!def.active) content.classList.add('hidden');
          toggle.addEventListener('change',()=>{ def.active=toggle.checked; App.broadcastState(); });
          header.addEventListener('click',(e)=>{ if(e.target!==toggle){ toggle.checked=!toggle.checked; toggle.dispatchEvent(new Event('change')); } content.classList.toggle('hidden',!toggle.checked); });
          def.toggleElement=toggle; header.appendChild(toggle);
        }
        stateObj.ui[key]={}; if(stateObj.jitter){ stateObj.jitter[key]={}; }
        for(const [controlKey,controlDef] of Object.entries(def.controls)){
          const slider=this.createSlider(controlKey,controlDef); content.appendChild(slider.container);
          stateObj.ui[key][controlKey]=slider.input;
          if(stateObj.jitter){ stateObj.jitter[key][controlKey]={ base: controlDef.value, current: controlDef.value }; slider.input.addEventListener('input',()=>{ stateObj.jitter[key][controlKey].base=parseFloat(slider.input.value); }); }
        }
        group.append(header,content); parent.appendChild(group);
      },
      createSlider(id,def){ const c=document.createElement('div'); c.className='space-y-2';
        const lc=document.createElement('div'); lc.className='flex justify-between items-center';
        const label=document.createElement('label'); label.className='text-sm'; label.textContent=def.label.toUpperCase();
        const val=document.createElement('span'); val.className='text-sm font-mono';
        const input=document.createElement('input'); input.type='range'; Object.assign(input,{min:def.min,max:def.max,step:def.step,value:def.value});
        const upd=()=>val.textContent=parseFloat(input.value).toFixed(String(def.step).includes('.')?3:0);
        input.addEventListener('input',upd); upd(); lc.append(label,val); c.append(lc,input); return {container:c,input};
      },
      updateJitter(t){
        if(!this.definitions.Jitter.active) return;
        const { jitterAmount, jitterSpeed } = this.state.ui.Jitter;
        const amount=parseFloat(jitterAmount.value), speed=parseFloat(jitterSpeed.value);
        for (const [gk,group] of Object.entries(this.state.jitter)){
          if (gk==='Jitter' || !this.definitions[gk].active) continue;
          for(const [ck,st] of Object.entries(group)){
            const slider=this.state.ui[gk][ck]; const range=parseFloat(slider.max)-parseFloat(slider.min);
            const off=(Math.sin(t*speed+ck.length)*Math.cos(t*speed*0.7+gk.length))*amount*range;
            st.current=Math.max(parseFloat(slider.min),Math.min(parseFloat(slider.max),st.base+off));
          }
        }
      },
      setStatus(text,isError=false){ document.getElementById('statusBar').textContent=`STATUS: ${text}`; document.getElementById('statusBar').classList.toggle('error',isError); },
      setMsg(text){ document.getElementById('msg').textContent=text; }
    };

    const PresetManager = {
      init(){ this.populateList(); UI.elements.savePresetBtn.addEventListener('click',()=>this.save()); UI.elements.deletePresetBtn.addEventListener('click',()=>this.delete()); UI.elements.presetList.addEventListener('change',()=>this.load()); UI.elements.randomBtn.addEventListener('click',()=>this.randomize()); },
      getPresets:()=>JSON.parse(localStorage.getItem('bodyGlitchV5.0Presets')||'{}'),
      savePresets:p=>localStorage.setItem('bodyGlitchV5.0Presets',JSON.stringify(p)),
      setAppState(state){
        if(!state) return;
        if(state.controls){ for(const [g,grp] of Object.entries(state.controls)){ if(UI.state.ui[g]){ for(const [k,v] of Object.entries(grp)){ const el=UI.state.ui[g][k]; if(el){ el.value=v; el.dispatchEvent(new Event('input')); if(UI.state.jitter[g]?.[k]) UI.state.jitter[g][k].base=parseFloat(el.value); } } } } }
        if(state.toggles){ for(const [g,checked] of Object.entries(state.toggles)){ const def=UI.definitions[g]; if(def&&def.toggleElement){ def.toggleElement.checked=checked; def.toggleElement.dispatchEvent(new Event('change')); } } }
        if(state.globalControls){ for(const [g,grp] of Object.entries(state.globalControls)){ if(UI.globalState.ui[g]){ for(const [k,v] of Object.entries(grp)){ const el=UI.globalState.ui[g][k]; if(el){ el.value=v; el.dispatchEvent(new Event('input')); } } } } }
        if(state.checkboxes){ UI.elements.animateChk.checked = state.checkboxes.animateChk ?? true; UI.elements.mirrorChk.checked = state.checkboxes.mirrorChk ?? true; UI.elements.useBgChk.checked = state.checkboxes.useBgChk ?? false; UI.elements.logoChk.checked = state.checkboxes.logoChk ?? true; }
        if(state.misc){ const s=UI.elements.maskFeather; if(s){ s.value=state.misc.maskFeather ?? '0.15'; s.dispatchEvent(new Event('input')); } }
        App.broadcastState();
      },
      populateList(){ const presets=this.getPresets(); const list=UI.elements.presetList; const cur=list.value; list.innerHTML='<option value="">-- LOAD PRESET --</option>'; for(const name in presets){ const opt=document.createElement('option'); opt.value=name; opt.textContent=name; list.appendChild(opt); } list.value=cur; },
      save(){ const name=UI.elements.presetName.value.trim(); if(!name) return UI.setMsg('Enter a preset name.'); const p=this.getPresets(); p[name]=App.getCurrentState(true); this.savePresets(p); this.populateList(); UI.elements.presetList.value=name; UI.setMsg(`Preset '${name}' saved.`); },
      delete(){ const name=UI.elements.presetList.value; if(!name) return UI.setMsg('Select a preset to delete.'); const p=this.getPresets(); delete p[name]; this.savePresets(p); this.populateList(); UI.elements.presetName.value=''; UI.setMsg(`Preset '${name}' deleted.`); },
      load(name){ const list=UI.elements.presetList; const chosen=name||list.value; if(!chosen) return; const p=this.getPresets(); if(p[chosen]){ this.setAppState(p[chosen]); UI.elements.presetName.value=chosen; list.value=chosen; UI.setMsg(`Preset '${chosen}' loaded.`); } },
      randomize(){ for(const g in UI.state.ui){ const def=UI.definitions[g]; if(def&&def.toggleElement){ def.toggleElement.checked=Math.random()>0.3; def.toggleElement.dispatchEvent(new Event('change')); } for(const k in UI.state.ui[g]){ const el=UI.state.ui[g][k]; const min=parseFloat(el.min), max=parseFloat(el.max), step=parseFloat(el.step); el.value=Math.round((min+Math.random()*(max-min))/step)*step; el.dispatchEvent(new Event('input')); } } UI.setMsg('Parameters randomized!'); App.broadcastState(); }
    };

    const App = {
      channel:null, definitions:{}, globalDefinitions:{}, rafId:null,
      lastRandomizeTime:0, lastPresetIterateTime:0, currentPresetIndex:0,
      bgObjectUrl:null,
      init(defs, gdefs){
        this.definitions=defs; this.globalDefinitions=gdefs;
        this.channel=new BroadcastChannel('unknown_signal');
        this.channel.onmessage = (e)=>this.handleMessage(e.data);
        UI.init(defs,gdefs);
        PresetManager.init();
        UI.elements.bgUpload.addEventListener('change',(e)=>this.handleBgUpload(e));
        this.loop();
        this.broadcastState();
      },
      handleMessage(data){
        if(data.type==='recording_complete'){ Remote.handleRecordingBlob(data.payload.blob); }
        else if(data.type==='recording_error'){ Remote.handleRecordingError(data.payload.message); }
      },
      handleBgUpload(e){
        const f=e.target.files[0]; if(!f) return;
        if(this.bgObjectUrl) URL.revokeObjectURL(this.bgObjectUrl);
        this.bgObjectUrl = URL.createObjectURL(f);
        UI.elements.useBgChk.disabled=true?false:true; UI.elements.useBgChk.checked=true;
        UI.setMsg(`Loaded background: ${f.name}`);
        this.broadcastState();
      },
      getCurrentState(forPreset=false){
        const state={ uniforms:{}, animate:UI.elements.animateChk.checked, mirror:UI.elements.mirrorChk.checked, showLogos:UI.elements.logoChk.checked, useBg:UI.elements.useBgChk.checked };
        if(forPreset){ state.controls={}; state.toggles={}; state.globalControls={}; state.checkboxes={}; state.misc={}; }
        for(const [g,grp] of Object.entries(UI.state.ui)){
          if(forPreset){ state.controls[g]={}; state.toggles[g]=this.definitions[g].active; }
          const active=this.definitions[g].active;
          for(const [k,control] of Object.entries(grp)){
            let val=active?parseFloat(control.value):this.definitions[g].controls[k].neutral;
            if(active && this.definitions.Jitter.active && UI.state.jitter[g]?.[k]) val=UI.state.jitter[g][k].current;
            state.uniforms[`u_${k}`]=val;
            if(forPreset){ state.controls[g][k]=control.value; }
          }
        }
        for(const [g,grp] of Object.entries(UI.globalState.ui)){
          if(forPreset){ state.globalControls[g]={}; }
          for(const [k,control] of Object.entries(grp)){
            state.uniforms[`u_${k}`]=parseFloat(control.value);
            if(forPreset){ state.globalControls[g][k]=control.value; }
          }
        }
        state.uniforms.u_maskFeather=parseFloat(UI.elements.maskFeather.value);
        if(this.bgObjectUrl){ state.bgFile={ url:this.bgObjectUrl, type:UI.elements.bgUpload.files[0].type }; }
        if(forPreset){
          state.checkboxes={ animateChk:state.animate, mirrorChk:state.mirror, useBgChk:state.useBg, logoChk:state.showLogos };
          state.misc={ maskFeather:UI.elements.maskFeather.value };
          delete state.uniforms; delete state.animate; delete state.mirror; delete state.useBg; delete state.bgFile; delete state.showLogos;
        }
        return state;
      },
      broadcastState(){ const payload=this.getCurrentState(); this.channel.postMessage({ type:'state_update', payload }); },
      loop(time){
        this.rafId=requestAnimationFrame(t=>this.loop(t));
        const t = UI.elements.animateChk.checked ? time/1000 : 0;
        UI.updateJitter(t);
        const autoInt=parseFloat(UI.elements.autoRandomizeSlider.value);
        if(autoInt>0){
          if(this.lastRandomizeTime===0){ PresetManager.randomize(); this.lastRandomizeTime=time||1; }
          else if((time-this.lastRandomizeTime)>autoInt*1000){ PresetManager.randomize(); this.lastRandomizeTime=time; }
        } else { this.lastRandomizeTime=0; }
        const iterInt=parseFloat(UI.elements.presetIterationSlider.value);
        if(iterInt>0){
          if(this.lastPresetIterateTime===0) this.lastPresetIterateTime=time;
          if((time-this.lastPresetIterateTime)>iterInt*1000){
            const presets=PresetManager.getPresets(); const names=Object.keys(presets);
            if(names.length>0){ this.currentPresetIndex=(this.currentPresetIndex+1)%names.length; PresetManager.load(names[this.currentPresetIndex]); }
            this.lastPresetIterateTime=time;
          }
        } else { this.lastPresetIterateTime=0; }
        this.broadcastState();
      }
    };

    // --- Remote Trigger + MP4 pipeline ---
    const Remote = {
      peer:null, connections:new Map(), sessionToken:null, armed:false, isRecording:false, activeConnection:null,
      init(){
        const els={ showQR:document.getElementById('remoteShowQR'), reset:document.getElementById('remoteReset') };
        els.showQR.addEventListener('click', async ()=>{ if(!this.armed) await this.arm(); this.openQRWindow(); });
        els.reset.addEventListener('click', ()=>this.disarm());
      },
      updateStatus(){
        const el=document.getElementById('remoteStatus');
        const count=this.connections.size; let text='REMOTE: idle';
        if(this.armed){
          if(this.isRecording) text=`REMOTE: RECORDING... (${count} connected)`;
          else if(count>0) text=`REMOTE: ${count} phone(s) connected. Ready.`;
          else if(this.peer && this.peer.id) text=`REMOTE: armed @ ${this.peer.id.slice(0,6)}…`;
          else text='REMOTE: arming...';
        }
        el.textContent=text;
      },
      lazyLoadPeerJS(){ return new Promise((res,rej)=>{ if(window.Peer) return res(); const s=document.createElement('script'); s.src='https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js'; s.onload=res; s.onerror=()=>rej(new Error('Failed to load PeerJS')); document.body.appendChild(s); }); },
      async arm(){
        await this.lazyLoadPeerJS();
        this.sessionToken = (crypto.getRandomValues(new Uint8Array(16))).reduce((s,b)=>s+b.toString(16).padStart(2,'0'),'');
        return new Promise((resolve,reject)=>{
          this.peer=new window.Peer(undefined,{debug:1,config:{'iceServers':[ {urls:'stun:stun.l.google.com:19302'} ]}});
          this.peer.on('open', id=>{ this.armed=true; this.updateStatus(); document.getElementById('remoteReset').disabled=false; this.peer.on('connection',c=>this.handleNewConnection(c)); resolve(); });
          this.peer.on('error', err=>{ console.error('PeerJS error:',err); this.disarm(); reject(err); });
        });
      },
      disarm(){ this.armed=false; for(const c of this.connections.values()){ try{ c.close(); }catch{} } this.connections.clear(); if(this.peer) try{ this.peer.destroy(); }catch{} this.peer=null; this.sessionToken=null; document.getElementById('remoteReset').disabled=true; this.updateStatus(); },
      handleNewConnection(conn){
        if(this.connections.size>=3){ const oldestId=this.connections.keys().next().value; if(oldestId){ const oldest=this.connections.get(oldestId); if(oldest){ oldest.send(JSON.stringify({type:'error',message:'New user connected.'})); setTimeout(()=>{ try{oldest.close();}catch{} },100);} this.connections.delete(oldestId);} }
        this.connections.set(conn.peer,conn); this.updateStatus();
        conn.on('data', msg=>this.onMessage(msg,conn));
        conn.on('close', ()=>{ this.connections.delete(conn.peer); this.updateStatus(); });
        conn.on('error', e=>{ console.error('Peer connection error:',e); this.connections.delete(conn.peer); this.updateStatus(); });
      },
      async onMessage(msg,conn){
        try{
          const data=typeof msg==='string'?JSON.parse(msg):msg;
          if(data.type==='hello'){
            if(data.token!==this.sessionToken){ conn.send(JSON.stringify({type:'error',message:'Invalid token.'})); setTimeout(()=>{ try{conn.close();}catch{} },100); return; }
            conn.capabilities={ supportsWebM:!!data.supportsWebM };
            conn.send(JSON.stringify({type:'helloAck',ok:true}));
          } else if(data.type==='startRecording'){
            if(!this.armed) return conn.send(JSON.stringify({type:'error',message:'Remote not armed.'}));
            if(this.isRecording) return conn.send(JSON.stringify({type:'error',message:'Host busy.'}));
            this.isRecording=true; this.activeConnection=conn; this.updateStatus();
            const preferMp4=true; // ensure preview prefers MP4 if available
            App.channel.postMessage({ type:'start_recording', payload:{ preferMp4 } });
          }
        } catch(e){ console.error('Remote message error',e); this.isRecording=false; this.updateStatus(); }
      },

      // Lazily load ffmpeg.wasm
      async loadFFmpeg(){
        if(window.__ffmpegLoaded) return window.__ffmpeg;
        await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/@ffmpeg/ffmpeg@0.12.8/dist/ffmpeg.min.js'; s.onload=res; s.onerror=()=>rej(new Error('Failed to load ffmpeg')); document.body.appendChild(s); });
        const { createFFmpeg, fetchFile } = window.FFmpeg;
        const ffmpeg = createFFmpeg({ log:false });
        await ffmpeg.load();
        window.__ffmpegLoaded=true;
        window.__ffmpeg={ ffmpeg, fetchFile };
        return window.__ffmpeg;
      },

      // Always send MP4: convert here if needed, then stream chunks to the phone
      async handleRecordingBlob(blob){
        const conn=this.activeConnection;
        if(!conn){ this.isRecording=false; this.updateStatus(); return; }

        try {
          let outMime = 'video/mp4';
          let outName = `unknown_${Date.now()}.mp4`;
          let outBuffer;

          if (blob.type && blob.type.includes('mp4')) {
            // Already MP4: no conversion
            outBuffer = await blob.arrayBuffer();
          } else {
            UI.setStatus('TRANSCODING → MP4');
            const { ffmpeg, fetchFile } = await this.loadFFmpeg();
            // write input
            ffmpeg.FS('writeFile','in.webm', await fetchFile(blob));
            // transcode: h264, yuv420p, faststart; no audio track during capture, so -an is fine
            await ffmpeg.run(
              '-i','in.webm',
              '-c:v','libx264','-preset','veryfast','-crf','23',
              '-pix_fmt','yuv420p',
              '-movflags','faststart',
              '-an',
              'out.mp4'
            );
            const data = ffmpeg.FS('readFile','out.mp4');
            outBuffer = data.buffer.slice(0);
            // cleanup
            try { ffmpeg.FS('unlink','in.webm'); ffmpeg.FS('unlink','out.mp4'); } catch {}
          }

          // send metadata (MP4) and chunks
          const total = outBuffer.byteLength;
          conn.send(JSON.stringify({ type:'recordingMeta', mime: outMime, totalBytes: total, filename: outName }));

          const CHUNK = 64*1024; let sent = 0; const channel = conn.dataChannel;
          while (sent < total) {
            if (channel && channel.bufferedAmount > 1024*1024) {
              await new Promise(r => { channel.onbufferedamountlow = r; });
            }
            const end = Math.min(total, sent + CHUNK);
            conn.send(outBuffer.slice(sent, end));
            sent = end;
          }

          conn.send(JSON.stringify({ type:'recordingEnd' }));
        } catch (err) {
          console.error('Transcode/send error:', err);
          if (this.activeConnection) this.activeConnection.send(JSON.stringify({ type:'error', message: 'Transcoding failed.' }));
        } finally {
          this.isRecording=false; this.activeConnection=null; this.updateStatus();
          UI.setStatus('READY');
        }
      },

      handleRecordingError(message){
        if(this.activeConnection){ this.activeConnection.send(JSON.stringify({ type:'error', message })); }
        this.isRecording=false; this.activeConnection=null; this.updateStatus();
      },

      openQRWindow(){
        if(!this.peer || !this.sessionToken) return;
        const url=new URL('phone.html', location.href);
        url.searchParams.set('host', this.peer.id);
        url.searchParams.set('token', this.sessionToken);
        const qrUrl=new URL('remote-qr.html', location.href);
        qrUrl.searchParams.set('target', url.toString());
        window.open(qrUrl.toString(),'_blank','noopener,noreferrer,width=520,height=600');
      }
    };

    // --- EFFECT DEFINITIONS (unchanged) ---
    const definitions = {
      Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label:'Amount', min:0, max:0.1, step:0.001, value:0.005, neutral:0.0 }, jitterSpeed: { label:'Speed', min:0, max:10, step:0.1, value:2.5, neutral:0.0 } } },
      Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity:{ label:'Global Intensity', min:0, max:100, step:1, value:30, neutral:0.0 }, globalSmearAngle:{ label:'Global Angle', min:0, max:360, step:1, value:0, neutral:0.0 }, spotSmearIntensity:{ label:'Spot Intensity', min:0, max:50, step:1, value:10, neutral:0.0 }, spotSmearDensity:{ label:'Spot Density', min:0, max:1, step:0.01, value:0.2, neutral:0.0 }, spotSmearSize:{ label:'Spot Size', min:5, max:50, step:1, value:20, neutral:0.0 } } },
      Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount:{ label:'Amount', min:0, max:1, step:0.01, value:0.33, neutral:0.0 }, feedbackZoom:{ label:'Zoom', min:0.95, max:1.05, step:0.001, value:1.00, neutral:1.0 } } },
      Flicker: { title: 'Light Flicker', active: true, controls: { flickerPerSecond:{ label:'Hz', min:0, max:20, step:0.1, value:3, neutral:0.0 }, flickerDuration:{ label:'Duration', min:0, max:1, step:0.01, value:0.35, neutral:0.0 }, flickerIntensity:{ label:'Intensity', min:0, max:2, step:0.01, value:0.5, neutral:0.0 }, flickerFade:{ label:'Fade', min:0, max:1, step:0.01, value:0.5, neutral:0.0 } } },
      Glitch: { title: 'Glitch', active: true, controls: { glitchIntensity:{ label:'Intensity', min:0, max:2, step:0.01, value:0.2, neutral:0.0 }, glitchBlockSize:{ label:'Block Size', min:4, max:64, step:1, value:16, neutral:16 } } },
      RGBShift: { title: 'RGB Shift', active: true, controls: { rgbShift:{ label:'Offset', min:0, max:8, step:0.01, value:1.25, neutral:0.0 } } },
      Noise: { title: 'Noise', active: true, controls: { noiseAmount:{ label:'Amount', min:0, max:1, step:0.01, value:0.08, neutral:0.0 }, noiseSpeed:{ label:'Speed', min:0, max:5, step:0.01, value:1.1, neutral:0.0 } } },
      Vignette: { title: 'Vignette', active: true, controls: { vignette:{ label:'Strength', min:0, max:1, step:0.01, value:0.25, neutral:0.0 } } }
    };
    const globalDefinitions = { Global: { title: 'Global', controls: { overallOpacity:{ label:'Opacity', min:0, max:1, step:0.01, value:1.0 }, maskFeather:{ label:'Mask Feather', min:0.01, max:0.5, step:0.001, value:0.15 } } } };

    // boot
    Remote.init();
    App.init(definitions, globalDefinitions);
  })();
  </script>
</body>
</html>
