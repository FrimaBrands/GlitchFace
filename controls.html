<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Controls</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'JetBrains Mono', monospace; background-color: #0a0a0a; color: #EAEAEA;}
    .custom-scrollbar::-webkit-scrollbar { width: 4px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; }
    input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 2px; background: #333; outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: #EAEAEA; cursor: pointer; border-radius: 0;}
    input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; background: #EAEAEA; cursor: pointer; border-radius: 0; }
    .tab-button { border-color: #333; transition: all 0.2s ease-in-out; }
    .tab-button.active { border-color: #EAEAEA; color: #FFFFFF; background-color: #1a1a1a; }
    .btn { border: 1px solid #555; transition: all 0.2s ease-in-out; }
    .btn:hover { background-color: #EAEAEA; color: #000; border-color: #EAEAEA; }
    .btn:disabled { opacity: 0.4; pointer-events: none; }
    .btn-primary { background-color: #EAEAEA; color: #000; border-color: #EAEAEA; }
    .btn-primary:hover { background-color: #000; color: #EAEAEA; }
    .form-checkbox { appearance: none; -webkit-appearance: none; height: 14px; width: 14px; background-color: transparent; border: 1px solid #555; cursor: pointer; }
    .form-checkbox:checked { background-color: #EAEAEA; }
  </style>
</head>
<body class="p-2">

  <div class="controls-panel w-full h-[98vh] bg-[#0a0a0a] border border-gray-800 flex flex-col">
    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h1 class="text-xl font-bold text-white tracking-widest">U N K N O W N</h1>
      <p class="text-sm text-gray-400 font-mono">// CONTROLS</p>
      <div class="flex space-x-2 mt-4">
        <button id="startBtn" class="flex-1 btn btn-primary font-bold py-2 px-4">Initialize</button>
        <button id="stopBtn" class="flex-1 btn font-bold py-2 px-4">Terminate</button>
      </div>
      <div id="msg" class="text-red-400 font-mono text-xs mt-2 h-4"></div>
    </div>

    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h2 class="font-bold text-gray-300 mb-2">// PRESET_MANAGER</h2>
      <select id="presetList" class="w-full bg-black border border-gray-700 p-2 mb-2 text-sm focus:outline-none focus:border-gray-400"></select>
      <div class="grid grid-cols-3 gap-2">
        <input type="text" id="presetName" placeholder="> Preset Name..." class="col-span-3 bg-black border border-gray-700 p-2 text-sm focus:outline-none focus:border-gray-400">
        <button id="savePresetBtn" class="btn font-semibold py-1 text-sm">Save</button>
        <button id="deletePresetBtn" class="btn font-semibold py-1 text-sm">Delete</button>
        <button id="randomBtn" class="btn font-semibold py-1 text-sm">Randomize</button>
      </div>
    </div>
    
    <div class="flex border-b border-gray-800 flex-shrink-0">
      <button id="globalsTabBtn" class="tab-button active flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 text-gray-400 hover:text-white">Globals</button>
      <button id="effectsTabBtn" class="tab-button flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 border-transparent text-gray-400 hover:text-white">Effects</button>
    </div>

    <div class="flex-grow custom-scrollbar overflow-y-auto">
      <div id="effects-tab-content" class="hidden p-4 space-y-4"></div>
      <div id="globals-tab-content" class="p-4 space-y-4">
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// BACKGROUND_SOURCE</h3>
          <p class="text-xs text-gray-500 mb-3">Note: Upload functionality is disabled in this view.</p>
          <div class="space-y-3">
              <label class="flex items-center justify-between text-sm cursor-pointer">
                  <span class="text-gray-400">USE CUSTOM BG</span>
                  <input type="checkbox" id="useBgChk" class="form-checkbox">
              </label>
              <div class="control-item space-y-2">
                  <div class="flex justify-between items-center">
                      <label for="maskFeather" class="text-sm font-medium text-gray-300">MASK FEATHER</label>
                      <span id="maskFeatherValue" class="text-sm font-mono text-gray-400">0.150</span>
                  </div>
                  <input type="range" id="maskFeather" min="0.01" max="0.5" step="0.001" value="0.15">
              </div>
          </div>
        </div>
        
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// SYSTEM_SETTINGS</h3>
          <div class="space-y-3">
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">ANIMATE EFFECTS</span>
              <input type="checkbox" id="animateChk" class="form-checkbox" checked>
            </label>
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">MIRROR CAMERA</span>
              <input type="checkbox" id="mirrorChk" class="form-checkbox" checked>
            </label>
          </div>
        </div>
        
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// AUTOMATION_MODULE</h3>
          <div class="control-item space-y-2">
            <div class="flex justify-between items-center">
              <label for="autoRandomizeSlider" class="text-sm font-medium text-gray-300">AUTO-RANDOMIZE</label>
              <span id="autoRandomizeValue" class="text-sm font-mono text-gray-400">Off</span>
            </div>
            <input type="range" id="autoRandomizeSlider" min="0" max="30" step="0.5" value="0">
          </div>
          <div class="control-item space-y-2 mt-3">
            <div class="flex justify-between items-center">
              <label for="presetIterationSlider" class="text-sm font-medium text-gray-300">PRESET-ITERATION</label>
              <span id="presetIterationValue" class="text-sm font-mono text-gray-400">Off</span>
            </div>
            <input type="range" id="presetIterationSlider" min="0" max="30" step="0.5" value="0">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    // This script now ONLY manages the UI and sends messages to the preview window.
    const UI = {
      elements: {},
      state: {}, // Local copy of the state for updating the UI
      channel: null,

      init(definitions, globalDefinitions, channel) {
        this.channel = channel;
        const ids = ['startBtn', 'stopBtn', 'msg', 'savePresetBtn', 'deletePresetBtn', 'presetName', 'presetList', 'randomBtn', 'animateChk', 'mirrorChk', 'useBgChk', 'maskFeather', 'maskFeatherValue', 'effectsTabBtn', 'globalsTabBtn', 'effects-tab-content', 'globals-tab-content', 'autoRandomizeSlider', 'autoRandomizeValue', 'presetIterationSlider', 'presetIterationValue'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        for (const [key, definition] of Object.entries(definitions)) {
          this.createControlGroup(key, definition, this.elements['effects-tab-content'], true);
        }
        for (const [key, definition] of Object.entries(globalDefinitions)) {
            this.createControlGroup(key, definition, this.elements['globals-tab-content'], false);
        }

        // --- Event Listeners ---
        const debouncedStateUpdate = this.debounce(() => {
            this.channel.postMessage({ type: 'stateUpdate', payload: this.getState() });
        }, 100);

        // This listener will be added to all sliders and toggles
        const genericInputListener = () => {
            this.updateJitterBase(); // Update jitter base values on manual input
            debouncedStateUpdate();
        };

        document.querySelectorAll('input[type="range"]').forEach(el => el.addEventListener('input', genericInputListener));
        document.querySelectorAll('.form-checkbox.toggle').forEach(el => el.addEventListener('change', genericInputListener));

        // System Checkboxes
        ['animateChk', 'mirrorChk', 'useBgChk'].forEach(id => {
            this.elements[id].addEventListener('change', () => {
                const payload = { [id]: this.elements[id].checked };
                this.channel.postMessage({ type: 'checkboxUpdate', payload });
            });
        });

        // Misc controls
        this.elements.maskFeather.addEventListener('input', () => {
            const val = parseFloat(this.elements.maskFeather.value);
            this.elements.maskFeatherValue.textContent = val.toFixed(3);
            this.channel.postMessage({ type: 'miscUpdate', payload: { maskFeather: val } });
        });
        
        // Automation
        const automationListener = () => {
            const autoRandomizeInterval = parseFloat(this.elements.autoRandomizeSlider.value);
            const presetIterationInterval = parseFloat(this.elements.presetIterationSlider.value);
            this.elements.autoRandomizeValue.textContent = autoRandomizeInterval === 0 ? 'Off' : `${autoRandomizeInterval.toFixed(1)}s`;
            this.elements.presetIterationValue.textContent = presetIterationInterval === 0 ? 'Off' : `${presetIterationInterval.toFixed(1)}s`;
            this.channel.postMessage({ type: 'automationUpdate', payload: { autoRandomizeInterval, presetIterationInterval } });
        };
        this.elements.autoRandomizeSlider.addEventListener('input', automationListener);
        this.elements.presetIterationSlider.addEventListener('input', automationListener);

        // Tab switching logic
        this.elements.effectsTabBtn.addEventListener('click', () => this.switchTab('effects'));
        this.elements.globalsTabBtn.addEventListener('click', () => this.switchTab('globals'));

        // Action Buttons
        this.elements.startBtn.addEventListener('click', () => this.channel.postMessage({ type: 'triggerAction', name: 'start' }));
        this.elements.stopBtn.addEventListener('click', () => this.channel.postMessage({ type: 'triggerAction', name: 'stop' }));
        this.elements.randomBtn.addEventListener('click', () => this.channel.postMessage({ type: 'triggerAction', name: 'randomize' }));
        
        // Preset Buttons
        this.elements.savePresetBtn.addEventListener('click', () => {
            const name = this.elements.presetName.value.trim();
            if (!name) return this.setMsg('Enter a preset name.');
            this.channel.postMessage({ type: 'triggerAction', name: 'savePreset', payload: name });
            this.setMsg(`Preset '${name}' saved.`);
        });
        this.elements.deletePresetBtn.addEventListener('click', () => {
            const name = this.elements.presetList.value;
            if (!name) return this.setMsg('Select a preset to delete.');
            this.channel.postMessage({ type: 'triggerAction', name: 'deletePreset', payload: name });
            this.setMsg(`Preset '${name}' deleted.`);
        });
        this.elements.presetList.addEventListener('change', () => {
            const name = this.elements.presetList.value;
            if (!name) return;
            this.channel.postMessage({ type: 'triggerAction', name: 'loadPreset', payload: name });
            this.setMsg(`Preset '${name}' loaded.`);
        });
        
        // Request initial state from the preview window
        this.channel.postMessage({ type: 'requestState' });
      },

      debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
              const later = () => {
                  clearTimeout(timeout);
                  func(...args);
              };
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
          };
      },
      
      getState() {
          const state = { controls: {}, toggles: {}, globalControls: {} };
          document.querySelectorAll('.control-group').forEach(group => {
              const key = group.dataset.groupkey;
              if (!key) return;
              
              const toggle = group.querySelector('.form-checkbox.toggle');
              if (toggle) {
                  state.toggles[key] = toggle.checked;
              }

              const isGlobal = group.parentElement.id.includes('globals');
              const targetState = isGlobal ? state.globalControls : state.controls;
              targetState[key] = {};

              group.querySelectorAll('input[type="range"]').forEach(slider => {
                  const controlKey = slider.dataset.controlkey;
                  targetState[key][controlKey] = slider.value;
              });
          });
          return state;
      },
      
      updateJitterBase() {
        // This function is no longer needed here, as jitter is computed in the preview window.
        // We just send the base values.
      },

      setState(newState) {
          if (!newState) return;
          const { controls, toggles, checkboxes, globalControls, misc } = newState;
          
          if (controls) {
              for (const [groupKey, group] of Object.entries(controls)) {
                  for (const [controlKey, value] of Object.entries(group)) {
                      const slider = document.querySelector(`[data-groupkey="${groupKey}"] [data-controlkey="${controlKey}"]`);
                      if (slider) {
                          slider.value = value;
                          slider.dispatchEvent(new Event('input', { bubbles: true }));
                      }
                  }
              }
          }
          if (toggles) {
              for (const [groupKey, isChecked] of Object.entries(toggles)) {
                  const toggle = document.querySelector(`[data-groupkey="${groupKey}"] .form-checkbox.toggle`);
                  if (toggle) {
                      toggle.checked = isChecked;
                  }
              }
          }
          if (globalControls) {
               for (const [groupKey, group] of Object.entries(globalControls)) {
                  for (const [controlKey, value] of Object.entries(group)) {
                      const slider = document.querySelector(`[data-groupkey="${groupKey}"] [data-controlkey="${controlKey}"]`);
                      if (slider) {
                          slider.value = value;
                          slider.dispatchEvent(new Event('input', { bubbles: true }));
                      }
                  }
              }
          }
          if (checkboxes) {
              for (const [key, value] of Object.entries(checkboxes)) {
                  if (this.elements[key]) this.elements[key].checked = value;
              }
          }
           if (misc) {
               if (misc.maskFeather !== undefined) {
                    this.elements.maskFeather.value = misc.maskFeather;
                    this.elements.maskFeather.dispatchEvent(new Event('input', { bubbles: true }));
               }
           }
      },
      
      populatePresetList(presets) {
        const { presetList } = this.elements;
        const currentVal = presetList.value;
        presetList.innerHTML = '<option value="">-- LOAD PRESET --</option>';
        presets.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name; opt.textContent = name; presetList.appendChild(opt);
        });
        presetList.value = currentVal;
      },

      switchTab(tabName) {
        if (tabName === 'effects') {
            this.elements.effectsTabBtn.classList.add('active');
            this.elements.globalsTabBtn.classList.remove('active');
            this.elements['effects-tab-content'].classList.remove('hidden');
            this.elements['globals-tab-content'].classList.add('hidden');
        } else {
            this.elements.effectsTabBtn.classList.remove('active');
            this.elements.globalsTabBtn.classList.add('active');
            this.elements['effects-tab-content'].add('hidden');
            this.elements['globals-tab-content'].classList.remove('hidden');
        }
      },

      createControlGroup(key, definition, parentElement, withToggle) {
        const group = document.createElement('div');
        group.className = 'control-group bg-black/50 border border-gray-800 p-3';
        group.dataset.groupkey = key;
        
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between';
        
        const title = document.createElement('h3');
        title.className = 'font-semibold text-gray-200';
        title.textContent = `// ${definition.title.toUpperCase()}`;
        header.appendChild(title);

        const content = document.createElement('div');
        content.className = 'mt-3 space-y-3';
        
        if (withToggle) {
            header.classList.add('cursor-pointer');
            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.checked = definition.active;
            toggle.className = 'form-checkbox toggle';
            if (!definition.active) content.classList.add('hidden');
            
            toggle.addEventListener('change', () => {
              content.classList.toggle('hidden', !toggle.checked);
            });
            header.addEventListener('click', (e) => {
                if(e.target !== toggle) {
                    toggle.checked = !toggle.checked;
                    toggle.dispatchEvent(new Event('change'));
                }
            });
            header.appendChild(toggle);
        }

        for (const [controlKey, controlDef] of Object.entries(definition.controls)) {
          const slider = this.createSlider(controlKey, controlDef);
          slider.input.dataset.controlkey = controlKey; // Store key on the element
          content.appendChild(slider.container);
        }
        
        group.append(header, content);
        parentElement.appendChild(group);
      },

      createSlider(id, def) {
        const container = document.createElement('div');
        container.className = 'control-item space-y-2';
        const labelContainer = document.createElement('div');
        labelContainer.className = 'flex justify-between items-center';
        const label = document.createElement('label');
        label.className = 'text-sm font-medium text-gray-300';
        label.textContent = def.label.toUpperCase();
        const valueSpan = document.createElement('span');
        valueSpan.className = 'text-sm font-mono text-gray-400';
        const input = document.createElement('input');
        input.type = 'range';
        Object.assign(input, { min: def.min, max: def.max, step: def.step, value: def.value });
        
        const updateValue = () => valueSpan.textContent = parseFloat(input.value).toFixed(String(def.step).includes('.') ? 3 : 0);
        input.addEventListener('input', updateValue);
        updateValue();
        
        labelContainer.append(label, valueSpan);
        container.append(labelContainer, input);
        return { container, input };
      },
      setMsg(text) { this.elements.msg.textContent = text; }
    };
    
    // --- Entry Point ---
    const definitions = { /* Same as index.html */ };
    const globalDefinitions = { /* Same as index.html */ };
    
    // Omitted definitions for brevity - they are identical to the ones in index.html
    const defs = {
      Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.0, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } },
      Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 0, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 0, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.0, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } },
      Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } },
      Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.0, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } },
      Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.0, neutral: 0.0 } } },
      Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.0, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.0, neutral: 0.0 } } }
    };
    const gDefs = {
        Opacity: { title: 'Global Opacity', active: true, controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0, neutral: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1, neutral: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }}},
        Seep: { title: 'Effect Seep', active: true, controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 0.0, neutral: 0.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 0.0, neutral: 0.0 }}}
    };

    const channel = new BroadcastChannel('unknown_controls');
    channel.onmessage = (ev) => {
        const { type, payload } = ev.data;
        if (type === 'stateUpdate') {
            UI.setState(payload);
        } else if (type === 'updatePresetList') {
            UI.populatePresetList(payload);
        }
    };
    UI.init(defs, gDefs, channel);

  })();
  </script>

</body>
</html>
