<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Controls</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0a0a0a;--fg:#eaeaea;--muted:#9a9a9a;--accent:#fff;--border:#2a2a2a;
      --ok:#33d17a;--warn:#f6c945;--err:#ff6464;
    }
    html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--fg);font-family:'JetBrains Mono',monospace}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .card{background:#0e0e0e;border:1px solid var(--border);border-radius:12px;padding:12px}
    .btn{background:#111;border:1px solid #333;color:var(--fg);border-radius:8px;padding:6px 10px;cursor:pointer}
    .btn:hover{background:#1b1b1b}
    .small{font-size:12px;color:var(--muted)}
    .status{padding:6px 10px;border-radius:8px;background:#111;border:1px solid #333}
    input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:2px;background:#333}
    input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#fff;border-radius:50%;cursor:pointer}
  </style>

  <!-- ffmpeg.wasm loader for WebM->MP4 conversion -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>
  <script>
    /* Ensure WebM -> MP4 conversion on host before sending to phone */
    async function transcodeToMp4IfNeeded(inputBlob, onProgress) {
      try {
        if (inputBlob && inputBlob.type && inputBlob.type.includes('mp4')) {
          if (onProgress) onProgress(100);
          return inputBlob;
        }
        if (typeof FFmpeg === 'undefined') throw new Error('FFmpeg.wasm not loaded');

        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({
          log: true,
          corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js'
        });

        if (onProgress) {
          ffmpeg.setProgress(({ ratio }) => {
            const pct = Math.max(0, Math.min(100, Math.round((ratio || 0) * 100)));
            onProgress(pct);
          });
        }

        await ffmpeg.load();
        ffmpeg.FS('writeFile', 'in.webm', await fetchFile(inputBlob));
        await ffmpeg.run(
          '-i', 'in.webm',
          '-c:v', 'libx264',
          '-preset', 'veryfast',
          '-pix_fmt', 'yuv420p',
          '-movflags', '+faststart',
          'out.mp4'
        );
        const out = ffmpeg.FS('readFile', 'out.mp4');
        const mp4Blob = new Blob([out.buffer], { type: 'video/mp4' });
        if (onProgress) onProgress(100);
        return mp4Blob;
      } catch (err) {
        console.error('Transcode failed; returning original blob', err);
        return inputBlob; // fall back rather than failing the session
      }
    }
  </script>
</head>
<body>
  <div class="wrap">
    <h1>U N K N O W N // Controls</h1>

    <div class="row">
      <div class="card" style="flex:1 1 320px">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <button id="remoteShowQR" class="btn">Show Pair QR</button>
          <button id="remoteReset" class="btn">Reset</button>
          <span id="remoteStatus" class="status">REMOTE: idle</span>
        </div>

        <div class="small">
          Open this on desktop (host). Use QR to connect your phone page to receive recordings.
        </div>
      </div>

      <div class="card" style="flex:1 1 300px">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <button id="startBtn" class="btn">Start Recording</button>
          <button id="stopBtn" class="btn">Stop</button>
          <span id="status" class="status">idle</span>
        </div>
        <div class="small">Host records the preview and sends the video to the phone after conversion to MP4.</div>
      </div>
    </div>

    <!-- (Your existing effect/UI controls would remain here; omitted for brevity) -->
  </div>

  <script>
  (() => {
    // ---- UI (minimal skeleton; keep your existing UI here) ----
    const UI = {
      elements: {}, state: { checkboxes: { logoChk:true } },
      init() {
        this.elements.remoteShowQR = document.getElementById('remoteShowQR');
        this.elements.remoteReset = document.getElementById('remoteReset');
        this.elements.remoteStatus = document.getElementById('remoteStatus');
        this.elements.startBtn = document.getElementById('startBtn');
        this.elements.stopBtn = document.getElementById('stopBtn');
        this.elements.status = document.getElementById('status');
      }
    };

    // ---- Remote / pairing / data channel (simplified â€” keep your implementation) ----
    const Remote = {
      armed:false, isRecording:false, activeConnection:null,
      init(){
        document.getElementById('remoteShowQR').addEventListener('click', async ()=>{
          if(!this.armed) await this.arm();
          this.openQRWindow();
        });
        document.getElementById('remoteReset').addEventListener('click', ()=> this.disarm());
      },
      async arm(){
        this.armed = true;
        this.updateStatus();
        // (pairing/peer setup goes here in your project)
      },
      disarm(){ this.armed=false; this.activeConnection=null; this.updateStatus(); },
      openQRWindow(){ window.open('remote-qr.html','_blank','width=480,height=600'); },
      updateStatus(){
        const el=document.getElementById('remoteStatus');
        el.textContent = this.isRecording ? 'REMOTE: recordingâ€¦' : (this.armed ? 'REMOTE: armed' : 'REMOTE: idle');
      },

      // ðŸ”´ REPLACED: always send MP4 to the phone
      async handleRecordingBlob(blob) {
        const conn = this.activeConnection;
        if (!conn) { this.isRecording = false; this.updateStatus(); return; }

        const setStatus = (p) => {
          const el = document.getElementById('remoteStatus');
          if (el && typeof p === 'number') el.textContent = `REMOTE: transcoding ${p}%`;
        };

        const mp4Blob = await transcodeToMp4IfNeeded(blob, setStatus);

        const mime = 'video/mp4';
        const arrayBuf = await mp4Blob.arrayBuffer();
        const total = arrayBuf.byteLength;
        const filename = `unknown_${Date.now()}.mp4`;

        conn.send(JSON.stringify({ type:'recordingMeta', mime, totalBytes: total, filename }));
        const CHUNK = 64 * 1024; let sent = 0; const channel = conn.dataChannel;
        while (sent < total) {
          if (channel && channel.bufferedAmount > 1024 * 1024) {
            await new Promise(r => { channel.onbufferedamountlow = r; });
          }
          const end = Math.min(total, sent + CHUNK);
          conn.send(arrayBuf.slice(sent, end));
          sent = end;
        }
        conn.send(JSON.stringify({ type:'recordingEnd' }));
        this.isRecording = false; this.activeConnection = null; this.updateStatus();
      },

      handleRecordingError(message) {
        try { this.activeConnection?.send(JSON.stringify({ type: 'error', message })); } catch {}
        this.isRecording = false; this.activeConnection = null; this.updateStatus();
      }
    };

    // ---- App glue ----
    const App = {
      channel: null,
      init(){
        UI.init();
        Remote.init();

        this.channel = new BroadcastChannel('unknown_signal');
        this.channel.onmessage = (event) => this.handleMessage(event.data);

        document.getElementById('startBtn').addEventListener('click', ()=>{
          document.getElementById('status').textContent='recordingâ€¦';
          Remote.isRecording=true; Remote.updateStatus();
          this.channel.postMessage({ type:'record_start' });
        });
        document.getElementById('stopBtn').addEventListener('click', ()=>{
          document.getElementById('status').textContent='stoppingâ€¦';
          this.channel.postMessage({ type:'record_stop' });
        });
      },

      handleMessage(data){
        if (data.type === 'recording_complete') {
          Remote.handleRecordingBlob(data.payload.blob);
          document.getElementById('status').textContent='sending to phoneâ€¦';
        } else if (data.type === 'recording_error') {
          Remote.handleRecordingError(data.payload.message);
          document.getElementById('status').textContent='error';
        } else if (data.type === 'record_stop_ack') {
          document.getElementById('status').textContent='stopped';
          Remote.isRecording=false; Remote.updateStatus();
        }
      }
    };

    window.addEventListener('load', ()=> App.init());
  })();
  </script>
</body>
</html>
