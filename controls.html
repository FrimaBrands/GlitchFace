<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Controls</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* Base styles for the mysterious, glitchy theme */
    body { 
        font-family: 'JetBrains Mono', monospace; 
        background-color: #0a0a0a;
        color: #EAEAEA;
    }
    .container {
        max-width: 420px;
        margin: 0 auto;
    }
    /* Custom scrollbar for a more integrated look */
    .custom-scrollbar::-webkit-scrollbar { width: 4px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #666; }

    /* Custom range input styles */
    input[type="range"] {
        -webkit-appearance: none; appearance: none;
        width: 100%; height: 2px;
        background: #333;
        outline: none;
        transition: background .3s;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        width: 14px; height: 14px;
        background: #EAEAEA;
        cursor: pointer;
        border: none;
        border-radius: 0;
    }
    input[type="range"]::-moz-range-thumb {
        width: 14px; height: 14px;
        background: #EAEAEA;
        cursor: pointer;
        border: none;
        border-radius: 0;
    }

    /* Status indicator animation for a glitchy feel */
    .status-indicator::after {
        content: '■';
        display: inline-block;
        margin-left: 6px;
        animation: blink 0.7s step-end infinite;
        color: #00ff00;
    }
    @keyframes blink { 
        0%, 100% { opacity: 1; }
        50% { opacity: 0; } 
    }
    .status-indicator.error::after {
        color: #ff0000;
    }

    /* Tab button styling */
    .tab-button {
        border-color: #333;
        transition: all 0.2s ease-in-out;
    }
    .tab-button.active {
        border-color: #EAEAEA;
        color: #FFFFFF;
        background-color: #1a1a1a;
    }
    
    /* General button styling */
    .btn {
        border: 1px solid #555;
        transition: all 0.2s ease-in-out;
    }
    .btn:hover {
        background-color: #EAEAEA;
        color: #000;
        border-color: #EAEAEA;
    }
    .btn:disabled {
        opacity: 0.4;
        pointer-events: none;
    }
    .btn-primary {
        background-color: #EAEAEA;
        color: #000;
        border-color: #EAEAEA;
    }
    .btn-primary:hover {
        background-color: #000;
        color: #EAEAEA;
    }

    /* Custom checkbox styling */
    .form-checkbox {
        appearance: none;
        -webkit-appearance: none;
        height: 14px;
        width: 14px;
        background-color: transparent;
        border: 1px solid #555;
        cursor: pointer;
        display: inline-block;
        position: relative;
    }
    .form-checkbox:checked {
        background-color: #EAEAEA;
    }
  </style>
</head>
<body class="p-2">

  <div class="controls-panel w-full h-[calc(100vh-1rem)] bg-[#0a0a0a] border border-gray-800 flex flex-col">
    
    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h1 class="text-xl font-bold text-white tracking-widest">U N K N O W N</h1>
      <p class="text-sm text-gray-400 font-mono">// SIGNAL PROCESSOR</p>
       <div id="statusBar" class="font-mono text-xs text-green-400 mt-3 status-indicator">
        STATUS: STANDBY
      </div>
      <div class="flex space-x-2 mt-2">
        <button id="startBtn" class="flex-1 btn btn-primary font-bold py-2 px-4">Initialize</button>
        <button id="stopBtn" class="flex-1 btn font-bold py-2 px-4" disabled>Terminate</button>
      </div>
      <div id="msg" class="text-red-400 font-mono text-xs mt-2 h-4"></div>
    </div>

    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h2 class="font-bold text-gray-300 mb-2">// PRESET_MANAGER</h2>
      <select id="presetList" class="w-full bg-black border border-gray-700 p-2 mb-2 text-sm focus:outline-none focus:border-gray-400"></select>
      <div class="grid grid-cols-3 gap-2">
        <input type="text" id="presetName" placeholder="> Preset Name..." class="col-span-3 bg-black border border-gray-700 p-2 text-sm focus:outline-none focus:border-gray-400">
        <button id="savePresetBtn" class="btn font-semibold py-1 text-sm">Save</button>
        <button id="deletePresetBtn" class="btn font-semibold py-1 text-sm">Delete</button>
        <button id="randomBtn" class="btn font-semibold py-1 text-sm">Randomize</button>
      </div>
    </div>
    
    <div class="flex border-b border-gray-800 flex-shrink-0">
      <button id="globalsTabBtn" class="tab-button active flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 text-gray-400 hover:text-white">Globals</button>
      <button id="effectsTabBtn" class="tab-button flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 border-transparent text-gray-400 hover:text-white">Effects</button>
    </div>

    <div class="flex-grow custom-scrollbar overflow-y-auto">
      <div id="effects-tab-content" class="hidden p-4 space-y-4">
        </div>
      <div id="globals-tab-content" class="p-4 space-y-4">
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// REMOTE_TRIGGER</h3>
          <p class="text-xs text-gray-500 mb-3">Enable guest phone to trigger a 5s capture.</p>
          <div class="space-y-3">
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">ARM REMOTE</span>
              <input type="checkbox" id="remoteEnable" class="form-checkbox">
            </label>
            <div class="grid grid-cols-2 gap-2">
              <button id="remoteShowQR" class="btn font-semibold py-2 text-sm" disabled>Open QR</button>
              <button id="remoteReset" class="btn font-semibold py-2 text-sm" disabled>Reset</button>
            </div>
            <div id="remoteStatus" class="text-xs font-mono text-green-400">REMOTE: idle</div>
          </div>
        </div>

        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// BACKGROUND_SOURCE</h3>
          <div class="space-y-3">
              <button id="bgUploadBtn" class="w-full btn font-semibold py-2 text-sm">Upload Image/Video</button>
              <input type="file" id="bgUpload" accept="image/*,video/*" class="hidden">
              <label class="flex items-center justify-between text-sm cursor-pointer">
                  <span class="text-gray-400">USE CUSTOM BG</span>
                  <input type="checkbox" id="useBgChk" class="form-checkbox" disabled>
              </label>
              <div class="control-item space-y-2">
                  <div class="flex justify-between items-center">
                      <label for="maskFeather" class="text-sm font-medium text-gray-300">MASK FEATHER</label>
                      <span id="maskFeatherValue" class="text-sm font-mono text-gray-400">0.150</span>
                  </div>
                  <input type="range" id="maskFeather" min="0.01" max="0.5" step="0.001" value="0.15">
              </div>
          </div>
        </div>
        
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// SYSTEM_SETTINGS</h3>
          <div class="space-y-3">
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">ANIMATE EFFECTS</span>
              <input type="checkbox" id="animateChk" class="form-checkbox" checked>
            </label>
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">MIRROR CAMERA</span>
              <input type="checkbox" id="mirrorChk" class="form-checkbox" checked>
            </label>
          </div>
        </div>
        
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// AUTOMATION_MODULE</h3>
          <div class="control-item space-y-2">
            <div class="flex justify-between items-center">
              <label for="autoRandomizeSlider" class="text-sm font-medium text-gray-300">AUTO-RANDOMIZE</label>
              <span id="autoRandomizeValue" class="text-sm font-mono text-gray-400">Off</span>
            </div>
            <input type="range" id="autoRandomizeSlider" min="0" max="30" step="0.5" value="0">
          </div>
          <div class="control-item space-y-2 mt-3">
            <div class="flex justify-between items-center">
              <label for="presetIterationSlider" class="text-sm font-medium text-gray-300">PRESET-ITERATION</label>
              <span id="presetIterationValue" class="text-sm font-mono text-gray-400">Off</span>
            </div>
            <input type="range" id="presetIterationSlider" min="0" max="30" step="0.5" value="0">
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
    // --- APP ARCHITECTURE ---
    // This is the CONTROL window. Its job is to manage the UI, handle presets,
    // and send all state changes to the PREVIEW window via a BroadcastChannel.
    // It does not handle any WebGL or camera logic itself.

    const channel = new BroadcastChannel('unknown_signal_channel');

    const UI = {
        elements: {},
        state: { ui: {}, jitter: {} },
        globalState: { ui: {} },
        definitions: {},
        globalDefinitions: {},

        init(definitions, globalDefinitions) {
            this.definitions = definitions;
            this.globalDefinitions = globalDefinitions;
            const ids = ['startBtn', 'stopBtn', 'statusBar', 'msg', 'savePresetBtn', 'deletePresetBtn', 'presetName', 'presetList', 'randomBtn', 'animateChk', 'mirrorChk', 'bgUploadBtn', 'bgUpload', 'useBgChk', 'maskFeather', 'maskFeatherValue', 'effectsTabBtn', 'globalsTabBtn', 'effects-tab-content', 'globals-tab-content', 'autoRandomizeSlider', 'autoRandomizeValue', 'presetIterationSlider', 'presetIterationValue', 'remoteEnable', 'remoteShowQR', 'remoteReset', 'remoteStatus'];
            ids.forEach(id => this.elements[id] = document.getElementById(id));

            for (const [key, definition] of Object.entries(this.definitions)) {
                this.createControlGroup(key, definition, this.state, this.elements['effects-tab-content'], true);
            }
            for (const [key, definition] of Object.entries(this.globalDefinitions)) {
                this.createControlGroup(key, definition, this.globalState, this.elements['globals-tab-content'], false);
            }

            // --- Event Listeners ---
            document.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', () => this.broadcastState());
                input.addEventListener('change', () => this.broadcastState());
            });
            this.elements.effectsTabBtn.addEventListener('click', () => this.switchTab('effects'));
            this.elements.globalsTabBtn.addEventListener('click', () => this.switchTab('globals'));

             // Background controls
            this.elements.bgUploadBtn.addEventListener('click', () => this.elements.bgUpload.click());
            this.elements.bgUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    channel.postMessage({
                        type: 'background_update',
                        payload: {
                            fileData: event.target.result,
                            fileName: file.name,
                            fileType: file.type
                        }
                    });
                    this.elements.useBgChk.disabled = false;
                    this.elements.useBgChk.checked = true;
                    this.broadcastState();
                    this.setMsg(`Background sent: ${file.name}`);
                };
                reader.readAsDataURL(file);
            });
        },

        broadcastState() {
            const state = PresetManager.getAppState();
            channel.postMessage({ type: 'state_update', payload: state });
        },

        switchTab(tabName) {
            if (tabName === 'effects') {
                this.elements.effectsTabBtn.classList.add('active');
                this.elements.globalsTabBtn.classList.remove('active');
                this.elements['effects-tab-content'].classList.remove('hidden');
                this.elements['globals-tab-content'].classList.add('hidden');
            } else {
                this.elements.effectsTabBtn.classList.remove('active');
                this.elements.globalsTabBtn.classList.add('active');
                this.elements['effects-tab-content'].classList.add('hidden');
                this.elements['globals-tab-content'].classList.remove('hidden');
            }
        },

        createControlGroup(key, definition, stateObject, parentElement, withToggle) {
          const group = document.createElement('div');
          group.className = 'control-group bg-black/50 border border-gray-800 p-3';
          const header = document.createElement('div');
          header.className = 'flex items-center justify-between';
          
          const title = document.createElement('h3');
          title.className = 'font-semibold text-gray-200';
          title.textContent = `// ${definition.title.toUpperCase()}`;
          header.appendChild(title);

          const content = document.createElement('div');
          content.className = 'mt-3 space-y-3';
          
          if (withToggle) {
              header.classList.add('cursor-pointer');
              const toggle = document.createElement('input');
              toggle.type = 'checkbox';
              toggle.checked = definition.active;
              toggle.className = 'form-checkbox';
              if (!definition.active) content.classList.add('hidden');
              
              toggle.addEventListener('change', () => {
                definition.active = toggle.checked;
              });
              header.addEventListener('click', (e) => {
                  if(e.target !== toggle) {
                      toggle.checked = !toggle.checked;
                      toggle.dispatchEvent(new Event('change'));
                  }
                  content.classList.toggle('hidden', !toggle.checked);
              });
              definition.toggleElement = toggle;
              header.appendChild(toggle);
          }

          stateObject.ui[key] = {};
          if (stateObject.jitter) stateObject.jitter[key] = {};

          for (const [controlKey, controlDef] of Object.entries(definition.controls)) {
            const slider = this.createSlider(controlKey, controlDef);
            content.appendChild(slider.container);
            stateObject.ui[key][controlKey] = slider.input;
          }
          group.append(header, content);
          parentElement.appendChild(group);
        },

        createSlider(id, def) {
            const container = document.createElement('div');
            container.className = 'control-item space-y-2';
            const labelContainer = document.createElement('div');
            labelContainer.className = 'flex justify-between items-center';
            const label = document.createElement('label');
            label.className = 'text-sm font-medium text-gray-300';
            label.textContent = def.label.toUpperCase();
            const valueSpan = document.createElement('span');
            valueSpan.className = 'text-sm font-mono text-gray-400';
            const input = document.createElement('input');
            input.type = 'range';
            Object.assign(input, { min: def.min, max: def.max, step: def.step, value: def.value });
            
            const updateValue = () => valueSpan.textContent = parseFloat(input.value).toFixed(String(def.step).includes('.') ? 3 : 0);
            input.addEventListener('input', updateValue);
            updateValue();
            
            labelContainer.append(label, valueSpan);
            container.append(labelContainer, input);
            return { container, input };
        },

        setStatus(text, isError = false) {
            this.elements.statusBar.textContent = `STATUS: ${text}`;
            this.elements.statusBar.classList.toggle('error', isError);
        },
        setMsg(text) { this.elements.msg.textContent = text; }
    };

    const PresetManager = {
        init() {
            this.populateList();
            UI.elements.savePresetBtn.addEventListener('click', () => this.save());
            UI.elements.deletePresetBtn.addEventListener('click', () => this.delete());
            UI.elements.presetList.addEventListener('change', () => this.load());
            UI.elements.randomBtn.addEventListener('click', () => this.randomize());
        },
        
        getPresets: () => JSON.parse(localStorage.getItem('bodyGlitchV5.0Presets') || '{}'),
        savePresets: (p) => localStorage.setItem('bodyGlitchV5.0Presets', JSON.stringify(p)),

        getAppState() {
            const state = { controls: {}, toggles: {}, checkboxes: {}, globalControls: {}, misc: {}, automation: {} };
            for (const [groupKey, group] of Object.entries(UI.state.ui)) {
              state.controls[groupKey] = {};
              state.toggles[groupKey] = UI.definitions[groupKey].active;
              for (const [controlKey, control] of Object.entries(group)) {
                state.controls[groupKey][controlKey] = control.value;
              }
            }
            for (const [groupKey, group] of Object.entries(UI.globalState.ui)) {
                state.globalControls[groupKey] = {};
                for (const [controlKey, control] of Object.entries(group)) {
                    state.globalControls[groupKey][controlKey] = control.value;
                }
            }
            state.checkboxes = { 
                animateChk: UI.elements.animateChk.checked, 
                mirrorChk: UI.elements.mirrorChk.checked,
                useBgChk: UI.elements.useBgChk.checked
            };
            state.misc = { maskFeather: UI.elements.maskFeather.value };
            state.automation = {
                autoRandomize: UI.elements.autoRandomizeSlider.value,
                presetIteration: UI.elements.presetIterationSlider.value,
            };
            return state;
        },

        setAppState(state) {
            if (!state) return;
            if (state.controls) {
              for (const [groupKey, group] of Object.entries(state.controls)) {
                if (UI.state.ui[groupKey]) {
                  for (const [controlKey, value] of Object.entries(group)) {
                    const el = UI.state.ui[groupKey][controlKey];
                    if (el) { el.value = value; el.dispatchEvent(new Event('input')); }
                  }
                }
              }
            }
            if (state.toggles) {
              for (const [groupKey, isChecked] of Object.entries(state.toggles)) {
                const def = UI.definitions[groupKey];
                if (def && def.toggleElement) {
                  def.toggleElement.checked = isChecked;
                  def.toggleElement.dispatchEvent(new Event('change'));
                }
              }
            }
            if (state.globalControls) {
                for (const [groupKey, group] of Object.entries(state.globalControls)) {
                    if (UI.globalState.ui[groupKey]) {
                        for (const [controlKey, value] of Object.entries(group)) {
                            const el = UI.globalState.ui[groupKey][controlKey];
                            if (el) { el.value = value; el.dispatchEvent(new Event('input')); }
                        }
                    }
                }
            }
            if (state.checkboxes) {
              UI.elements.animateChk.checked = state.checkboxes.animateChk ?? true;
              UI.elements.mirrorChk.checked  = state.checkboxes.mirrorChk ?? true;
              UI.elements.useBgChk.checked = state.checkboxes.useBgChk ?? false;
            }
            if (state.misc) {
                const featherSlider = UI.elements.maskFeather;
                if (featherSlider) {
                    featherSlider.value = state.misc.maskFeather ?? '0.15';
                    featherSlider.dispatchEvent(new Event('input'));
                }
            }
            if (state.automation) {
                UI.elements.autoRandomizeSlider.value = state.automation.autoRandomize ?? 0;
                UI.elements.presetIterationSlider.value = state.automation.presetIteration ?? 0;
                UI.elements.autoRandomizeSlider.dispatchEvent(new Event('input'));
                UI.elements.presetIterationSlider.dispatchEvent(new Event('input'));
            }
            UI.broadcastState(); // Broadcast the newly loaded state
        },

        populateList() {
            const presets = this.getPresets();
            const { presetList } = UI.elements;
            const currentVal = presetList.value;
            presetList.innerHTML = '<option value="">-- LOAD PRESET --</option>';
            for (const name in presets) {
              const opt = document.createElement('option');
              opt.value = name; opt.textContent = name; presetList.appendChild(opt);
            }
            presetList.value = currentVal;
        },

        save() {
            const { presetName } = UI.elements;
            const name = presetName.value.trim();
            if (!name) return UI.setMsg('Enter a preset name.');
            const presets = this.getPresets();
            presets[name] = this.getAppState();
            this.savePresets(presets);
            this.populateList();
            UI.elements.presetList.value = name;
            UI.setMsg(`Preset '${name}' saved.`);
        },

        delete() {
            const { presetList, presetName } = UI.elements;
            const name = presetList.value;
            if (!name) return UI.setMsg('Select a preset to delete.');
            const presets = this.getPresets();
            delete presets[name];
            this.savePresets(presets);
            this.populateList();
            presetName.value = '';
            UI.setMsg(`Preset '${name}' deleted.`);
        },

        load(name) {
            const { presetList, presetName } = UI.elements;
            const presetToLoad = name || presetList.value;
            if (!presetToLoad) return;
            const presets = this.getPresets();
            if (presets[presetToLoad]) {
              this.setAppState(presets[presetToLoad]);
              presetName.value = presetToLoad;
              presetList.value = presetToLoad;
              UI.setMsg(`Preset '${presetToLoad}' loaded.`);
            }
        },

        randomize() {
            for (const groupKey in UI.state.ui) {
              const def = UI.definitions[groupKey];
              if(def && def.toggleElement){
                def.toggleElement.checked = Math.random() > 0.3;
                def.toggleElement.dispatchEvent(new Event('change'));
              }
              for (const controlKey in UI.state.ui[groupKey]) {
                const el = UI.state.ui[groupKey][controlKey];
                const min = parseFloat(el.min), max = parseFloat(el.max), step = parseFloat(el.step);
                el.value = Math.round((min + Math.random() * (max - min)) / step) * step;
                el.dispatchEvent(new Event('input'));
              }
            }
            UI.broadcastState();
            UI.setMsg('Parameters randomized!');
        }
    };

    const RemoteTriggerUI = {
        peerId: null,
        sessionToken: null,
        
        init() {
            const els = UI.elements;
            els.remoteEnable.addEventListener('change', () => {
                channel.postMessage({ type: 'remote_command', payload: els.remoteEnable.checked ? 'arm' : 'disarm' });
            });
            els.remoteReset.addEventListener('click', () => {
                channel.postMessage({ type: 'remote_command', payload: 'reset' });
            });
            els.remoteShowQR.addEventListener('click', () => this.openQRWindow());

            channel.addEventListener('message', (ev) => {
                const { type, payload } = ev.data;
                if (type === 'remote_status') {
                    this.updateStatusUI(payload);
                }
            });
        },
        
        updateStatusUI(status) {
            const els = UI.elements;
            this.peerId = status.peerId;
            this.sessionToken = status.sessionToken;

            els.remoteShowQR.disabled = !status.armed || !status.peerId;
            els.remoteReset.disabled = !status.armed;

            let text = 'REMOTE: idle';
            const good = !status.error;
            if (status.armed) {
                if (status.isRecording) {
                    text = `REMOTE: RECORDING... (${status.connections} connected)`;
                } else if (status.connections > 0) {
                    text = `REMOTE: ${status.connections} phone(s) connected. Ready.`;
                } else if (status.peerId) {
                    text = `REMOTE: armed @ ${status.peerId.slice(0,6)}… waiting for connections`;
                } else {
                    text = 'REMOTE: arming...';
                }
            } else if (status.error) {
                text = `REMOTE ERROR: ${status.error}`;
            }

            els.remoteStatus.textContent = text;
            els.remoteStatus.classList.toggle('text-red-400', !good);
            els.remoteStatus.classList.toggle('text-green-400', good);
        },

        openQRWindow() {
            if (!this.peerId || !this.sessionToken) return;
            const PHONE_URL = 'phone.html';
            const QR_URL = 'remote-qr.html';
            const url = new URL(PHONE_URL, location.href);
            url.searchParams.set('host', this.peerId);
            url.searchParams.set('token', this.sessionToken);
            const qrUrl = new URL(QR_URL, location.href);
            qrUrl.searchParams.set('target', url.toString());
            window.open(qrUrl.toString(), 'unknown_qr', 'noopener,noreferrer,width=520,height=600');
        }
    };

    const App = {
      init(definitions, globalDefinitions) {
        UI.init(definitions, globalDefinitions);
        PresetManager.init();
        RemoteTriggerUI.init();
        
        UI.elements.startBtn.addEventListener('click', () => channel.postMessage({ type: 'command', payload: 'start' }));
        UI.elements.stopBtn.addEventListener('click', () => channel.postMessage({ type: 'command', payload: 'stop' }));

        channel.addEventListener('message', (ev) => {
            const { type, payload } = ev.data;
            if (type === 'app_status') {
                UI.setStatus(payload.status, payload.isError);
                UI.setMsg(payload.message || '');
                UI.elements.startBtn.disabled = payload.isRunning;
                UI.elements.stopBtn.disabled = !payload.isRunning;
            }
        });

        // Initialize with default state
        UI.broadcastState();
      }
    };
    
    // --- Entry Point ---
    const definitions = { Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.005, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } }, Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 30, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 10, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.2, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } }, Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } }, Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.1, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } }, Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.01, neutral: 0.0 } } }, Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.5, neutral: 0.0 } } } };
    const globalDefinitions = { Opacity: { title: 'Global Opacity', active: true, controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0, neutral: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1, neutral: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 } } }, Seep: { title: 'Effect Seep', active: true, controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 2.0, neutral: 0.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 20, neutral: 0.0 } } } };

    App.init(definitions, globalDefinitions);

})();
</script>

</body>
</html>
