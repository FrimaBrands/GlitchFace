<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unknown — Remote Host (QR Always On)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark; }
    body { background:#0b0d11; color:#e5e7eb; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .panel { position: fixed; top: 0; right: 0; width: 360px; height: 100vh; overflow:auto; background:#11141a; border-left:1px solid #1f2430; padding:16px; }
    #glwrap { position: absolute; inset: 0 360px 0 0; display:grid; place-items:center; }
    #glcanvas { width: 100%; height: 100%; background:black; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    button { background:#34d399; color:#0b0d11; font-weight:700; border:0; border-radius:10px; padding:10px 12px; }
    button.secondary { background:#1f2430; color:#e5e7eb; }
    .muted { color:#9aa0aa; }
    .tag { font-size: 12px; background:#1f2430; color:#e5e7eb; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="glwrap">
    <canvas id="glcanvas" width="1280" height="720"></canvas>
  </div>
  <aside class="panel">
    <h1 class="text-xl font-bold mb-3">Remote Control (QR Always On)</h1>
    <p class="muted mb-4">Visitors scan the QR &gt; tap “Start recording”. You stay armed indefinitely. One recording at a time; extra requests are queued.</p>
    <div class="space-y-3">
      <div class="row">
        <span>Armed</span>
        <label class="inline-flex items-center cursor-pointer">
          <input id="arm" type="checkbox" class="sr-only peer">
          <div class="w-10 h-6 bg-gray-600 rounded-full peer-checked:bg-emerald-500 relative after:content-[''] after:w-5 after:h-5 after:bg-white after:rounded-full after:absolute after:top-0.5 after:left:0.5 peer-checked:after:translate-x-4 after:transition"></div>
        </label>
      </div>
      <div class="row">
        <span>Open QR window</span>
        <button id="openQR" class="secondary">Open</button>
      </div>
      <div class="row"><span>Host ID</span><span id="hostId" class="mono tag">—</span></div>
      <div class="row"><span>Connected phones</span><span id="connCount" class="tag">0</span></div>
      <div class="row"><span>Queue length</span><span id="queueLen" class="tag">0</span></div>
      <div class="row"><span>Status</span><span id="status" class="mono">idle</span></div>
    </div>
    <hr class="my-4 border-gray-700">
    <p class="text-sm muted">Safety: records only the canvas on this page for 5 seconds. No mic/screen capture. Encrypted P2P transfer.</p>
  </aside>

  <script>
    const c = document.getElementById('glcanvas');
    const g = c.getContext('2d');
    let t=0;
    function tick(){
      t += 1/60;
      const w=c.width,h=c.height;
      g.fillStyle='black'; g.fillRect(0,0,w,h);
      for(let i=0;i<60;i++){
        const x = (w/2) + Math.sin(t*0.8+i)*w*0.4*Math.sin(t*0.3+i*0.1);
        const y = (h/2) + Math.cos(t*1.1+i)*h*0.3*Math.cos(t*0.25+i*0.13);
        const r = 10+8*Math.sin(t*2+i);
        g.fillStyle=`hsl(${(t*40+i*7)%360} 80% 60%)`;
        g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
      }
      requestAnimationFrame(tick);
    } tick();
  </script>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
  (function(){
    const els = {
      arm: document.getElementById('arm'),
      openQR: document.getElementById('openQR'),
      hostId: document.getElementById('hostId'),
      connCount: document.getElementById('connCount'),
      queueLen: document.getElementById('queueLen'),
      status: document.getElementById('status'),
      canvas: document.getElementById('glcanvas')
    };

    let peer=null;
    let connections = new Set();
    let queue = [];
    let isRecording = false;

    function setStatus(s){ els.status.textContent = s; }
    function updateCounts(){
      els.connCount.textContent = String(connections.size);
      els.queueLen.textContent = String(queue.length + (isRecording ? 1 : 0));
    }
    function randomId(){
      const a = new Uint8Array(6); crypto.getRandomValues(a);
      return 'unk-' + Array.from(a, b => b.toString(16).padStart(2,'0')).join('');
    }
    function getOrCreateHostId(){
      let id = localStorage.getItem('unknownHostId');
      if (!id) { id = randomId(); localStorage.setItem('unknownHostId', id); }
      return id;
    }

    async function arm(){
      if (peer) return;
      setStatus('arming…');
      let id = getOrCreateHostId();
      try {
        peer = new Peer(id, { debug: 1 });
      } catch(e) {
        id = randomId(); localStorage.setItem('unknownHostId', id);
        peer = new Peer(id, { debug: 1 });
      }
      els.hostId.textContent = id;

      peer.on('open', () => setStatus('armed ✔'));
      peer.on('error', (e) => {
        if (String(e).includes('unavailable-id')){
          const nid = randomId();
          localStorage.setItem('unknownHostId', nid);
          peer = new Peer(nid, { debug: 1 });
          els.hostId.textContent = nid;
        } else {
          setStatus('peer error'); console.error(e);
        }
      });
      peer.on('connection', (conn) => {
        connections.add(conn);
        updateCounts();
        conn.on('close', () => { connections.delete(conn); removeFromQueue(conn); updateCounts(); });
        conn.on('error', () => { connections.delete(conn); removeFromQueue(conn); updateCounts(); });
        conn.on('data', (msg) => onMessage(conn, msg));
        try { conn.send(JSON.stringify({ type:'helloAck', ok:true })); } catch {}
      });
    }
    function disarm(){
      if (peer){ try { peer.destroy(); } catch {} }
      peer=null; connections.clear(); queue=[]; isRecording=false;
      updateCounts(); setStatus('idle');
    }
    function removeFromQueue(conn){
      queue = queue.filter(q => q.conn !== conn);
    }

    async function recordCanvasFiveSeconds(preferMp4=false){
      const canvas = els.canvas;
      const stream = canvas.captureStream(30);
      const chunks = [];
      const opts = [];
      if (preferMp4) opts.push({mimeType:'video/mp4;codecs=h264', videoBitsPerSecond: 2000000});
      opts.push({mimeType:'video/webm;codecs=vp9', videoBitsPerSecond: 2000000});
      opts.push({mimeType:'video/webm;codecs=vp8', videoBitsPerSecond: 2000000});
      opts.push({mimeType:'video/webm', videoBitsPerSecond: 2000000});
      let rec=null, mime='video/webm';
      for (const o of opts){ try { rec = new MediaRecorder(stream, o); mime=rec.mimeType; break; } catch{} }
      if (!rec) throw new Error('MediaRecorder not available');
      await new Promise(r => setTimeout(r, 50));
      return await new Promise((resolve, reject) => {
        let stopped=false;
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
        rec.onerror = e => { if (!stopped) reject(e.error || e); };
        rec.onstop = () => {
          stopped=true;
          try { stream.getTracks().forEach(t=>t.stop()); } catch {}
          resolve({ blob: new Blob(chunks, {type:mime}), mime });
        };
        rec.start();
        setTimeout(() => { try { rec.stop(); } catch{} }, 5000);
      });
    }

    async function handleOne(conn, preferMp4){
      isRecording = true; updateCounts();
      setStatus('recording for a phone…');
      let recording;
      try {
        recording = await recordCanvasFiveSeconds(preferMp4);
      } catch(e){
        try { conn.send(JSON.stringify({ type:'error', message: String(e) })); } catch {}
        isRecording = false; updateCounts(); setStatus('ready');
        return;
      }
      const { blob, mime } = recording;
      const buffer = await blob.arrayBuffer();
      const total = buffer.byteLength;
      const filename = `unknown_${Date.now()}.${mime.includes('mp4')?'mp4':'webm'}`;

      try { conn.send(JSON.stringify({ type:'recordingMeta', mime, totalBytes: total, filename })); } catch {}
      const CHUNK = 64*1024;
      const channel = conn._dc || conn._channel || null;
      const threshold = 1*1024*1024;
      for (let i=0;i<total;i+=CHUNK){
        const end = Math.min(total, i+CHUNK);
        const chunk = buffer.slice(i,end);
        if (channel && channel.bufferedAmount > threshold){
          await new Promise(r => {
            const h = () => {
              if (channel.bufferedAmount <= threshold/2){
                channel.removeEventListener('bufferedamountlow', h);
                r();
              }
            };
            channel.addEventListener('bufferedamountlow', h);
          });
        }
        conn.send(chunk);
        if (i % (CHUNK*32) === 0){
          try { conn.send(JSON.stringify({ type:'progress', sent: end })); } catch {}
        }
      }
      try { conn.send(JSON.stringify({ type:'recordingEnd' })); } catch {}
      try { conn.close(); } catch {}
      isRecording = false; updateCounts();
      setStatus('ready');
      const next = queue.shift();
      if (next) handleOne(next.conn, next.preferMp4);
    }

    async function onMessage(conn, msg){
      let data = msg;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch {}
      }
      if (!data || typeof data !== 'object') return;

      if (data.type === 'hello'){
        try { conn.send(JSON.stringify({ type:'helloAck', ok:true })); } catch {}
        return;
      }
      if (data.type === 'startRecording'){
        if (isRecording || queue.length){
          if (!queue.find(q => q.conn===conn)){
            queue.push({ conn, preferMp4: !data.supportsWebM });
            try { conn.send(JSON.stringify({ type:'queued', position: queue.length })); } catch {}
            updateCounts();
          }
          return;
        } else {
          handleOne(conn, !data.supportsWebM);
          return;
        }
      }
    }

    els.arm.addEventListener('change', () => {
      if (els.arm.checked) arm(); else disarm();
    });
    els.openQR.addEventListener('click', () => {
      if (!peer) { setStatus('arm first'); return; }
      const url = new URL('remote-visitor.html', location.href);
      url.searchParams.set('host', peer.id);
      const qr = new URL('remote-qr.html', location.href);
      qr.searchParams.set('target', url.toString());
      window.open(qr.toString(), '_blank', 'noopener,noreferrer,width=520,height=600');
    });

    els.arm.checked = true; arm();
    setStatus('loading…');
  })();
  </script>
</body>
</html>
