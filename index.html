<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face Glitch V3 - UNKNOWN</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent-primary: #00ff99;
            --accent-secondary: #ff00ff;
            --border-color: #3a3a3a;
            --danger-color: #ff3b30;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }

        /* Custom Slider Styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            outline: none;
            border-radius: 2px;
            transition: background 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
            transition: transform 0.2s ease;
        }
        
        input[type="range"]:hover::-webkit-slider-thumb {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
        }
        
        /* Custom Checkbox */
        .custom-checkbox {
            -webkit-appearance: none;
            appearance: none;
            background-color: var(--bg-tertiary);
            width: 20px;
            height: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .custom-checkbox:checked {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .custom-checkbox:checked::after {
            content: 'âœ“';
            font-size: 14px;
            color: var(--bg-primary);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Pulsing animation for status indicator */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .pulse-live {
            animation: pulse 2s infinite;
        }

    </style>
</head>
<body class="overflow-hidden">

    <div id="app-container" class="flex h-screen w-screen bg-bg-primary">
        
        <!-- Main Stage: Where the visual output is rendered -->
        <div id="main-stage" class="flex-grow h-screen relative bg-black flex items-center justify-center">
            <video id="video-source" class="hidden" playsinline muted></video>
            <canvas id="gl-canvas" class="w-full h-full object-contain"></canvas>
            <div id="loading-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center text-center p-8 z-20">
                <h1 class="text-4xl font-bold mb-2 font-mono">UNKNOWN</h1>
                <p class="text-lg text-text-secondary mb-8">Interactive Glitch Installation</p>
                <button id="start-button" class="px-8 py-3 bg-accent-primary text-bg-primary font-bold rounded-lg text-xl hover:bg-white transition-all duration-300 transform hover:scale-105">Initialize Camera</button>
                <p id="error-message" class="mt-6 text-danger-color font-mono"></p>
                <div id="loading-spinner" class="hidden mt-4 border-4 border-t-4 border-gray-200 border-t-accent-primary rounded-full w-12 h-12 animate-spin"></div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div id="controls-panel" class="w-[450px] h-screen bg-bg-secondary flex flex-col border-l border-border-color shrink-0">
            <div class="p-4 border-b border-border-color flex justify-between items-center">
                <h1 class="text-xl font-bold font-mono">CONTROLS</h1>
                <div class="flex items-center space-x-3">
                    <span id="status-indicator" class="w-3 h-3 bg-danger-color rounded-full"></span>
                    <span id="status-text" class="text-sm text-text-secondary font-mono">OFFLINE</span>
                </div>
            </div>

            <!-- Tabs for Admin/Visitor modes -->
            <div class="flex border-b border-border-color">
                <button id="admin-view-btn" class="flex-1 p-3 text-center font-semibold bg-bg-tertiary border-r border-border-color">Admin</button>
                <button id="visitor-view-btn" class="flex-1 p-3 text-center font-semibold text-text-secondary">Visitor</button>
            </div>

            <!-- Container for different views -->
            <div class="flex-grow overflow-y-auto p-4">
                
                <!-- ADMIN VIEW -->
                <div id="admin-view">
                    <!-- Presets Section -->
                    <div class="bg-bg-tertiary rounded-lg p-4">
                        <h2 class="font-bold mb-3 text-lg font-mono">PRESETS</h2>
                        <div class="space-y-3">
                            <select id="preset-list" class="w-full p-2 bg-bg-primary border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary"></select>
                            <input type="text" id="preset-name" placeholder="New Preset Name..." class="w-full p-2 bg-bg-primary border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
                            <div class="grid grid-cols-2 gap-3">
                                <button id="save-preset-btn" class="w-full p-2 bg-accent-primary text-bg-primary font-bold rounded-md hover:bg-white transition-colors">Save</button>
                                <button id="delete-preset-btn" class="w-full p-2 bg-danger-color text-white font-bold rounded-md hover:bg-red-400 transition-colors">Delete</button>
                            </div>
                        </div>
                    </div>

                    <!-- Effects Section -->
                    <div class="bg-bg-tertiary rounded-lg p-4 mt-6">
                        <h2 class="font-bold mb-3 text-lg font-mono">ACTIVE EFFECTS</h2>
                        <div id="effect-toggles" class="grid grid-cols-2 gap-2">
                            <!-- Effect toggles will be generated here by JS -->
                        </div>
                    </div>
                    
                    <!-- Controls Container -->
                    <div id="effects-controls-container" class="space-y-4 mt-6">
                        <!-- Effect controls will be generated here -->
                    </div>
                </div>

                <!-- VISITOR VIEW -->
                <div id="visitor-view" class="hidden">
                     <div class="bg-bg-tertiary rounded-lg p-4">
                        <h2 class="font-bold mb-3 text-lg font-mono">CHOOSE A STYLE</h2>
                        <select id="visitor-preset-list" class="w-full p-3 bg-bg-primary border border-border-color rounded-md text-lg focus:outline-none focus:ring-2 focus:ring-accent-primary"></select>
                    </div>
                    <div id="visitor-controls-container" class="space-y-6 mt-6">
                        <!-- Simplified visitor controls will be generated here -->
                    </div>
                    <div class="mt-6">
                         <button id="randomize-btn" class="w-full p-4 bg-accent-secondary text-white font-bold rounded-md text-xl hover:bg-fuchsia-500 transition-colors duration-300 transform hover:scale-105">RANDOMIZE</button>
                    </div>
                </div>

            </div>

            <div class="p-4 border-t border-border-color text-center">
                <p class="text-xs text-text-secondary font-mono">UNKNOWN v3.1</p>
            </div>
        </div>
    </div>

    <!-- ES6 Module Scripts -->
    <script type="module" src="./main.js"></script>

</body>
</html>
```javascript
// main.js

// This is the main entry point of the application.
// It orchestrates the setup of UI, WebGL, and Face Tracking.

import { initUI, updateUIState, showErrorMessage, hideLoadingOverlay, setStatus, setFullState, populateInitialControls } from './ui.js';
import { GlitchEngine } from './webgl.js';
import { initFaceLandmarker, detectFaces } from './face.js';

// --- Global State ---
let glitchEngine = null;
let faceLandmarker = null;
let videoElement = null;
let lastVideoTime = -1;
let animationFrameId = null;
let isRunning = false;

// --- Core Application Logic ---

/**
 * The main animation loop. Called every frame.
 */
async function renderLoop() {
    if (!isRunning) return;

    // Get the current video frame
    if (videoElement.currentTime !== lastVideoTime) {
        lastVideoTime = videoElement.currentTime;

        // Detect faces in the current frame
        const faceResults = await detectFaces(faceLandmarker, videoElement);
        
        // Update the WebGL engine with the new video frame and face data
        if (glitchEngine) {
            glitchEngine.update(videoElement, faceResults);
            glitchEngine.render();
        }

        // Update UI elements with status
        const faceDetected = faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0;
        setStatus(faceDetected ? 'FACE DETECTED' : 'SEARCHING...', faceDetected);
    }
    
    animationFrameId = requestAnimationFrame(renderLoop);
}

/**
 * Initializes and starts the camera stream.
 */
async function startCamera() {
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('Camera access is not supported by this browser.');
        }
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720, facingMode: 'user' }
        });
        videoElement.srcObject = stream;
        await new Promise(resolve => {
            videoElement.onloadedmetadata = () => resolve();
        });
        await videoElement.play();
    } catch (err) {
        console.error("Camera Error:", err);
        let message = `Failed to access camera: ${err.message}.`;
        if (err.name === 'NotAllowedError') {
            message = 'Camera permission was denied. Please allow camera access in your browser settings.';
        }
        if(!isSecureContext){
            message = 'Camera access requires a secure connection (HTTPS).';
        }
        showErrorMessage(message);
        throw err; // Propagate error to stop initialization
    }
}

/**
 * Main initialization function.
 */
async function main() {
    // 1. Initialize UI components and get references
    // Pass the state management functions to the UI module.
    const { canvas, video, startButton } = initUI(getAppState, setAppState);
    videoElement = video;
    glitchEngine = new GlitchEngine(canvas);

    // After the glitch engine is created, its default state is known.
    // We can now populate the UI with the initial controls.
    populateInitialControls(getAppState());

    // 2. Setup event listener for the start button
    startButton.addEventListener('click', async () => {
        try {
            updateUIState({ isLoading: true, errorMessage: '' });
            
            // 3. Initialize Face Landmarker (heavy operation)
            setStatus('Loading AI Model...');
            faceLandmarker = await initFaceLandmarker();

            // 4. Start the camera
            setStatus('Initializing Camera...');
            await startCamera();

            // 5. Initialize WebGL Engine with video dimensions
            glitchEngine.setup(videoElement.videoWidth, videoElement.videoHeight);

            // 6. Hide loading overlay and start the main loop
            hideLoadingOverlay();
            isRunning = true;
            renderLoop();

        } catch (error) {
            // Error handling is managed within the functions
            updateUIState({ isLoading: false });
            setStatus('ERROR', false);
        }
    });
}

// --- State Management Bridge between UI and WebGL ---

/**
 * Gets the entire current state from the Glitch Engine.
 * This is passed to the UI module so it can read the state.
 * @returns {object} The current application state.
 */
function getAppState() {
    if (!glitchEngine) return { activeEffects: [], uniforms: {}, effects: [] };
    const { uniforms, effects } = glitchEngine.getUniformDefinitions();
    return {
        activeEffects: glitchEngine.getActiveEffects(),
        uniforms: uniforms,
        effects: effects
    };
}

/**
 * Updates the Glitch Engine's state from the UI.
 * This is passed to the UI module so it can write to the state.
 * @param {object} newState - The new state to apply.
 */
function setAppState(newState) {
    if (!glitchEngine) return;

    // Update the engine's state
    if (newState.activeEffects) {
        glitchEngine.setActiveEffects(newState.activeEffects);
    }
    if (newState.uniforms) {
        glitchEngine.updateUniforms(newState.uniforms);
    }

    // Also update the UI to reflect any changes (e.g., loading a preset)
    setFullState(newState);
}


// --- Start the application ---
main();
```javascript
// ui.js

// This module handles all DOM interactions, event listeners,
// and UI state management (like switching views, updating sliders, etc.).

// --- State ---
let getAppStateCallback = () => {};
let setAppStateCallback = () => {};
let currentView = 'admin'; // 'admin' or 'visitor'
const PRESET_STORAGE_KEY = 'faceGlitchV3Presets';

// --- DOM Elements ---
let elements = {};

// --- Helper Functions ---
const getEl = (id) => document.getElementById(id);

/**
 * Creates a slider control component.
 * @param {object} uniform - The uniform object from the effects definition.
 * @param {string} effectName - The name of the effect this uniform belongs to.
 * @returns {HTMLElement} The control group element.
 */
function createSlider(uniform, effectName) {
    const id = `slider-${effectName}-${uniform.name}`;
    const controlEl = document.createElement('div');
    controlEl.className = 'space-y-2';

    const labelContainer = document.createElement('div');
    labelContainer.className = 'flex justify-between items-center text-sm';
    
    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = uniform.label;
    label.className = 'font-semibold text-text-secondary';
    
    const valueSpan = document.createElement('span');
    valueSpan.id = `${id}-value`;
    valueSpan.className = 'font-mono text-accent-primary';
    valueSpan.textContent = parseFloat(uniform.value).toFixed(uniform.step < 1 ? 2 : 0);

    labelContainer.append(label, valueSpan);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.id = id;
    slider.min = uniform.min;
    slider.max = uniform.max;
    slider.step = uniform.step;
    slider.value = uniform.value;
    slider.dataset.effect = effectName;
    slider.dataset.uniform = uniform.name;

    slider.addEventListener('input', (e) => {
        const newValue = parseFloat(e.target.value);
        valueSpan.textContent = newValue.toFixed(uniform.step < 1 ? 2 : 0);
        const uniformUpdate = {};
        uniformUpdate[uniform.name] = newValue;
        setAppStateCallback({ uniforms: uniformUpdate });
    });

    controlEl.append(labelContainer, slider);
    return controlEl;
}

/**
 * Creates and populates the controls for all defined effects for the Admin view.
 */
function populateAdminControls() {
    const { uniforms: allUniforms, effects } = getAppStateCallback();
    const container = elements.effectsControlsContainer;
    container.innerHTML = ''; // Clear existing controls

    effects.forEach(effect => {
        const effectUniforms = effect.uniforms.map(uname => allUniforms[uname]);

        if (effectUniforms.length > 0) {
            const group = document.createElement('div');
            group.className = 'bg-bg-tertiary rounded-lg p-4 space-y-4';
            group.dataset.effectControlGroup = effect.name;
            
            const header = document.createElement('h3');
            header.className = 'font-bold font-mono text-lg';
            header.textContent = effect.name;
            group.appendChild(header);

            effectUniforms.forEach(uniform => {
                group.appendChild(createSlider(uniform, effect.name));
            });
            container.appendChild(group);
        }
    });
}

/**
 * Creates the toggle buttons for activating/deactivating effects.
 */
function populateEffectToggles() {
    const { effects } = getAppStateCallback();
    const container = elements.effectToggles;
    container.innerHTML = '';

    effects.forEach(effect => {
        const button = document.createElement('button');
        button.className = 'p-2 rounded-md text-sm font-semibold transition-colors border';
        button.textContent = effect.label;
        button.dataset.effect = effect.name;

        button.addEventListener('click', () => {
            const { activeEffects } = getAppStateCallback();
            const wasActive = activeEffects.includes(effect.name);
            let newActiveEffects;
            if (wasActive) {
                newActiveEffects = activeEffects.filter(e => e !== effect.name);
            } else {
                newActiveEffects = [...activeEffects, effect.name];
            }
            setAppStateCallback({ activeEffects: newActiveEffects });
        });

        container.appendChild(button);
    });
    updateEffectToggleStyles();
}

/**
 * Updates the visual style of effect toggles based on the current state.
 */
function updateEffectToggleStyles() {
    const { activeEffects } = getAppStateCallback();
    document.querySelectorAll('#effect-toggles [data-effect]').forEach(el => {
        const effectName = el.dataset.effect;
        const isActive = activeEffects.includes(effectName);
        if (isActive) {
            el.classList.add('bg-accent-primary', 'text-bg-primary', 'border-accent-primary');
            el.classList.remove('bg-transparent', 'text-text-primary', 'border-border-color');
        } else {
            el.classList.remove('bg-accent-primary', 'text-bg-primary', 'border-accent-primary');
            el.classList.add('bg-transparent', 'text-text-primary', 'border-border-color');
        }
    });
}

/**
 * Switches the view between 'admin' and 'visitor'.
 */
function switchView(viewName) {
    currentView = viewName;
    if (viewName === 'admin') {
        elements.adminView.style.display = 'block';
        elements.visitorView.style.display = 'none';
        elements.adminViewBtn.classList.add('bg-bg-tertiary', 'text-text-primary');
        elements.adminViewBtn.classList.remove('text-text-secondary');
        elements.visitorViewBtn.classList.remove('bg-bg-tertiary', 'text-text-primary');
        elements.visitorViewBtn.classList.add('text-text-secondary');
    } else {
        elements.adminView.style.display = 'none';
        elements.visitorView.style.display = 'block';
        elements.visitorViewBtn.classList.add('bg-bg-tertiary', 'text-text-primary');
        elements.visitorViewBtn.classList.remove('text-text-secondary');
        elements.adminViewBtn.classList.remove('bg-bg-tertiary', 'text-text-primary');
        elements.adminViewBtn.classList.add('text-text-secondary');
    }
}

// --- Preset Management ---

function getPresets() {
    try {
        const presets = localStorage.getItem(PRESET_STORAGE_KEY);
        return presets ? JSON.parse(presets) : {};
    } catch (e) {
        console.error("Failed to parse presets from localStorage", e);
        return {};
    }
}

function savePresets(presets) {
    try {
        localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
    } catch (e) {
        console.error("Failed to save presets to localStorage", e);
    }
}

function populatePresetLists() {
    const presets = getPresets();
    const presetNames = Object.keys(presets);

    // Clear existing options
    elements.presetList.innerHTML = '<option value="">Load Preset...</option>';
    elements.visitorPresetList.innerHTML = '<option value="">Choose a Style...</option>';

    presetNames.forEach(name => {
        const optionAdmin = new Option(name, name);
        const optionVisitor = new Option(name, name);
        elements.presetList.add(optionAdmin);
        elements.visitorPresetList.add(optionVisitor);
    });
}

function saveCurrentPreset() {
    const name = elements.presetName.value.trim();
    if (!name) {
        alert("Please enter a name for the preset.");
        return;
    }
    const presets = getPresets();
    const { activeEffects, uniforms } = getAppStateCallback();
    
    // Only save the values, not the full uniform definitions
    const uniformValues = {};
    for(const key in uniforms) {
        uniformValues[key] = uniforms[key].value;
    }

    presets[name] = { activeEffects, uniforms: uniformValues };
    savePresets(presets);
    populatePresetLists();
    elements.presetList.value = name; // Select the newly saved preset
    alert(`Preset '${name}' saved!`);
}

function deleteSelectedPreset() {
    const name = elements.presetList.value;
    if (!name) {
        alert("Please select a preset to delete.");
        return;
    }
    if (confirm(`Are you sure you want to delete the preset '${name}'?`)) {
        const presets = getPresets();
        delete presets[name];
        savePresets(presets);
        populatePresetLists();
        elements.presetName.value = '';
        alert(`Preset '${name}' deleted.`);
    }
}

function loadSelectedPreset(selectElement) {
    const name = selectElement.value;
    if (!name) return;

    const presets = getPresets();
    const preset = presets[name];
    if (preset) {
        setAppStateCallback(preset);
        elements.presetName.value = name;
        // Make sure both dropdowns are in sync
        elements.presetList.value = name;
        elements.visitorPresetList.value = name;
    }
}

// --- Randomization ---

function randomizeState() {
    const { uniforms, effects } = getAppStateCallback();
    const newUniforms = {};
    
    // Randomize all sliders
    for (const key in uniforms) {
        const uniform = uniforms[key];
        if (uniform.min !== undefined) {
            const min = parseFloat(uniform.min);
            const max = parseFloat(uniform.max);
            newUniforms[key] = Math.random() * (max - min) + min;
        }
    }

    // Randomize active effects
    const newActiveEffects = effects
        .map(e => e.name)
        .filter(() => Math.random() > 0.5);
    
    // Ensure at least one effect is active
    if (newActiveEffects.length === 0) {
        newActiveEffects.push(effects[Math.floor(Math.random() * effects.length)].name);
    }

    setAppStateCallback({
        uniforms: newUniforms,
        activeEffects: newActiveEffects
    });
}

// --- Public Functions ---

/**
 * Sets the entire UI to match a given state object.
 * Used for loading presets or randomizing.
 * @param {object} state - The full state object { activeEffects, uniforms }.
 */
export function setFullState(state) {
    if (!state) return;
    
    // Update sliders
    if (state.uniforms) {
        for (const [name, value] of Object.entries(state.uniforms)) {
            const slider = document.querySelector(`input[data-uniform="${name}"]`);
            if (slider) {
                slider.value = value;
                // Update the text label next to the slider
                const valueSpan = getEl(`${slider.id}-value`);
                if (valueSpan) {
                    valueSpan.textContent = parseFloat(value).toFixed(slider.step < 1 ? 2 : 0);
                }
            }
        }
    }

    // Update active effect toggles
    if (state.activeEffects) {
        updateEffectToggleStyles();
    }
}

/**
 * Initializes all UI elements and sets up event listeners.
 * @param {function} getStateCb - Callback to get the current effect state.
 * @param {function} setStateCb - Callback to update the effect state.
 * @returns {object} An object containing references to key DOM elements.
 */
export function initUI(getStateCb, setStateCb) {
    getAppStateCallback = getStateCb;
    setAppStateCallback = setStateCb;

    elements = {
        canvas: getEl('gl-canvas'),
        video: getEl('video-source'),
        startButton: getEl('start-button'),
        loadingOverlay: getEl('loading-overlay'),
        loadingSpinner: getEl('loading-spinner'),
        errorMessage: getEl('error-message'),
        statusIndicator: getEl('status-indicator'),
        statusText: getEl('status-text'),
        adminViewBtn: getEl('admin-view-btn'),
        visitorViewBtn: getEl('visitor-view-btn'),
        adminView: getEl('admin-view'),
        visitorView: getEl('visitor-view'),
        effectsControlsContainer: getEl('effects-controls-container'),
        effectToggles: getEl('effect-toggles'),
        presetList: getEl('preset-list'),
        visitorPresetList: getEl('visitor-preset-list'),
        presetName: getEl('preset-name'),
        savePresetBtn: getEl('save-preset-btn'),
        deletePresetBtn: getEl('delete-preset-btn'),
        randomizeBtn: getEl('randomize-btn'),
    };
    
    // Setup event listeners
    elements.adminViewBtn.addEventListener('click', () => switchView('admin'));
    elements.visitorViewBtn.addEventListener('click', () => switchView('visitor'));
    elements.savePresetBtn.addEventListener('click', saveCurrentPreset);
    elements.deletePresetBtn.addEventListener('click', deleteSelectedPreset);
    elements.presetList.addEventListener('change', (e) => loadSelectedPreset(e.target));
    elements.visitorPresetList.addEventListener('change', (e) => loadSelectedPreset(e.target));
    elements.randomizeBtn.addEventListener('click', randomizeState);

    populatePresetLists();
    console.log("UI Initialized");
    
    return {
        canvas: elements.canvas,
        video: elements.video,
        startButton: elements.startButton,
    };
}

/**
 * Populates the UI controls for the first time after the engine is ready.
 * @param {object} initialState - The initial state from the engine.
 */
export function populateInitialControls(initialState) {
    populateAdminControls(initialState);
    populateEffectToggles(initialState);
    updateEffectToggleStyles();
}

export function updateUIState({ isLoading, errorMessage }) {
    if (isLoading) {
        elements.loadingSpinner.style.display = 'block';
        elements.startButton.disabled = true;
        elements.startButton.classList.add('opacity-50');
    } else {
        elements.loadingSpinner.style.display = 'none';
        elements.startButton.disabled = false;
        elements.startButton.classList.remove('opacity-50');
    }
    elements.errorMessage.textContent = errorMessage || '';
}

export function hideLoadingOverlay() {
    elements.loadingOverlay.style.display = 'none';
}

export function showErrorMessage(message) {
    updateUIState({ isLoading: false, errorMessage: message });
}

export function setStatus(text, isLive = false) {
    elements.statusText.textContent = text;
    if (isLive) {
        elements.statusIndicator.classList.add('bg-accent-primary', 'pulse-live');
        elements.statusIndicator.classList.remove('bg-danger-color');
    } else {
        elements.statusIndicator.classList.remove('bg-accent-primary', 'pulse-live');
        elements.statusIndicator.classList.add('bg-danger-color');
    }
}
```javascript
// webgl.js

// This module contains the GlitchEngine class, which manages the WebGL canvas,
// shaders, textures, and rendering pipeline.

import { vertexShaderSource, fragmentShaderSource } from './shaders.js';
import { effectDefinitions } from './effects.js';

/**
 * Creates and compiles a WebGL shader.
 * @param {WebGLRenderingContext} gl - The WebGL context.
 *param {number} type - The shader type (VERTEX_SHADER or FRAGMENT_SHADER).
 * @param {string} source - The GLSL source code.
 * @returns {WebGLShader} The compiled shader.
 */
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error(`Shader compilation failed: ${error}`);
    }
    return shader;
}

/**
 * Creates a WebGL program from vertex and fragment shaders.
 * @param {WebGLRenderingContext} gl - The WebGL context.
 * @param {WebGLShader} vs - The vertex shader.
 * @param {WebGLShader} fs - The fragment shader.
 * @returns {WebGLProgram} The linked WebGL program.
 */
function createProgram(gl, vs, fs) {
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error(`Program linking failed: ${error}`);
    }
    return program;
}

/**
 * Creates a WebGL texture with standard parameters.
 * @param {WebGLRenderingContext} gl - The WebGL context.
 * @returns {WebGLTexture} The created texture.
 */
function createTexture(gl) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
}


export class GlitchEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl', { premultipliedAlpha: false });
        if (!this.gl) {
            throw new Error('WebGL is not supported');
        }

        this.program = null;
        this.textures = {};
        this.uniformLocations = new Map();

        // State
        this.activeEffects = ['Displacement', 'RGBShift']; // Default active effects
        this.uniforms = {};
        this.initUniforms();
    }

    /**
     * Initializes all uniforms with their default values from effectDefinitions.
     */
    initUniforms() {
        Object.values(effectDefinitions).forEach(effect => {
            effect.uniforms.forEach(uniform => {
                // Store the full definition, including min/max/step for the UI
                this.uniforms[uniform.name] = { ...uniform };
            });
        });
         // Add global uniforms
        this.uniforms['u_time'] = { value: 0 };
        this.uniforms['u_resolution'] = { value: [0, 0] };
        this.uniforms['u_face_detected'] = { value: 0 };
        this.uniforms['u_face_center'] = { value: [0.5, 0.5] };
    }

    /**
     * Sets up the WebGL environment, shaders, and initial buffers.
     * @param {number} width - The width of the source video.
     * @param {number} height - The height of the source video.
     */
    setup(width, height) {
        const gl = this.gl;

        // --- Compile Shaders and Link Program ---
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        this.program = createProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(this.program);

        // --- Create Buffers ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [ -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0 ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(this.program, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Create Textures ---
        this.textures.video = createTexture(gl);
        
        // --- Set initial resolution ---
        this.resize(width, height);
        console.log("WebGL Engine Setup Complete");
    }

    /**
     * Resizes the canvas and WebGL viewport.
     */
    resize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.gl.viewport(0, 0, width, height);
        this.updateUniforms({ u_resolution: [width, height] });
    }

    /**
     * Updates the engine with new data for the next frame.
     */
    update(videoElement, faceResults) {
        const gl = this.gl;

        // Update video texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textures.video);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);
        
        // Update face data uniforms
        const faceDetected = faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0;
        this.updateUniforms({ 'u_face_detected': faceDetected ? 1.0 : 0.0 });
        if(faceDetected) {
            const landmarks = faceResults.faceLandmarks[0];
            const noseTip = landmarks[1]; // MediaPipe landmark for nose tip
            this.updateUniforms({ 'u_face_center': [1.0 - noseTip.x, 1.0 - noseTip.y] }); // Flip coordinates
        }
    }

    /**
     * Renders a single frame to the canvas.
     */
    render() {
        const gl = this.gl;
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(this.program);
        
        // --- Set All Uniforms ---
        this.setUniform('u_video_texture', 0); // Texture unit 0
        this.setUniform('u_time', performance.now() / 1000.0);

        // Set effect-specific uniforms from our state
        for (const [name, uniform] of Object.entries(this.uniforms)) {
            this.setUniform(name, uniform.value);
        }

        // Set active effect flags
        for (const effect of Object.values(effectDefinitions)) {
            const isActive = this.activeEffects.includes(effect.name);
            this.setUniform(`u_${effect.name}_active`, isActive);
        }

        // --- Draw ---
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    /**
     * A generic uniform setter that handles different types.
     */
    setUniform(name, value) {
        if (!this.program) return;
        const gl = this.gl;
        let location = this.uniformLocations.get(name);
        if (location === undefined) {
            location = gl.getUniformLocation(this.program, name);
            if (!location) {
                // Cache the negative result to avoid repeated lookups for non-existent uniforms
                this.uniformLocations.set(name, null);
                return; 
            }
            this.uniformLocations.set(name, location);
        }
        if (location === null) return; // Known non-existent uniform

        if (typeof value === 'number') {
            // Check if it's an integer for uniform1i, otherwise float
            gl.uniform1f(location, value);
        } else if (Array.isArray(value)) {
            switch (value.length) {
                case 2: gl.uniform2fv(location, value); break;
                case 3: gl.uniform3fv(location, value); break;
                case 4: gl.uniform4fv(location, value); break;
            }
        } else if (typeof value === 'boolean') {
             gl.uniform1i(location, value ? 1 : 0);
        }
    }
    
    // --- Public State Management ---

    getActiveEffects() {
        return [...this.activeEffects];
    }

    setActiveEffects(effects) {
        this.activeEffects = [...effects];
    }

    getUniformDefinitions() {
        // Return a copy of all defined uniforms and their properties
        return {
            uniforms: this.uniforms,
            effects: Object.values(effectDefinitions)
        };
    }

    updateUniforms(newUniforms) {
        for (const [name, value] of Object.entries(newUniforms)) {
            if (this.uniforms[name]) {
                this.uniforms[name].value = value;
            }
        }
    }
}
```javascript
// face.js

// This module handles the setup and execution of the MediaPipe Face Landmarker task.

// Import from the CDN
import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

// --- Constants ---
export { FACEMESH_TESSELATION } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";


// --- State ---
let faceLandmarker = null;
let runningMode = "VIDEO";


/**
 * Initializes the FaceLandmarker task.
 * This is an async function because it needs to load the model files.
 * @returns {Promise<FaceLandmarker>} A promise that resolves with the initialized FaceLandmarker instance.
 */
export async function initFaceLandmarker() {
    if (faceLandmarker) {
        console.log("Face Landmarker already initialized.");
        return faceLandmarker;
    }

    const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
    );

    faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
            delegate: "GPU"
        },
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrixes: false,
        runningMode: runningMode,
        numFaces: 1
    });

    console.log("Face Landmarker initialized successfully.");
    return faceLandmarker;
}


/**
 * Detects faces in a given video frame.
 * @param {FaceLandmarker} landmarker - The initialized FaceLandmarker instance.
 * @param {HTMLVideoElement} videoElement - The video element to process.
 * @returns {object} The detection results.
 */
export async function detectFaces(landmarker, videoElement) {
    if (!landmarker) {
        console.error("Face Landmarker is not initialized.");
        return {};
    }

    // detectForVideo can be slow, so we don't await it in the main loop
    // For this implementation, we will await it to keep logic simple.
    const results = await landmarker.detectForVideo(videoElement, performance.now());
    
    return results;
}
```javascript
// shaders.js

// This module exports the GLSL source code for the shaders.
// Keeping them in a separate file makes the main logic cleaner.

export const vertexShaderSource = `
    attribute vec4 a_position;
    varying vec2 v_texcoord;

    void main() {
        gl_Position = a_position;
        v_texcoord = a_position.xy * 0.5 + 0.5;
    }
`;

export const fragmentShaderSource = `
    precision highp float;

    // Varyings
    varying vec2 v_texcoord;

    // Textures
    uniform sampler2D u_video_texture;

    // Global Uniforms
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_face_detected;
    uniform vec2 u_face_center; // Flipped coordinates [0,1]

    // Effect Flags
    uniform bool u_RGBShift_active;
    uniform bool u_Displacement_active;
    uniform bool u_Pixelate_active;
    uniform bool u_Scanlines_active;

    // Effect-specific Uniforms
    uniform float u_rgb_amount;
    uniform float u_rgb_angle;
    uniform float u_noise_amount;
    uniform float u_noise_speed;
    uniform float u_pixel_size;
    uniform float u_scanline_density;
    uniform float u_scanline_opacity;


    // --- Helper Functions ---
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }


    // --- Effect Functions ---

    vec4 applyRGBShift(sampler2D tex, vec2 uv, float amount, float angle) {
        vec2 dir = vec2(cos(angle), sin(angle));
        vec2 offset = dir * amount / u_resolution.x;
        float r = texture2D(tex, uv - offset).r;
        float g = texture2D(tex, uv).g;
        float b = texture2D(tex, uv + offset).b;
        return vec4(r, g, b, 1.0);
    }

    vec2 applyDisplacement(vec2 uv, float amount, float speed) {
        float noise_val = random(uv + u_time * speed) - 0.5; // From -0.5 to 0.5
        vec2 offset = vec2(noise_val) * amount / u_resolution.x;
        return uv + offset;
    }

    vec2 applyPixelate(vec2 uv, float size) {
        if (size <= 1.0) return uv;
        vec2 res_factor = u_resolution / size;
        return (floor(uv * res_factor) + 0.5) / res_factor;
    }

    vec4 applyScanlines(vec4 color, vec2 uv, float density, float opacity) {
        float y = uv.y * density;
        float line = fract(y) > 0.5 ? 1.0 : 1.0 - opacity;
        return color * line;
    }


    void main() {
        vec2 uv = v_texcoord;

        // --- Effect Pipeline ---
        // The order matters here. UV effects first, then color effects.

        // 1. UV manipulation effects
        if (u_Displacement_active) {
            uv = applyDisplacement(uv, u_noise_amount, u_noise_speed);
        }
        if (u_Pixelate_active) {
            uv = applyPixelate(uv, u_pixel_size);
        }

        // 2. Sample the texture with the (potentially modified) UVs
        vec4 color = texture2D(u_video_texture, uv);

        // 3. Color manipulation effects
        if (u_RGBShift_active) {
            color = applyRGBShift(u_video_texture, uv, u_rgb_amount, u_rgb_angle);
        }
        if (u_Scanlines_active) {
            color = applyScanlines(color, v_texcoord, u_scanline_density, u_scanline_opacity);
        }

        // --- Final Output ---
        gl_FragColor = color;
    }
`;
```javascript
// effects.js

// This module defines the properties of all available glitch effects,
// including their names and the uniforms they use. This centralized
// definition makes it easy to add or modify effects.

export const effectDefinitions = {
    RGBShift: {
        name: 'RGBShift',
        label: 'RGB Shift',
        uniforms: [
            { name: 'u_rgb_amount', label: 'Amount', type: 'float', value: 5.0, min: 0.0, max: 50.0, step: 0.1 },
            { name: 'u_rgb_angle', label: 'Angle', type: 'float', value: 0.0, min: 0.0, max: 6.28, step: 0.01 }
        ]
    },
    Displacement: {
        name: 'Displacement',
        label: 'Displacement',
        uniforms: [
            { name: 'u_noise_amount', label: 'Amount', type: 'float', value: 2.0, min: 0.0, max: 20.0, step: 0.1 },
            { name: 'u_noise_speed', label: 'Speed', type: 'float', value: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        ]
    },
    Pixelate: {
        name: 'Pixelate',
        label: 'Pixelate',
        uniforms: [
            { name: 'u_pixel_size', label: 'Pixel Size', type: 'float', value: 1.0, min: 1.0, max: 100.0, step: 1.0 }
        ]
    },
    Scanlines: {
        name: 'Scanlines',
        label: 'Scanlines',
        uniforms: [
            { name: 'u_scanline_density', label: 'Density', type: 'float', value: 800.0, min: 10.0, max: 2000.0, step: 10.0 },
            { name: 'u_scanline_opacity', label: 'Opacity', type: 'float', value: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        ]
    }
};
