<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face Glitch V3 - UNKNOWN</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent-primary: #00ff99;
            --accent-secondary: #ff00ff;
            --border-color: #3a3a3a;
            --danger-color: #ff3b30;
            --success-color: #34c759;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }

        /* Custom Slider Styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            outline: none;
            border-radius: 2px;
            transition: background 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
            transition: transform 0.2s ease;
        }
        
        input[type="range"]:hover::-webkit-slider-thumb {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
        }
        
        /* Custom Checkbox */
        .custom-checkbox {
            -webkit-appearance: none;
            appearance: none;
            background-color: var(--bg-tertiary);
            width: 20px;
            height: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .custom-checkbox:checked {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .custom-checkbox:checked::after {
            content: 'âœ“';
            font-size: 14px;
            color: var(--bg-primary);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Pulsing animation for status indicator */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .pulse-live {
            animation: pulse 2s infinite;
        }

        /* Notification Toast */
        #notification-toast {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(-100%);
            opacity: 0;
        }
        #notification-toast.show {
            transform: translateY(0);
            opacity: 1;
        }

    </style>
</head>
<body class="overflow-hidden">

    <div id="app-container" class="flex h-screen w-screen bg-bg-primary relative">
        
        <!-- Main Stage: Where the visual output is rendered -->
        <div id="main-stage" class="flex-grow h-screen relative bg-black flex items-center justify-center">
            <video id="video-source" class="hidden" playsinline muted></video>
            <canvas id="gl-canvas" class="w-full h-full object-contain"></canvas>
            <div id="loading-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center text-center p-8 z-20">
                <h1 class="text-4xl font-bold mb-2 font-mono">UNKNOWN</h1>
                <p class="text-lg text-text-secondary mb-8">Interactive Glitch Installation</p>
                <button id="start-button" class="px-8 py-3 bg-accent-primary text-bg-primary font-bold rounded-lg text-xl hover:bg-white transition-all duration-300 transform hover:scale-105">Initialize Camera</button>
                <p id="error-message" class="mt-6 text-danger-color font-mono"></p>
                <div id="loading-spinner" class="hidden mt-4 border-4 border-t-4 border-gray-200 border-t-accent-primary rounded-full w-12 h-12 animate-spin"></div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div id="controls-panel" class="w-[450px] h-screen bg-bg-secondary flex flex-col border-l border-border-color shrink-0 relative overflow-hidden">
            <!-- Notification Toast -->
            <div id="notification-toast" class="absolute top-0 left-0 right-0 p-3 text-center font-semibold text-white z-30">
                <span id="notification-message"></span>
            </div>

            <div class="p-4 border-b border-border-color flex justify-between items-center shrink-0">
                <h1 class="text-xl font-bold font-mono">CONTROLS</h1>
                <div class="flex items-center space-x-3">
                    <span id="status-indicator" class="w-3 h-3 bg-danger-color rounded-full"></span>
                    <span id="status-text" class="text-sm text-text-secondary font-mono">OFFLINE</span>
                </div>
            </div>

            <!-- Tabs for Admin/Visitor modes -->
            <div class="flex border-b border-border-color shrink-0">
                <button id="admin-view-btn" class="flex-1 p-3 text-center font-semibold bg-bg-tertiary border-r border-border-color">Admin</button>
                <button id="visitor-view-btn" class="flex-1 p-3 text-center font-semibold text-text-secondary">Visitor</button>
            </div>

            <!-- Container for different views -->
            <div class="flex-grow overflow-y-auto p-4">
                
                <!-- ADMIN VIEW -->
                <div id="admin-view">
                    <!-- Presets Section -->
                    <div class="bg-bg-tertiary rounded-lg p-4">
                        <h2 class="font-bold mb-3 text-lg font-mono">PRESETS</h2>
                        <div class="space-y-3">
                            <select id="preset-list" class="w-full p-2 bg-bg-primary border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary"></select>
                            <input type="text" id="preset-name" placeholder="New Preset Name..." class="w-full p-2 bg-bg-primary border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
                            <div class="grid grid-cols-2 gap-3">
                                <button id="save-preset-btn" class="w-full p-2 bg-accent-primary text-bg-primary font-bold rounded-md hover:bg-white transition-colors">Save</button>
                                <button id="delete-preset-btn" class="w-full p-2 bg-danger-color text-white font-bold rounded-md hover:bg-red-400 transition-colors">Delete</button>
                            </div>
                        </div>
                    </div>

                    <!-- Global Controls Section -->
                    <div id="global-controls-container" class="mt-6">
                        <!-- Global controls (like masking) will be generated here -->
                    </div>

                    <!-- Effects Section -->
                    <div class="bg-bg-tertiary rounded-lg p-4 mt-6">
                        <h2 class="font-bold mb-3 text-lg font-mono">ACTIVE EFFECTS</h2>
                        <div id="effect-toggles" class="grid grid-cols-2 gap-2">
                            <!-- Effect toggles will be generated here by JS -->
                        </div>
                    </div>
                    
                    <!-- Controls Container -->
                    <div id="effects-controls-container" class="space-y-4 mt-6">
                        <!-- Effect controls will be generated here -->
                    </div>
                </div>

                <!-- VISITOR VIEW -->
                <div id="visitor-view" class="hidden">
                     <div class="bg-bg-tertiary rounded-lg p-4">
                        <h2 class="font-bold mb-3 text-lg font-mono">CHOOSE A STYLE</h2>
                        <select id="visitor-preset-list" class="w-full p-3 bg-bg-primary border border-border-color rounded-md text-lg focus:outline-none focus:ring-2 focus:ring-accent-primary"></select>
                    </div>
                    <div id="visitor-controls-container" class="space-y-6 mt-6">
                        <!-- Simplified visitor controls will be generated here -->
                    </div>
                    <div class="mt-6">
                         <button id="randomize-btn" class="w-full p-4 bg-accent-secondary text-white font-bold rounded-md text-xl hover:bg-fuchsia-500 transition-colors duration-300 transform hover:scale-105">RANDOMIZE</button>
                    </div>
                </div>

            </div>

            <div class="p-4 border-t border-border-color text-center shrink-0">
                <p class="text-xs text-text-secondary font-mono">UNKNOWN v3.3 FINAL (FIXED)</p>
            </div>
        </div>
    </div>

    <!-- ES6 Module Scripts -->
    <script type="module" src="./main.js"></script>

</body>
</html>
```javascript
// main.js

// This is the main entry point of the application.
// It orchestrates the setup of UI, WebGL, and Face Tracking.

import { initUI, updateUIState, showErrorMessage, hideLoadingOverlay, setStatus, setFullState, populateInitialControls } from './ui.js';
import { GlitchEngine } from './webgl.js';
import { initFaceLandmarker, detectFaces, drawFaceMask, getMaskCanvas } from './face.js';

// --- Global State ---
let glitchEngine = null;
let faceLandmarker = null;
let videoElement = null;
let lastVideoTime = -1;
let animationFrameId = null;
let isRunning = false;

// --- Core Application Logic ---

/**
 * The main animation loop. Called every frame.
 */
async function renderLoop() {
    if (!isRunning) return;

    // Get the current video frame
    if (videoElement.currentTime !== lastVideoTime) {
        lastVideoTime = videoElement.currentTime;

        // Detect faces in the current frame
        const faceResults = await detectFaces(faceLandmarker, videoElement);
        
        // Draw the face mask onto its dedicated canvas
        drawFaceMask(faceResults.faceLandmarks, videoElement.videoWidth, videoElement.videoHeight);

        // Update the WebGL engine with the new video frame and face data
        if (glitchEngine) {
            glitchEngine.update(videoElement, getMaskCanvas());
            glitchEngine.render();
        }

        // Update UI elements with status
        const faceDetected = faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0;
        setStatus(faceDetected ? 'FACE DETECTED' : 'SEARCHING...', faceDetected);
    }
    
    animationFrameId = requestAnimationFrame(renderLoop);
}

/**
 * Initializes and starts the camera stream.
 */
async function startCamera() {
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('Camera access is not supported by this browser.');
        }
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720, facingMode: 'user' }
        });
        videoElement.srcObject = stream;
        await new Promise(resolve => {
            videoElement.onloadedmetadata = () => resolve();
        });
        await videoElement.play();
    } catch (err) {
        console.error("Camera Error:", err);
        let message = `Failed to access camera: ${err.message}.`;
        if (err.name === 'NotAllowedError') {
            message = 'Camera permission was denied. Please allow camera access in your browser settings.';
        }
        if(!isSecureContext){
            message = 'Camera access requires a secure connection (HTTPS).';
        }
        showErrorMessage(message);
        throw err; // Propagate error to stop initialization
    }
}

/**
 * Main initialization function.
 */
async function main() {
    // 1. Initialize UI components and get references
    const { canvas, video, startButton } = initUI(getAppState, setAppState);
    videoElement = video;
    glitchEngine = new GlitchEngine(canvas);

    // After the glitch engine is created, its default state is known.
    // We can now populate the UI with the initial controls.
    populateInitialControls(getAppState());

    // 2. Setup event listener for the start button
    startButton.addEventListener('click', async () => {
        try {
            updateUIState({ isLoading: true, errorMessage: '' });
            
            setStatus('Loading AI Model...');
            faceLandmarker = await initFaceLandmarker();

            setStatus('Initializing Camera...');
            await startCamera();

            glitchEngine.setup(videoElement.videoWidth, videoElement.videoHeight);

            hideLoadingOverlay();
            isRunning = true;
            renderLoop();

        } catch (error) {
            updateUIState({ isLoading: false });
            setStatus('ERROR', false);
        }
    });
}

// --- State Management Bridge between UI and WebGL ---

function getAppState() {
    if (!glitchEngine) return { activeEffects: [], uniforms: {}, effects: [], globalUniforms: [] };
    const { uniforms, effects, globalUniforms } = glitchEngine.getUniformDefinitions();
    return {
        activeEffects: glitchEngine.getActiveEffects(),
        uniforms,
        effects,
        globalUniforms
    };
}

function setAppState(newState) {
    if (!glitchEngine) return;

    if (newState.activeEffects) {
        glitchEngine.setActiveEffects(newState.activeEffects);
    }
    if (newState.uniforms) {
        glitchEngine.updateUniforms(newState.uniforms);
    }

    setFullState(newState);
}


// --- Start the application ---
main();
```javascript
// ui.js

// This module handles all DOM interactions, event listeners,
// and UI state management (like switching views, updating sliders, etc.).

// --- State ---
let getAppStateCallback = () => {};
let setAppStateCallback = () => {};
let currentView = 'admin'; // 'admin' or 'visitor'
const PRESET_STORAGE_KEY = 'faceGlitchV3Presets';
let notificationTimeout = null;

// --- DOM Elements ---
let elements = {};

// --- Helper Functions ---
const getEl = (id) => document.getElementById(id);

/**
 * Shows a temporary notification message at the top of the controls panel.
 * @param {string} message - The message to display.
 * @param {boolean} isError - If true, styles the notification as an error.
 */
function showNotification(message, isError = false) {
    if (notificationTimeout) {
        clearTimeout(notificationTimeout);
    }
    elements.notificationMessage.textContent = message;
    elements.notificationToast.classList.toggle('bg-danger-color', isError);
    elements.notificationToast.classList.toggle('bg-success-color', !isError);
    elements.notificationToast.classList.add('show');

    notificationTimeout = setTimeout(() => {
        elements.notificationToast.classList.remove('show');
    }, 3000);
}


/**
 * Creates a slider control component.
 * @param {object} uniform - The uniform object from the effects definition.
 * @returns {HTMLElement} The control group element.
 */
function createSlider(uniform) {
    const id = `slider-${uniform.name}`;
    const controlEl = document.createElement('div');
    controlEl.className = 'space-y-2';

    const labelContainer = document.createElement('div');
    labelContainer.className = 'flex justify-between items-center text-sm';
    
    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = uniform.label;
    label.className = 'font-semibold text-text-secondary';
    
    const valueSpan = document.createElement('span');
    valueSpan.id = `${id}-value`;
    valueSpan.className = 'font-mono text-accent-primary';
    valueSpan.textContent = parseFloat(uniform.value).toFixed(uniform.step < 1 ? 2 : 0);

    labelContainer.append(label, valueSpan);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.id = id;
    slider.min = uniform.min;
    slider.max = uniform.max;
    slider.step = uniform.step;
    slider.value = uniform.value;
    slider.dataset.uniform = uniform.name;

    slider.addEventListener('input', (e) => {
        const newValue = parseFloat(e.target.value);
        valueSpan.textContent = newValue.toFixed(uniform.step < 1 ? 2 : 0);
        const uniformUpdate = { [uniform.name]: newValue };
        setAppStateCallback({ uniforms: uniformUpdate });
    });

    controlEl.append(labelContainer, slider);
    return controlEl;
}

/**
 * Creates a checkbox control component.
 */
function createCheckbox(uniform) {
    const id = `checkbox-${uniform.name}`;
    const controlEl = document.createElement('label');
    controlEl.className = 'flex items-center space-x-3 cursor-pointer';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = id;
    checkbox.checked = uniform.value > 0.5;
    checkbox.className = 'custom-checkbox';
    checkbox.dataset.uniform = uniform.name;

    checkbox.addEventListener('change', (e) => {
        const newValue = e.target.checked ? 1.0 : 0.0;
        const uniformUpdate = { [uniform.name]: newValue };
        setAppStateCallback({ uniforms: uniformUpdate });
    });

    const label = document.createElement('span');
    label.textContent = uniform.label;
    label.className = 'text-text-secondary';

    controlEl.append(checkbox, label);
    return controlEl;
}

/**
 * Creates and populates the controls for all defined effects for the Admin view.
 */
function populateAdminControls() {
    const { uniforms: allUniforms, effects, globalUniforms } = getAppStateCallback();
    
    // Populate Global Controls
    const globalContainer = elements.globalControlsContainer;
    globalContainer.innerHTML = '';
    if (globalUniforms.length > 0) {
        const group = document.createElement('div');
        group.className = 'bg-bg-tertiary rounded-lg p-4 space-y-4';
        const header = document.createElement('h2');
        header.className = 'font-bold mb-3 text-lg font-mono';
        header.textContent = 'GLOBAL CONTROLS';
        group.appendChild(header);

        globalUniforms.map(uname => allUniforms[uname]).forEach(uniform => {
            if (uniform.type === 'bool') {
                group.appendChild(createCheckbox(uniform));
            } else {
                group.appendChild(createSlider(uniform));
            }
        });
        globalContainer.appendChild(group);
    }

    // Populate Effect-Specific Controls
    const effectsContainer = elements.effectsControlsContainer;
    effectsContainer.innerHTML = ''; 
    effects.forEach(effect => {
        const effectUniforms = effect.uniforms.map(uname => allUniforms[uname]);

        if (effectUniforms.length > 0) {
            const group = document.createElement('div');
            group.className = 'bg-bg-tertiary rounded-lg p-4 space-y-4';
            group.dataset.effectControlGroup = effect.name;
            
            const header = document.createElement('h3');
            header.className = 'font-bold font-mono text-lg';
            header.textContent = effect.label;
            group.appendChild(header);

            effectUniforms.forEach(uniform => {
                group.appendChild(createSlider(uniform));
            });
            effectsContainer.appendChild(group);
        }
    });
}

/**
 * Creates the toggle buttons for activating/deactivating effects.
 */
function populateEffectToggles() {
    const { effects } = getAppStateCallback();
    const container = elements.effectToggles;
    container.innerHTML = '';

    effects.forEach(effect => {
        const button = document.createElement('button');
        button.className = 'p-2 rounded-md text-sm font-semibold transition-colors border';
        button.textContent = effect.label;
        button.dataset.effect = effect.name;

        button.addEventListener('click', () => {
            const { activeEffects } = getAppStateCallback();
            const wasActive = activeEffects.includes(effect.name);
            const newActiveEffects = wasActive 
                ? activeEffects.filter(e => e !== effect.name)
                : [...activeEffects, effect.name];
            setAppStateCallback({ activeEffects: newActiveEffects });
        });
        container.appendChild(button);
    });
    updateEffectToggleStyles();
}

/**
 * Updates the visual style of effect toggles based on the current state.
 */
function updateEffectToggleStyles() {
    const { activeEffects } = getAppStateCallback();
    document.querySelectorAll('#effect-toggles [data-effect]').forEach(el => {
        const effectName = el.dataset.effect;
        const isActive = activeEffects.includes(effectName);
        el.classList.toggle('bg-accent-primary', isActive);
        el.classList.toggle('text-bg-primary', isActive);
        el.classList.toggle('border-accent-primary', isActive);
        el.classList.toggle('bg-transparent', !isActive);
        el.classList.toggle('text-text-primary', !isActive);
        el.classList.toggle('border-border-color', !isActive);
    });
}

/**
 * Switches the view between 'admin' and 'visitor'.
 */
function switchView(viewName) {
    currentView = viewName;
    elements.adminView.style.display = viewName === 'admin' ? 'block' : 'none';
    elements.visitorView.style.display = viewName === 'visitor' ? 'block' : 'none';
    
    elements.adminViewBtn.classList.toggle('bg-bg-tertiary', viewName === 'admin');
    elements.adminViewBtn.classList.toggle('text-text-primary', viewName === 'admin');
    elements.adminViewBtn.classList.toggle('text-text-secondary', viewName !== 'admin');
    
    elements.visitorViewBtn.classList.toggle('bg-bg-tertiary', viewName === 'visitor');
    elements.visitorViewBtn.classList.toggle('text-text-primary', viewName === 'visitor');
    elements.visitorViewBtn.classList.toggle('text-text-secondary', viewName !== 'visitor');
}

// --- Preset Management ---

function getPresets() {
    try {
        const presets = localStorage.getItem(PRESET_STORAGE_KEY);
        return presets ? JSON.parse(presets) : {};
    } catch (e) {
        console.error("Failed to parse presets from localStorage", e);
        return {};
    }
}

function savePresets(presets) {
    try {
        localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
    } catch (e) {
        console.error("Failed to save presets to localStorage", e);
    }
}

function populatePresetLists() {
    const presets = getPresets();
    const presetNames = Object.keys(presets);
    const createOption = (name) => new Option(name, name);

    elements.presetList.innerHTML = '<option value="">Load Preset...</option>';
    elements.visitorPresetList.innerHTML = '<option value="">Choose a Style...</option>';

    presetNames.forEach(name => {
        elements.presetList.add(createOption(name));
        elements.visitorPresetList.add(createOption(name));
    });
}

function saveCurrentPreset() {
    const name = elements.presetName.value.trim();
    if (!name) {
        showNotification("Please enter a name for the preset.", true);
        return;
    }
    const presets = getPresets();
    const { activeEffects, uniforms } = getAppStateCallback();
    
    const uniformValues = {};
    for(const key in uniforms) {
        uniformValues[key] = uniforms[key].value;
    }

    presets[name] = { activeEffects, uniforms: uniformValues };
    savePresets(presets);
    populatePresetLists();
    elements.presetList.value = name;
    showNotification(`Preset '${name}' saved!`);
}

function deleteSelectedPreset() {
    const name = elements.presetList.value;
    if (!name) {
        showNotification("Please select a preset to delete.", true);
        return;
    }
    
    const presets = getPresets();
    delete presets[name];
    savePresets(presets);
    populatePresetLists();
    elements.presetName.value = '';
    showNotification(`Preset '${name}' deleted.`);
}

function loadSelectedPreset(selectElement) {
    const name = selectElement.value;
    if (!name) return;

    const presets = getPresets();
    const preset = presets[name];
    if (preset) {
        setAppStateCallback(preset);
        elements.presetName.value = name;
        elements.presetList.value = name;
        elements.visitorPresetList.value = name;
    }
}

// --- Randomization ---

function randomizeState() {
    const { uniforms, effects } = getAppStateCallback();
    const newUniforms = {};
    
    for (const key in uniforms) {
        const uniform = uniforms[key];
        if (uniform.min !== undefined) {
            const min = parseFloat(uniform.min);
            const max = parseFloat(uniform.max);
            newUniforms[key] = Math.random() * (max - min) + min;
        }
    }

    const newActiveEffects = effects
        .map(e => e.name)
        .filter(() => Math.random() > 0.5);
    
    if (newActiveEffects.length === 0) {
        newActiveEffects.push(effects[Math.floor(Math.random() * effects.length)].name);
    }

    setAppStateCallback({
        uniforms: newUniforms,
        activeEffects: newActiveEffects
    });
}

// --- Public Functions ---

export function setFullState(state) {
    if (!state) return;
    
    if (state.uniforms) {
        for (const [name, value] of Object.entries(state.uniforms)) {
            const slider = document.querySelector(`input[data-uniform="${name}"]`);
            if (slider) {
                slider.value = value;
                const valueSpan = getEl(`${slider.id}-value`);
                if (valueSpan) {
                    valueSpan.textContent = parseFloat(value).toFixed(slider.step < 1 ? 2 : 0);
                }
            }
             const checkbox = document.querySelector(`input[type="checkbox"][data-uniform="${name}"]`);
            if (checkbox) {
                checkbox.checked = value > 0.5;
            }
        }
    }

    if (state.activeEffects) {
        updateEffectToggleStyles();
    }
}

export function initUI(getStateCb, setStateCb) {
    getAppStateCallback = getStateCb;
    setAppStateCallback = setStateCb;

    elements = {
        canvas: getEl('gl-canvas'),
        video: getEl('video-source'),
        startButton: getEl('start-button'),
        loadingOverlay: getEl('loading-overlay'),
        loadingSpinner: getEl('loading-spinner'),
        errorMessage: getEl('error-message'),
        statusIndicator: getEl('status-indicator'),
        statusText: getEl('status-text'),
        adminViewBtn: getEl('admin-view-btn'),
        visitorViewBtn: getEl('visitor-view-btn'),
        adminView: getEl('admin-view'),
        visitorView: getEl('visitor-view'),
        globalControlsContainer: getEl('global-controls-container'),
        effectsControlsContainer: getEl('effects-controls-container'),
        effectToggles: getEl('effect-toggles'),
        presetList: getEl('preset-list'),
        visitorPresetList: getEl('visitor-preset-list'),
        presetName: getEl('preset-name'),
        savePresetBtn: getEl('save-preset-btn'),
        deletePresetBtn: getEl('delete-preset-btn'),
        randomizeBtn: getEl('randomize-btn'),
        notificationToast: getEl('notification-toast'),
        notificationMessage: getEl('notification-message'),
    };
    
    elements.adminViewBtn.addEventListener('click', () => switchView('admin'));
    elements.visitorViewBtn.addEventListener('click', () => switchView('visitor'));
    elements.savePresetBtn.addEventListener('click', saveCurrentPreset);
    elements.deletePresetBtn.addEventListener('click', deleteSelectedPreset);
    elements.presetList.addEventListener('change', (e) => loadSelectedPreset(e.target));
    elements.visitorPresetList.addEventListener('change', (e) => loadSelectedPreset(e.target));
    elements.randomizeBtn.addEventListener('click', randomizeState);

    populatePresetLists();
    console.log("UI Initialized");
    
    return {
        canvas: elements.canvas,
        video: elements.video,
        startButton: elements.startButton,
    };
}

export function populateInitialControls(initialState) {
    populateAdminControls(initialState);
    populateEffectToggles(initialState);
    updateEffectToggleStyles();
}

export function updateUIState({ isLoading, errorMessage }) {
    elements.loadingSpinner.style.display = isLoading ? 'block' : 'none';
    elements.startButton.disabled = isLoading;
    elements.startButton.classList.toggle('opacity-50', isLoading);
    elements.errorMessage.textContent = errorMessage || '';
}

export function hideLoadingOverlay() {
    elements.loadingOverlay.style.display = 'none';
}

export function showErrorMessage(message) {
    updateUIState({ isLoading: false, errorMessage: message });
}

export function setStatus(text, isLive = false) {
    elements.statusText.textContent = text;
    elements.statusIndicator.classList.toggle('bg-accent-primary', isLive);
    elements.statusIndicator.classList.toggle('pulse-live', isLive);
    elements.statusIndicator.classList.toggle('bg-danger-color', !isLive);
}
```javascript
// webgl.js

// This module contains the GlitchEngine class, which manages the WebGL canvas,
// shaders, textures, and rendering pipeline.

import { vertexShaderSource, fragmentShaderSource, postFXVertexShaderSource, postFXFragmentShaderSource } from './shaders.js';
import { effectDefinitions, globalUniformDefinitions } from './effects.js';

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error(`Shader compilation failed: ${error}`);
    }
    return shader;
}

function createProgram(gl, vs, fs) {
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error(`Program linking failed: ${error}`);
    }
    return program;
}

function createTexture(gl) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
}

function createFramebuffer(gl, texture) {
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    return fb;
}

export class GlitchEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl', { premultipliedAlpha: false });
        if (!this.gl) throw new Error('WebGL is not supported');

        this.program = null;
        this.postFXProgram = null; // Program for drawing the final texture to screen
        this.textures = {};
        this.framebuffers = {};
        this.uniformLocations = new Map();
        this.activeEffects = ['Displacement', 'RGBShift', 'Feedback'];
        this.uniforms = {};
        this.initUniforms();
    }

    initUniforms() {
        Object.values(effectDefinitions).forEach(effect => {
            effect.uniforms.forEach(uniform => {
                this.uniforms[uniform.name] = { ...uniform };
            });
        });
        globalUniformDefinitions.forEach(uniform => {
            this.uniforms[uniform.name] = { ...uniform };
        });
        this.uniforms['u_time'] = { value: 0 };
        this.uniforms['u_resolution'] = { value: [0, 0] };
    }

    setup(width, height) {
        const gl = this.gl;

        // --- Main Effects Program ---
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        this.program = createProgram(gl, vertexShader, fragmentShader);
        
        // --- Post-Processing (Display) Program ---
        const postFXVS = createShader(gl, gl.VERTEX_SHADER, postFXVertexShaderSource);
        const postFXFS = createShader(gl, gl.FRAGMENT_SHADER, postFXFragmentShaderSource);
        this.postFXProgram = createProgram(gl, postFXVS, postFXFS);

        // --- Geometry Buffer (shared by both programs) ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
        const posLocation = gl.getAttribLocation(this.program, 'a_position');
        gl.enableVertexAttribArray(posLocation);
        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Textures ---
        this.textures.video = createTexture(gl);
        this.textures.mask = createTexture(gl);
        this.textures.read = createTexture(gl);
        this.textures.write = createTexture(gl);
        
        this.resize(width, height); 

        // --- Framebuffers ---
        this.framebuffers.read = createFramebuffer(gl, this.textures.read);
        this.framebuffers.write = createFramebuffer(gl, this.textures.write);
        
        console.log("WebGL Engine Setup Complete");
    }

    resize(width, height) {
        const gl = this.gl;
        this.canvas.width = width;
        this.canvas.height = height;

        for (const key of ['read', 'write']) {
            gl.bindTexture(gl.TEXTURE_2D, this.textures[key]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        
        this.updateUniforms({ u_resolution: [width, height] });
    }

    update(videoElement, maskCanvas) {
        const gl = this.gl;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textures.video);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);
        
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.textures.mask);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);
    }

    swapFramebuffers() {
        [this.textures.read, this.textures.write] = [this.textures.write, this.textures.read];
        [this.framebuffers.read, this.framebuffers.write] = [this.framebuffers.write, this.framebuffers.read];
    }

    render() {
        const gl = this.gl;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        
        // --- Pass 1: Render effects into the 'write' framebuffer ---
        gl.useProgram(this.program);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers.write);
        gl.clear(gl.COLOR_BUFFER_BIT);

        this.setAllUniforms(this.program);
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // --- Pass 2: Render the result to the actual canvas ---
        gl.useProgram(this.postFXProgram);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Bind the texture we just rendered to
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textures.write);
        this.setUniform(this.postFXProgram, 'u_texture', 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // Swap for the next frame's feedback
        this.swapFramebuffers();
    }

    setAllUniforms(program) {
        // Set texture units
        this.setUniform(program, 'u_video_texture', 0);
        this.setUniform(program, 'u_mask_texture', 1);
        this.setUniform(program, 'u_feedback_texture', 2);
        
        // Bind the previous frame's output for feedback
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, this.textures.read);

        // Set time and all user-controlled uniforms
        this.setUniform(program, 'u_time', performance.now() / 1000.0);
        for (const [name, uniform] of Object.entries(this.uniforms)) {
            this.setUniform(program, name, uniform.value);
        }
        // Set active effect flags
        for (const effect of Object.values(effectDefinitions)) {
            this.setUniform(program, `u_${effect.name}_active`, this.activeEffects.includes(effect.name));
        }
    }

    setUniform(program, name, value) {
        const gl = this.gl;
        // A more robust cache key including program might be needed if uniforms differ, but not here.
        let location = this.uniformLocations.get(name);
        if (location === undefined) {
            location = gl.getUniformLocation(program, name);
            this.uniformLocations.set(name, location || null);
        }
        if (!location) return;

        if (typeof value === 'boolean') {
            gl.uniform1i(location, value ? 1 : 0);
        } else if (typeof value === 'number') {
            // Use uniform1i for integers (like texture units), 1f for floats
            if (Number.isInteger(value) && name.includes('texture')) {
                 gl.uniform1i(location, value);
            } else {
                 gl.uniform1f(location, value);
            }
        } else if (Array.isArray(value)) {
            switch (value.length) {
                case 2: gl.uniform2fv(location, value); break;
                case 3: gl.uniform3fv(location, value); break;
                case 4: gl.uniform4fv(location, value); break;
            }
        }
    }
    
    // --- Public State Management ---
    getActiveEffects = () => [...this.activeEffects];
    setActiveEffects = (effects) => { this.activeEffects = [...effects]; };
    
    getUniformDefinitions() {
        return {
            uniforms: this.uniforms,
            effects: Object.values(effectDefinitions),
            globalUniforms: globalUniformDefinitions.map(u => u.name)
        };
    }

    updateUniforms(newUniforms) {
        for (const [name, value] of Object.entries(newUniforms)) {
            if (this.uniforms[name]) {
                this.uniforms[name].value = value;
            }
        }
    }
}
```javascript
// face.js

// This module handles the setup and execution of the MediaPipe Face Landmarker task,
// and drawing the face mask to a canvas.

import { FaceLandmarker, FilesetResolver, FACEMESH_TESSELATION } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

// --- State ---
let faceLandmarker = null;
let runningMode = "VIDEO";
const maskCanvas = document.createElement('canvas');
const maskCtx = maskCanvas.getContext('2d');

/**
 * Initializes the FaceLandmarker task.
 */
export async function initFaceLandmarker() {
    if (faceLandmarker) return faceLandmarker;

    const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
    );

    faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
            delegate: "GPU"
        },
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrixes: false,
        runningMode: runningMode,
        numFaces: 1
    });

    console.log("Face Landmarker initialized successfully.");
    return faceLandmarker;
}

/**
 * Detects faces in a given video frame.
 */
export async function detectFaces(landmarker, videoElement) {
    if (!landmarker) return {};
    return await landmarker.detectForVideo(videoElement, performance.now());
}

/**
 * Draws the detected face landmarks as a filled shape on the mask canvas.
 * @param {Array} faceLandmarks - An array of face landmark arrays.
 * @param {number} width - The width of the canvas.
 * @param {number} height - The height of the canvas.
 */
export function drawFaceMask(faceLandmarks, width, height) {
    if (maskCanvas.width !== width || maskCanvas.height !== height) {
        maskCanvas.width = width;
        maskCanvas.height = height;
    }

    maskCtx.clearRect(0, 0, width, height);

    if (faceLandmarks && faceLandmarks.length > 0) {
        const landmarks = faceLandmarks[0];
        maskCtx.fillStyle = '#FFFFFF';
        maskCtx.beginPath();
        
        // Use the tesselation data to draw triangles covering the face
        FACEMESH_TESSELATION.forEach(triangle => {
            const p1 = landmarks[triangle[0]];
            const p2 = landmarks[triangle[1]];
            const p3 = landmarks[triangle[2]];

            // Flip horizontally to match video
            maskCtx.moveTo((1 - p1.x) * width, p1.y * height);
            maskCtx.lineTo((1 - p2.x) * width, p2.y * height);
            maskCtx.lineTo((1 - p3.x) * width, p3.y * height);
            maskCtx.closePath();
        });
        
        maskCtx.fill();
    }
}

/**
 * Returns the canvas element used for drawing the mask.
 * @returns {HTMLCanvasElement}
 */
export function getMaskCanvas() {
    return maskCanvas;
}
```javascript
// shaders.js

// This module exports the GLSL source code for the shaders.

// --- Simple shader for drawing a texture to the screen ---
export const postFXVertexShaderSource = `
    attribute vec4 a_position;
    varying vec2 v_texcoord;
    void main() {
        gl_Position = a_position;
        v_texcoord = a_position.xy * 0.5 + 0.5;
    }
`;

export const postFXFragmentShaderSource = `
    precision highp float;
    varying vec2 v_texcoord;
    uniform sampler2D u_texture;
    void main() {
        gl_FragColor = texture2D(u_texture, v_texcoord);
    }
`;


// --- Main shader for all effects ---
export const vertexShaderSource = `
    attribute vec4 a_position;
    varying vec2 v_texcoord;

    void main() {
        gl_Position = a_position;
        v_texcoord = a_position.xy * 0.5 + 0.5;
    }
`;

export const fragmentShaderSource = `
    precision highp float;

    // Varyings
    varying vec2 v_texcoord;

    // Textures
    uniform sampler2D u_video_texture;
    uniform sampler2D u_feedback_texture;
    uniform sampler2D u_mask_texture;

    // Global Uniforms
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_mask_invert;
    uniform float u_mask_feather;
    uniform float u_mask_padding;

    // Effect Flags
    uniform bool u_RGBShift_active;
    uniform bool u_Displacement_active;
    uniform bool u_Pixelate_active;
    uniform bool u_Scanlines_active;
    uniform bool u_Feedback_active;

    // Effect-specific Uniforms
    uniform float u_rgb_amount;
    uniform float u_rgb_angle;
    uniform float u_noise_amount;
    uniform float u_noise_speed;
    uniform float u_pixel_size;
    uniform float u_scanline_density;
    uniform float u_scanline_opacity;
    uniform float u_feedback_amount;
    uniform float u_feedback_zoom;

    // --- Helper Functions ---
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    // --- Effect Functions ---
    vec4 applyRGBShift(sampler2D tex, vec2 uv, float amount, float angle) {
        vec2 dir = vec2(cos(angle), sin(angle));
        vec2 offset = dir * amount / u_resolution.x;
        float r = texture2D(tex, uv - offset).r;
        float g = texture2D(tex, uv).g;
        float b = texture2D(tex, uv + offset).b;
        return vec4(r, g, b, 1.0);
    }

    vec2 applyDisplacement(vec2 uv, float amount, float speed) {
        float noise_val = random(uv + u_time * speed) - 0.5;
        vec2 offset = vec2(noise_val) * amount / u_resolution.x;
        return uv + offset;
    }

    vec2 applyPixelate(vec2 uv, float size) {
        if (size <= 1.0) return uv;
        vec2 res_factor = u_resolution / size;
        return (floor(uv * res_factor) + 0.5) / res_factor;
    }

    vec4 applyScanlines(vec4 color, vec2 uv, float density, float opacity) {
        float y = uv.y * density;
        float line = fract(y) > 0.5 ? 1.0 : 1.0 - opacity;
        return color * line;
    }

    vec4 applyFeedback(vec4 current_color, vec2 uv, float amount, float zoom) {
        vec2 zoom_uv = (uv - 0.5) * (1.0 - zoom) + 0.5;
        vec4 feedback_color = texture2D(u_feedback_texture, zoom_uv);
        return mix(current_color, feedback_color, amount);
    }

    // --- Masking ---
    float getMaskValue(vec2 uv) {
        // Sample the mask texture. The mask is drawn white on black.
        float mask = texture2D(u_mask_texture, uv).r;
        
        // Apply feathering using smoothstep
        float feather_px = u_mask_feather / u_resolution.y;
        float padded_mask = mask - (u_mask_padding / 100.0);
        float feathered_mask = smoothstep(0.0, feather_px, padded_mask);

        // Invert if needed
        if (u_mask_invert > 0.5) {
            return 1.0 - feathered_mask;
        }
        return feathered_mask;
    }


    void main() {
        vec2 uv = v_texcoord;
        vec4 original_color = texture2D(u_video_texture, uv);

        // --- Effect Pipeline ---
        vec2 effected_uv = uv;

        // 1. UV manipulation effects
        if (u_Displacement_active) { effected_uv = applyDisplacement(effected_uv, u_noise_amount, u_noise_speed); }
        if (u_Pixelate_active) { effected_uv = applyPixelate(effected_uv, u_pixel_size); }

        // 2. Sample the texture with the (potentially modified) UVs
        vec4 effected_color = texture2D(u_video_texture, effected_uv);

        // 3. Color manipulation effects
        if (u_RGBShift_active) { effected_color = applyRGBShift(u_video_texture, effected_uv, u_rgb_amount, u_rgb_angle); }
        if (u_Scanlines_active) { effected_color = applyScanlines(effected_color, uv, u_scanline_density, u_scanline_opacity); }

        // 4. Feedback is applied last to the result of all other effects
        if (u_Feedback_active) { effected_color = applyFeedback(effected_color, uv, u_feedback_amount, u_feedback_zoom); }
        
        // --- Masking and Final Composition ---
        float mask = getMaskValue(v_texcoord);
        vec4 final_color = mix(original_color, effected_color, mask);

        gl_FragColor = final_color;
    }
`;
```javascript
// effects.js

// This module defines the properties of all available glitch effects,
// including their names and the uniforms they use.

export const globalUniformDefinitions = [
    { name: 'u_mask_invert', label: 'Invert Mask', type: 'bool', value: 0.0 },
    { name: 'u_mask_feather', label: 'Mask Feather', type: 'float', value: 5.0, min: 0.0, max: 50.0, step: 0.1 },
    { name: 'u_mask_padding', label: 'Mask Padding', type: 'float', value: 0.0, min: -50.0, max: 100.0, step: 1.0 }
];

export const effectDefinitions = {
    Feedback: {
        name: 'Feedback',
        label: 'Feedback',
        uniforms: [
            { name: 'u_feedback_amount', label: 'Amount', type: 'float', value: 0.85, min: 0.0, max: 0.99, step: 0.01 },
            { name: 'u_feedback_zoom', label: 'Zoom', type: 'float', value: 0.01, min: -0.1, max: 0.1, step: 0.001 }
        ]
    },
    RGBShift: {
        name: 'RGBShift',
        label: 'RGB Shift',
        uniforms: [
            { name: 'u_rgb_amount', label: 'Amount', type: 'float', value: 5.0, min: 0.0, max: 50.0, step: 0.1 },
            { name: 'u_rgb_angle', label: 'Angle', type: 'float', value: 0.0, min: 0.0, max: 6.28, step: 0.01 }
        ]
    },
    Displacement: {
        name: 'Displacement',
        label: 'Displacement',
        uniforms: [
            { name: 'u_noise_amount', label: 'Amount', type: 'float', value: 2.0, min: 0.0, max: 20.0, step: 0.1 },
            { name: 'u_noise_speed', label: 'Speed', type: 'float', value: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        ]
    },
    Pixelate: {
        name: 'Pixelate',
        label: 'Pixelate',
        uniforms: [
            { name: 'u_pixel_size', label: 'Pixel Size', type: 'float', value: 1.0, min: 1.0, max: 100.0, step: 1.0 }
        ]
    },
    Scanlines: {
        name: 'Scanlines',
        label: 'Scanlines',
        uniforms: [
            { name: 'u_scanline_density', label: 'Density', type: 'float', value: 800.0, min: 10.0, max: 2000.0, step: 10.0 },
            { name: 'u_scanline_opacity', label: 'Opacity', type: 'float', value: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        ]
    }
};
