<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Face Glitch V4.2 - Artist Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        :root{--bg:#0b0d11;--panel:#11141a;--stroke:#1f2430;--fg:#e5e7eb;--muted:#9aa0aa;--accent:#6ee7b7;--danger:#f87171;--primary-bg:#1a202c;--secondary-bg:#2d3748;--text-color:#f7fafc;--primary-color:#6ee7b7;--border-color:#4a5568;--shadow:0 10px 30px rgba(0,0,0,0.4);--radius-sm:8px;--radius-md:12px}
        *{box-sizing:border-box}html,body{height:100%;margin:0;font-family:'Poppins',sans-serif;background:var(--bg);color:var(--text-color)}
        body{display:flex;justify-content:center;align-items:center;padding:20px;background:radial-gradient(circle at center,#1a1f26 0%,#0d0f13 100%)}
        .container{display:flex;width:100%;max-width:1600px;height:90vh;border-radius:var(--radius-md);overflow:hidden;box-shadow:var(--shadow);background:var(--primary-bg);border:1px solid var(--border-color)}
        .main-stage{flex:2;position:relative;background:#0d0f13;display:flex;align-items:center;justify-content:center}
        #glcanvas,#video{width:100%;height:100%;display:block}
        #video{display:none}
        .controls-panel{flex:1;padding:24px;display:flex;flex-direction:column;overflow-y:auto;background:var(--secondary-bg)}
        .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;border-bottom:1px solid var(--border-color);padding-bottom:16px}
        h1{font-size:24px;font-weight:600;margin:0;letter-spacing:-.5px}
        .btn,select{padding:10px 20px;border:1px solid var(--border-color);border-radius:var(--radius-sm);background-color:transparent;color:var(--text-color);font-size:14px;cursor:pointer;transition:background-color .2s,border-color .2s;font-family:'Poppins',sans-serif;appearance:none;-webkit-appearance:none}
        .btn:hover:not(:disabled),select:hover{background-color:rgba(255,255,255,.1);border-color:var(--primary-color)}
        .btn:disabled{opacity:.5;cursor:not-allowed}
        .btn-primary{background-color:var(--primary-color);border-color:var(--primary-color);color:#1a1f26;font-weight:600}
        .btn-primary:hover:not(:disabled){background-color:#55d4a6;border-color:#55d4a6}
        .section-heading{font-size:16px;font-weight:600;margin:16px 0 8px;padding-bottom:8px;border-bottom:1px solid var(--border-color)}
        .effect-selector{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:16px}
        .effect-btn{background:var(--primary-bg);border:1px solid var(--border-color);color:var(--text-color);padding:8px 12px;border-radius:var(--radius-sm);cursor:pointer;transition:all .2s}
        .effect-btn:hover{border-color:var(--primary-color);background:rgba(110,231,183,.1)}
        .effect-btn.active-stack{border-color:var(--primary-color);background:rgba(110,231,183,.2);color:var(--primary-color);box-shadow:0 0 8px rgba(110,231,183,.5)}
        #activeEffectsList{font-size:12px;color:var(--muted);margin-bottom:16px;min-height:1.2em}
        .control-group{border:1px solid var(--border-color);border-radius:var(--radius-md);margin-bottom:16px;background:var(--primary-bg);display:none}
        .control-group.global,.control-group.active{display:block}
        .control-group-header{padding:12px 16px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;font-weight:600;transition:background-color .2s}
        .control-group-header:hover{background-color:rgba(255,255,255,.05)}
        .control-group-header::after{content:'−';font-size:1.2rem;transition:transform .2s}
        .control-group:not(.expanded) .control-group-header::after{content:'+'}
        .control-group-content{padding:12px 16px;border-top:1px solid var(--border-color)}
        .control-group:not(.expanded) .control-group-content{display:none}
        .control-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
        .control-item{display:flex;flex-direction:column;gap:6px}
        .slider-label{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-bottom:4px}
        .slider-input{width:100%;height:4px;border-radius:2px;background:var(--border-color);-webkit-appearance:none;appearance:none;outline:none}
        .slider-input::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:var(--primary-color);cursor:pointer;border:2px solid #0d0f13}
        .slider-input::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:var(--primary-color);cursor:pointer;border:2px solid #0d0f13}
        .options-list{display:flex;flex-direction:column;gap:10px;margin-top:16px}
        .options-list label{display:flex;align-items:center;gap:10px;font-size:14px;cursor:pointer}
        .options-list input[type="checkbox"]{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:18px;height:18px;border:1px solid var(--border-color);border-radius:4px;background:var(--primary-bg);cursor:pointer;position:relative}
        .options-list input[type="checkbox"]:checked{background-color:var(--primary-color);border-color:var(--primary-color)}
        .options-list input[type="checkbox"]:checked:after{content:'✓';color:#1a1f26;font-size:14px;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}
        .preset-management{display:flex;flex-direction:column;gap:12px}
        #presetName{width:100%;padding:10px;border-radius:var(--radius-sm);border:1px solid var(--border-color);background-color:var(--primary-bg);color:var(--text-color);font-family:'JetBrains Mono',monospace}
        .preset-buttons{display:flex;gap:8px}
        #presetSelect{flex-grow:1}
        .preset-buttons .btn-danger{border-color:var(--danger);color:var(--danger)}
        .preset-buttons .btn-danger:hover{background:rgba(248,113,113,.1)}
        .status-bar{margin-top:auto;padding-top:16px;border-top:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--muted)}
        .status-badge{background:var(--primary-bg);padding:4px 8px;border-radius:var(--radius-sm);border:1px solid var(--border-color);font-size:10px}
        .status-error{color:var(--danger)}
    </style>
</head>
<body>
    <div class="container">
        <div class="main-stage">
            <video id="video" playsinline muted></video>
            <canvas id="glcanvas" aria-label="camera with face effects"></canvas>
        </div>
        <div class="controls-panel">
            <div class="header">
                <h1>Glitch V4.2</h1>
                <div class="header-actions">
                    <button id="startBtn" class="btn btn-primary">Start Camera</button>
                    <button id="stopBtn" class="btn" disabled>Stop</button>
                </div>
            </div>

            <div class="section-heading">Effect Stack</div>
            <div class="effect-selector">
                <button class="effect-btn" data-effect="9" data-name="Data Mosh">Data Mosh</button>
                <button class="effect-btn" data-effect="5" data-name="Jitter Smear">Jitter Smear</button>
                <button class="effect-btn" data-effect="8" data-name="Noise Tear">Noise Tear</button>
                <button class="effect-btn" data-effect="0" data-name="Slice Glitch">Slice Glitch</button>
                <button class="effect-btn" data-effect="3" data-name="Pixel Decay">Pixel Decay</button>
            </div>
            <div id="activeEffectsList">Active: None</div>

            <div class="dynamic-controls">
                <div id="dataMoshControls" class="control-group expanded" data-effect="9">
                    <div class="control-group-header">Data Moshing</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item"><label class="slider-label">Decay (λ)<span id="moshDecayVal">0.85</span></label><input type="range" id="moshDecay" min="0" max="0.99" step="0.01" value="0.85" class="slider-input"></div>
                            <div class="control-item"><label class="slider-label">Block Size (p)<span id="moshBlockVal">8</span></label><input type="range" id="moshBlock" min="2" max="32" step="1" value="8" class="slider-input"></div>
                        </div>
                    </div>
                </div>

                <div id="smearControls" class="control-group expanded" data-effect="5">
                    <div class="control-group-header">Jitter Smear</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item"><label class="slider-label">Length<span id="smLenVal">20</span></label><input type="range" id="smLen" min="0" max="120" step="1" value="20" class="slider-input"></div>
                            <div class="control-item"><label class="slider-label">Angle<span id="smAngVal">0</span></label><input type="range" id="smAng" min="0" max="360" step="1" value="0" class="slider-input"></div>
                            <div class="control-item"><label class="slider-label">Samples<span id="samplesVal">8</span></label><input type="range" id="samples" min="1" max="32" step="1" value="8" class="slider-input"></div>
                        </div>
                        <div class="options-list"><label><input type="checkbox" id="smearJitter" checked> Jitter</label></div>
                    </div>
                </div>
                
                <div id="noiseFlowControls" class="control-group expanded" data-effect="8">
                    <div class="control-group-header">Noise Tear</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item"><label class="slider-label">Scale<span id="nScaleVal">4.0</span></label><input type="range" id="nScale" min="0.5" max="20" step="0.1" value="4" class="slider-input"></div>
                            <div class="control-item"><label class="slider-label">Strength<span id="nStrengthVal">10</span></label><input type="range" id="nStrength" min="0" max="60" step="1" value="10" class="slider-input"></div>
                            <div class="control-item" style="grid-column: 1 / -1;"><label class="slider-label">Tear Threshold<span id="nTearVal">0.80</span></label><input type="range" id="nTear" min="0" max="1" step="0.01" value="0.8" class="slider-input"></div>
                        </div>
                    </div>
                </div>

                <div id="glitchControls" class="control-group expanded" data-effect="0">
                    <div class="control-group-header">Slice Glitch</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item"><label class="slider-label">Slice Height<span id="sliceHeightVal">8</span></label><input type="range" id="sliceHeight" min="2" max="64" step="1" value="8" class="slider-input"></div>
                            <div class="control-item"><label class="slider-label">Slice Shift<span id="sliceShiftVal">20</span></label><input type="range" id="sliceShift" min="0" max="100" step="1" value="20" class="slider-input"></div>
                        </div>
                    </div>
                </div>

                <div id="pixelateControls" class="control-group expanded" data-effect="3">
                    <div class="control-group-header">Pixel Decay</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item"><label class="slider-label">Pixel Size<span id="pixelVal">10</span></label><input type="range" id="pixel" min="1" max="64" step="1" value="10" class="slider-input"></div>
                            <div class="control-item"><label class="slider-label">Randomness<span id="pixelRandVal">0.10</span></label><input type="range" id="pixelRand" min="0" max="1" step="0.01" value="0.1" class="slider-input"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="globalControls" class="control-group global expanded">
                <div class="control-group-header">Global & Mask Controls</div>
                <div class="control-group-content">
                    <div class="control-grid">
                        <div class="control-item"><label class="slider-label">Speed<span id="speedVal">1.50</span></label><input type="range" id="speed" min="0" max="5" step="0.01" value="1.5" class="slider-input"></div>
                        <div class="control-item"><label class="slider-label">Chroma Shift<span id="chromaVal">4</span></label><input type="range" id="chroma" min="0" max="20" step="1" value="4" class="slider-input"></div>
                        <div class="control-item"><label class="slider-label">Mix (Opacity)<span id="mixVal">1.00</span></label><input type="range" id="mix" min="0" max="1" step="0.01" value="1" class="slider-input"></div>
                        <div class="control-item"><label class="slider-label">Feather<span id="featherVal">0.050</span></label><input type="range" id="feather" min="0" max="0.2" step="0.005" value="0.05" class="slider-input"></div>
                        <div class="control-item"><label class="slider-label">Mask Padding<span id="padVal">16</span></label><input type="range" id="pad" min="0" max="120" step="1" value="16" class="slider-input"></div>
                        <div class="control-item"><label class="slider-label">Seed<span id="seedVal">7</span></label><input type="range" id="seed" min="0" max="100" step="1" value="7" class="slider-input"></div>
                    </div>
                    <div class="options-list">
                        <label><input type="checkbox" id="mirrorChk" checked> Mirror Camera</label>
                        <label><input type="checkbox" id="animateChk" checked> Animate Effects</label>
                        <label><input type="checkbox" id="trackCenterChk" checked> Track Center of Face</label>
                        <label><input type="checkbox" id="preciseMaskChk"> Precise Face Mesh Mask</label>
                        <label><input type="checkbox" id="invert"> Invert Mask</label>
                    </div>
                </div>
            </div>
            
             <div id="userPresets" class="control-group global expanded">
                <div class="control-group-header">My Presets</div>
                <div class="control-group-content preset-management">
                    <input type="text" id="presetName" placeholder="Enter preset name...">
                    <div class="preset-buttons">
                        <select id="presetSelect" class="btn"><option value="">Load a preset...</option></select>
                        <button id="savePresetBtn" class="btn btn-primary">Save</button>
                        <button id="deletePresetBtn" class="btn btn-danger">Del</button>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <span id="msg" class="status-error"></span>
                <span id="status2" class="status-badge">Idle</span>
            </div>
        </div>
    </div>
<script>
(() => {
    // --- ELEMENT HOOKS & UI STATE ---
    const video = document.getElementById('video');
    const canvas = document.getElementById('glcanvas');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const mirrorChk = document.getElementById('mirrorChk');
    const animateChk = document.getElementById('animateChk');
    const trackCenterChk = document.getElementById('trackCenterChk');
    const preciseMaskChk = document.getElementById('preciseMaskChk');
    const status2El = document.getElementById('status2');
    const msgEl = document.getElementById('msg');
    const invertChk = document.getElementById('invert');
    const effectBtns = document.querySelectorAll('.effect-btn');
    const activeEffectsListEl = document.getElementById('activeEffectsList');

    let activeEffects = [];
    const PRESET_STORAGE_KEY = 'faceGlitchV4Presets';

    function hook(id, outId) {
        const el = document.getElementById(id);
        if (!el) { console.error(`Missing element: ${id}`); return null; }
        el.dataset.controlId = id;
        const out = document.getElementById(outId);
        const set = () => { if (out) out.textContent = parseFloat(el.value).toFixed(el.step < 1 ? 3 : 0); };
        el.addEventListener('input', set);
        set();
        return el;
    }

    const ui = {
        speed: hook('speed', 'speedVal'), chroma: hook('chroma', 'chromaVal'), mix: hook('mix', 'mixVal'),
        feather: hook('feather', 'featherVal'), pad: hook('pad', 'padVal'), seed: hook('seed', 'seedVal'),
        moshDecay: hook('moshDecay', 'moshDecayVal'), moshBlock: hook('moshBlock', 'moshBlockVal'),
        smLen: hook('smLen', 'smLenVal'), smAng: hook('smAng', 'smAngVal'), samples: hook('samples', 'samplesVal'),
        smearJitter: document.getElementById('smearJitter'),
        nScale: hook('nScale', 'nScaleVal'), nStrength: hook('nStrength', 'nStrengthVal'), nTear: hook('nTear', 'nTearVal'),
        sliceHeight: hook('sliceHeight', 'sliceHeightVal'), sliceShift: hook('sliceShift', 'sliceShiftVal'),
        pixel: hook('pixel', 'pixelVal'), pixelRand: hook('pixelRand', 'pixelRandVal'),
    };
    [mirrorChk, animateChk, trackCenterChk, preciseMaskChk, invertChk, ui.smearJitter].forEach(el => {
        if(el) el.dataset.controlId = el.id;
    });

    // --- CORE APP STATE ---
    let stream = null, rafId = null, detector = null, gl = null, program = null, tex = null, maskTex = null;
    let effectCenter = { x: 0.5, y: 0.5 }, faceRects = new Float32Array(5 * 4);
    let faceMesh = null, faceMeshReady = false;
    const maskCanvas = document.createElement('canvas'), maskCtx = maskCanvas.getContext('2d');
    
    // --- PING-PONG FRAMEBUFFERS FOR DATA MOSHING ---
    let fbos = [], textures = [], currentFBO = 0;

    // --- GLSL SHADERS V4.2 ---
    const vertSrc = `attribute vec2 a_pos; varying vec2 v_uv; void main(){ gl_Position = vec4(2.0 * a_pos - 1.0, 0.0, 1.0); v_uv = a_pos; }`;
    const fragSrc = `
        precision highp float;
        varying vec2 v_uv;
        uniform sampler2D u_tex, u_maskTex, u_prevFrame;
        uniform vec2 u_resolution, u_center;
        uniform float u_time, u_speed, u_chroma, u_mix, u_feather, u_seed;
        uniform bool u_enableDataMosh, u_enableJitterSmear, u_enableNoiseTear, u_enableSliceGlitch, u_enablePixelDecay;
        uniform float u_moshDecay, u_moshBlock, u_smLen, u_smAng;
        uniform int u_samples;
        uniform bool u_smearJitter;
        uniform float u_nScale, u_nStrength, u_nTear;
        uniform float u_sliceHeight, u_sliceShift;
        uniform float u_pixel, u_pixelRand;
        uniform bool u_maskMode, u_invert;
        uniform int u_faceCount; uniform vec4 u_faces[5];
        
        float hash(float n) { return fract(sin(n)*43758.5453); }
        vec2 hash2(float n) { return fract(sin(vec2(n, n + 1.0)) * vec2(43758.5453, 22578.1459)); }
        float rand(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }

        vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
        float snoise(vec2 v) {
            const vec4 C = vec4(0.2113248654, 0.3660254038, -0.5773502692, 0.0243902439);
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
            m = m*m; m = m*m;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
            vec3 g;
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

        vec2 get_displacement(vec2 uv) {
            vec2 total_disp = vec2(0.0);
            float t = u_time * u_speed;
            if (u_enableJitterSmear) {
                float ang = radians(u_smAng);
                float len = u_smLen;
                if (u_smearJitter) {
                    ang += (hash(t) - 0.5) * 2.0;
                    len *= (0.5 + hash(t + 0.5));
                }
                total_disp += vec2(cos(ang), sin(ang)) * len / u_resolution;
            }
            if (u_enableNoiseTear) {
                float n = snoise((uv + t * 0.1) * u_nScale);
                float displacement_mult = (n > u_nTear) ? 10.0 : 1.0;
                total_disp += (vec2(n, snoise(uv * u_nScale)) * u_nStrength / u_resolution) * displacement_mult;
            }
            if (u_enableSliceGlitch) {
                float row = floor(uv.y * u_sliceHeight);
                float shift = (hash(row + floor(t * 10.0)) - 0.5) * u_sliceShift / u_resolution.x;
                total_disp.x += shift;
            }
            return total_disp;
        }

        vec4 apply_post_effects(vec4 color, vec2 uv, vec2 disp_uv) {
            if (u_enablePixelDecay) {
                float size = max(1.0, u_pixel);
                vec2 pix_uv = (floor(disp_uv * u_resolution / size) + 0.5) / (u_resolution / size);
                vec4 pix_col = texture2D(u_tex, pix_uv);
                if (rand(uv + u_time) < u_pixelRand) {
                   pix_col = texture2D(u_tex, hash2(uv.y + u_time));
                }
                color = pix_col;
            }
            if (u_enableDataMosh) {
                vec2 block_uv = floor(uv * u_moshBlock) / u_moshBlock;
                vec4 prev = texture2D(u_prevFrame, block_uv);
                color = mix(color, prev, u_moshDecay);
            }
            if (u_chroma > 0.1) {
                float c = u_chroma / u_resolution.x;
                color.r = texture2D(u_tex, disp_uv + vec2(c, 0.)).r;
                color.b = texture2D(u_tex, disp_uv - vec2(c, 0.)).b;
            }
            return color;
        }

        float getFaceMask(vec2 uv) {
            float a;
            if (u_maskMode) {
                float r = u_feather / 2.0;
                a = smoothstep(0.5 - r, 0.5 + r, texture2D(u_maskTex, uv).r);
            } else {
                a = 0.0;
                for (int i = 0; i < 5; ++i) {
                    if (i >= u_faceCount) break;
                    vec4 r = u_faces[i];
                    vec2 c = r.xy + r.zw * 0.5;
                    vec2 p_norm = abs(uv - c) / r.zw;
                    float d = length(max(p_norm - 0.5, 0.0));
                    a = max(a, 1.0 - smoothstep(0.0, u_feather, d));
                }
            }
            return u_invert ? 1.0 - a : a;
        }

        void main() {
            vec4 base_color = texture2D(u_tex, v_uv);
            vec2 displacement = get_displacement(v_uv);
            vec2 displaced_uv = v_uv + displacement;
            
            vec4 effected_color = texture2D(u_tex, displaced_uv);
            effected_color = apply_post_effects(effected_color, v_uv, displaced_uv);
            
            float mask = getFaceMask(v_uv + displacement);
            
            gl_FragColor = mix(base_color, effected_color, mask * u_mix);
        }
    `;
    
    function setStatus(text){ status2El.textContent = text; }
    function setMsg(text, isError=false){ msgEl.textContent = text || ''; msgEl.classList.toggle('status-error', isError); }
    
    // --- GL & FBO INITIALIZATION ---
    function createFBO(width, height) {
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return { fbo, tex };
    }

    function setupFBOs(width, height) {
        textures = [createFBO(width, height), createFBO(width, height)];
        fbos = [textures[0].fbo, textures[1].fbo];
    }
    
    function fit(){ if(!video.videoWidth) return; const w=video.videoWidth,h=video.videoHeight; canvas.width=w; canvas.height=h; maskCanvas.width=w; maskCanvas.height=h; if(gl){gl.viewport(0,0,w,h); setupFBOs(w,h);} }
    function createGL(){
        gl = canvas.getContext('webgl'); if(!gl) throw new Error('WebGL not available');
        const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vertSrc); gl.compileShader(vs);
        const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fragSrc); gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) { setMsg("Shader Error: " + gl.getShaderInfoLog(fs), true); throw new Error("Shader fail"); }
        program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
        const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, 'a_pos');
        gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        
        // ** FIX: Restore correct global flip state for video textures **
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        
        tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        maskTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, maskTex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    
    // --- CORE LOGIC ---
    async function start(){
        if(!navigator.mediaDevices?.getUserMedia) return setMsg('getUserMedia not supported.', true);
        try {
            setStatus('Starting...');
            stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}});
            video.srcObject = stream; await video.play();
            await new Promise(res => video.onplaying = res);
            createGL(); fit(); window.onresize = fit;
            if ('FaceDetector' in window) detector = new FaceDetector({fastMode:true});
            await ensureFaceMesh();
            startBtn.disabled = true; stopBtn.disabled = false;
            rafId = requestAnimationFrame(loop);
        } catch(err){ setMsg('Camera error: ' + err.message, true); }
    }
    function stop(){ cancelAnimationFrame(rafId); if(stream) stream.getTracks().forEach(t=>t.stop()); startBtn.disabled=false; stopBtn.disabled=true; setStatus('Stopped'); }
    
    function setUniforms(time) {
        gl.useProgram(program);
        const U = (name, val, type) => {
            const loc = gl.getUniformLocation(program, `u_${name}`);
            if(!loc) return;
            if (type === 'f') gl.uniform1f(loc, val);
            else if (type === 'i') gl.uniform1i(loc, val);
            else if (type === 'b') gl.uniform1i(loc, val ? 1 : 0);
            else if (type === 'v2') gl.uniform2f(loc, val.x, val.y);
        };
        U('resolution', {x: gl.drawingBufferWidth, y: gl.drawingBufferHeight}, 'v2');
        U('time', time, 'f'); U('center', effectCenter, 'v2');
        Object.keys(ui).forEach(key => {
            const el = ui[key];
            if (el.type === 'checkbox') U(key, el.checked, 'b');
            else U(key, parseFloat(el.value), 'f');
        });
        
        ['DataMosh', 'JitterSmear', 'NoiseTear', 'SliceGlitch', 'PixelDecay'].forEach(name => U('enable' + name, false, 'b'));
        activeEffects.forEach(id => {
            const name = document.querySelector(`.effect-btn[data-effect="${id}"]`).dataset.name;
            const uniformName = 'enable' + name.replace(/\s/g, '');
            U(uniformName, true, 'b');
        });

        U('maskMode', preciseMaskChk.checked, 'b');
        U('invert', invertChk.checked, 'b');
        U('faceCount', faceRects.filter((_, i) => i % 4 === 2 && _ > 0).length, 'i');
        gl.uniform4fv(gl.getUniformLocation(program, 'u_faces'), faceRects);
    }

    async function updateFaceData() {
        let center = { x: 0.5, y: 0.5 };
        let hasFace = false;
        if (preciseMaskChk.checked && faceMeshReady) {
            const faces = await faceMesh.send({ image: video });
            if (faces && faces.multiFaceLandmarks && faces.multiFaceLandmarks.length > 0) {
                const landmarks = faces.multiFaceLandmarks[0];
                const W = maskCanvas.width, H = maskCanvas.height;
                maskCtx.clearRect(0,0,W,H); maskCtx.fillStyle='#fff'; maskCtx.beginPath();
                const p0 = landmarks[FACE_OVAL[0]]; maskCtx.moveTo(p0.x*W, p0.y*H);
                for(let i=1;i<FACE_OVAL.length;i++){const p=landmarks[FACE_OVAL[i]]; maskCtx.lineTo(p.x*W, p.y*H);}
                maskCtx.closePath(); maskCtx.fill();
                gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);
                const avgX = landmarks.reduce((s,p)=>s+p.x,0)/landmarks.length;
                const avgY = landmarks.reduce((s,p)=>s+p.y,0)/landmarks.length;
                center = { x: avgX, y: avgY }; hasFace = true;
            }
        } else if (detector) {
            const faces = await detector.detect(video);
            if (faces.length > 0) {
                const bb = faces[0].boundingBox;
                const W = video.videoWidth, H = video.videoHeight;
                const grow = parseFloat(ui.pad.value);
                const r = { x:bb.x-grow, y:bb.y-grow, w:bb.width+2*grow, h:bb.height+2*grow };
                faceRects.set([r.x/W, r.y/H, r.w/W, r.h/H], 0);
                center = { x: (bb.x + bb.width/2)/W, y: (bb.y + bb.height/2)/H }; hasFace = true;
            } else { faceRects[2] = 0; }
        }
        if (trackCenterChk.checked && hasFace) {
            let finalX = center.x;
            let finalY = 1.0 - center.y;
            if (mirrorChk.checked) {
                finalX = 1.0 - finalX;
            }
            effectCenter = { x: finalX, y: finalY };
        } else if (!trackCenterChk.checked) {
            effectCenter = { x: 0.5, y: 0.5 };
        }
    }

    function loop(time) {
        raf
