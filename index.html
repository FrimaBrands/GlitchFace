<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // CONTROLS</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body { 
        font-family: 'JetBrains Mono', monospace; 
        background-color: #0a0a0a;
        color: #EAEAEA;
    }
    .custom-scrollbar::-webkit-scrollbar { width: 4px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #666; }
    input[type="range"] {
        -webkit-appearance: none; appearance: none;
        width: 100%; height: 2px;
        background: #333;
        outline: none;
        transition: background .3s;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        width: 14px; height: 14px;
        background: #EAEAEA;
        cursor: pointer;
        border: none;
        border-radius: 0;
    }
    input[type="range"]::-moz-range-thumb {
        width: 14px; height: 14px;
        background: #EAEAEA;
        cursor: pointer;
        border: none;
        border-radius: 0;
    }
    .status-indicator::after {
        content: '■';
        display: inline-block;
        margin-left: 6px;
        animation: blink 0.7s step-end infinite;
        color: #00ff00;
    }
    @keyframes blink { 
        0%, 100% { opacity: 1; }
        50% { opacity: 0; } 
    }
    .status-indicator.error::after {
        color: #ff0000;
    }
    .tab-button {
        border-color: #333;
        transition: all 0.2s ease-in-out;
    }
    .tab-button.active {
        border-color: #EAEAEA;
        color: #FFFFFF;
        background-color: #1a1a1a;
    }
    .btn {
        border: 1px solid #555;
        transition: all 0.2s ease-in-out;
    }
    .btn:hover {
        background-color: #EAEAEA;
        color: #000;
        border-color: #EAEAEA;
    }
    .btn:disabled {
        opacity: 0.4;
        pointer-events: none;
    }
    .btn-primary {
        background-color: #EAEAEA;
        color: #000;
        border-color: #EAEAEA;
    }
    .btn-primary:hover {
        background-color: #000;
        color: #EAEAEA;
    }
    .form-checkbox {
        appearance: none;
        -webkit-appearance: none;
        height: 14px;
        width: 14px;
        background-color: transparent;
        border: 1px solid #555;
        cursor: pointer;
        display: inline-block;
        position: relative;
    }
    .form-checkbox:checked {
        background-color: #EAEAEA;
    }
  </style>
</head>
<body class="p-4">

  <div class="controls-panel w-full max-w-md mx-auto bg-[#0a0a0a] border border-gray-800 flex flex-col h-[95vh]">
    
    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h1 class="text-xl font-bold text-white tracking-widest">U N K N O W N</h1>
      <p class="text-sm text-gray-400 font-mono">// SIGNAL PROCESSOR</p>
      <div class="grid grid-cols-2 gap-2 mt-4">
        <button id="launchPreviewBtn" class="col-span-2 btn btn-primary font-bold py-2 px-4">Launch Preview Window</button>
        <button id="startBtn" class="flex-1 btn font-bold py-2 px-4">Initialize</button>
        <button id="stopBtn" class="flex-1 btn font-bold py-2 px-4">Terminate</button>
      </div>
      <div id="msg" class="text-red-400 font-mono text-xs mt-2 h-4"></div>
      <div id="statusBar" class="font-mono text-xs status-indicator mt-2">
        STATUS: AWAITING PREVIEW
      </div>
    </div>

    <div class="p-4 border-b border-gray-800 flex-shrink-0">
      <h2 class="font-bold text-gray-300 mb-2">// PRESET_MANAGER</h2>
      <select id="presetList" class="w-full bg-black border border-gray-700 p-2 mb-2 text-sm focus:outline-none focus:border-gray-400"></select>
      <div class="grid grid-cols-3 gap-2">
        <input type="text" id="presetName" placeholder="> Preset Name..." class="col-span-3 bg-black border border-gray-700 p-2 text-sm focus:outline-none focus:border-gray-400">
        <button id="savePresetBtn" class="btn font-semibold py-1 text-sm">Save</button>
        <button id="deletePresetBtn" class="btn font-semibold py-1 text-sm">Delete</button>
        <button id="randomBtn" class="btn font-semibold py-1 text-sm">Randomize</button>
      </div>
    </div>
    
    <div class="flex border-b border-gray-800 flex-shrink-0">
      <button id="globalsTabBtn" class="tab-button active flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 text-gray-400 hover:text-white">Globals</button>
      <button id="effectsTabBtn" class="tab-button flex-1 py-2 px-4 text-sm font-semibold text-center border-b-2 border-transparent text-gray-400 hover:text-white">Effects</button>
    </div>

    <div class="flex-grow custom-scrollbar overflow-y-auto">
      <div id="effects-tab-content" class="hidden p-4 space-y-4">
        </div>
      <div id="globals-tab-content" class="p-4 space-y-4">
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// REMOTE_TRIGGER</h3>
          <p class="text-xs text-gray-500 mb-3">Enable guest phone to trigger a 5s canvas recording.</p>
          <div class="space-y-3">
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">ARM REMOTE</span>
              <input type="checkbox" id="remoteEnable" class="form-checkbox">
            </label>
            <div class="grid grid-cols-2 gap-2">
              <button id="remoteShowQR" class="btn font-semibold py-2 text-sm" disabled>Open QR</button>
              <button id="remoteReset" class="btn font-semibold py-2 text-sm" disabled>Reset</button>
            </div>
            <div id="remoteStatus" class="text-xs font-mono text-green-400">REMOTE: idle</div>
          </div>
        </div>

        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// BACKGROUND_SOURCE</h3>
          <div class="space-y-3">
              <button id="bgUploadBtn" class="w-full btn font-semibold py-2 text-sm">Upload Image/Video</button>
              <input type="file" id="bgUpload" accept="image/*,video/*" class="hidden">
              <label class="flex items-center justify-between text-sm cursor-pointer">
                  <span class="text-gray-400">USE CUSTOM BG</span>
                  <input type="checkbox" id="useBgChk" class="form-checkbox" disabled>
              </label>
              <div class="control-item space-y-2">
                  <div class="flex justify-between items-center">
                      <label for="maskFeather" class="text-sm font-medium text-gray-300">MASK FEATHER</label>
                      <span id="maskFeatherValue" class="text-sm font-mono text-gray-400">0.150</span>
                  </div>
                  <input type="range" id="maskFeather" min="0.01" max="0.5" step="0.001" value="0.15">
              </div>
          </div>
        </div>
        
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// SYSTEM_SETTINGS</h3>
          <div class="space-y-3">
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">ANIMATE EFFECTS</span>
              <input type="checkbox" id="animateChk" class="form-checkbox" checked>
            </label>
            <label class="flex items-center justify-between text-sm cursor-pointer">
              <span class="text-gray-400">MIRROR CAMERA</span>
              <input type="checkbox" id="mirrorChk" class="form-checkbox" checked>
            </label>
          </div>
        </div>
        
        <div class="control-group bg-black/50 border border-gray-800 p-3">
          <h3 class="font-semibold text-gray-200 mb-3">// AUTOMATION_MODULE</h3>
          <div class="control-item space-y-2">
            <div class="flex justify-between items-center">
              <label for="autoRandomizeSlider" class="text-sm font-medium text-gray-300">AUTO-RANDOMIZE</label>
              <span id="autoRandomizeValue" class="text-sm font-mono text-gray-400">1.0s</span>
            </div>
            <input type="range" id="autoRandomizeSlider" min="0" max="30" step="0.5" value="1">
          </div>
          <div class="control-item space-y-2 mt-3">
            <div class="flex justify-between items-center">
              <label for="presetIterationSlider" class="text-sm font-medium text-gray-300">PRESET-ITERATION</label>
              <span id="presetIterationValue" class="text-sm font-mono text-gray-400">Off</span>
            </div>
            <input type="range" id="presetIterationSlider" min="0" max="30" step="0.5" value="0">
          </div>
        </div>
      </div>
    </div>
  </div>
  
<script>
(() => {
    // Communication channel to the preview window
    const channel = new BroadcastChannel('unknown_signal_processor');
    let previewWindow = null;
    let autoRandomizeIntervalId = null;
    let presetIterationIntervalId = null;

    const UI = {
      elements: {},
      state: { ui: {}, jitter: {} },
      globalState: { ui: {} },
      definitions: {},
      globalDefinitions: {},

      init(definitions, globalDefinitions) {
        this.definitions = definitions;
        this.globalDefinitions = globalDefinitions;
        const ids = ['video', 'glcanvas', 'startBtn', 'stopBtn', 'statusBar', 'msg', 'savePresetBtn', 'deletePresetBtn', 'presetName', 'presetList', 'randomBtn', 'animateChk', 'mirrorChk', 'backgroundMedia', 'backgroundImage', 'bgUploadBtn', 'bgUpload', 'useBgChk', 'maskFeather', 'maskFeatherValue', 'effectsTabBtn', 'globalsTabBtn', 'effects-tab-content', 'globals-tab-content', 'autoRandomizeSlider', 'autoRandomizeValue', 'presetIterationSlider', 'presetIterationValue', 'launchPreviewBtn'];
        ids.forEach(id => {
            const el = document.getElementById(id);
            if (el) this.elements[id] = el;
        });
        
        for (const [key, definition] of Object.entries(this.definitions)) {
          this.createControlGroup(key, definition, this.state, this.elements['effects-tab-content'], true);
        }
        for (const [key, definition] of Object.entries(this.globalDefinitions)) {
            this.createControlGroup(key, definition, this.globalState, this.elements['globals-tab-content'], false);
        }

        this.elements.effectsTabBtn.addEventListener('click', () => this.switchTab('effects'));
        this.elements.globalsTabBtn.addEventListener('click', () => this.switchTab('globals'));
        this.elements.bgUploadBtn.addEventListener('click', () => this.elements.bgUpload.click());
        this.elements.maskFeather.addEventListener('input', () => {
            this.elements.maskFeatherValue.textContent = parseFloat(this.elements.maskFeather.value).toFixed(3);
        });
        this.elements.autoRandomizeSlider.addEventListener('input', () => {
            const val = parseFloat(this.elements.autoRandomizeSlider.value);
            this.elements.autoRandomizeValue.textContent = val === 0 ? 'Off' : `${val.toFixed(1)}s`;
        });
        this.elements.presetIterationSlider.addEventListener('input', () => {
            const val = parseFloat(this.elements.presetIterationSlider.value);
            this.elements.presetIterationValue.textContent = val === 0 ? 'Off' : `${val.toFixed(1)}s`;
        });
      },
      switchTab(tabName) {
        if (tabName === 'effects') {
            this.elements.effectsTabBtn.classList.add('active');
            this.elements.globalsTabBtn.classList.remove('active');
            this.elements['effects-tab-content'].classList.remove('hidden');
            this.elements['globals-tab-content'].classList.add('hidden');
        } else {
            this.elements.effectsTabBtn.classList.remove('active');
            this.elements.globalsTabBtn.classList.add('active');
            this.elements['effects-tab-content'].classList.add('hidden');
            this.elements['globals-tab-content'].classList.remove('hidden');
        }
      },
      createControlGroup(key, definition, stateObject, parentElement, withToggle) {
        const group = document.createElement('div');
        group.className = 'control-group bg-black/50 border border-gray-800 p-3';
        const header = document.createElement('div');
        header.className = 'flex items-center justify-between';
        const title = document.createElement('h3');
        title.className = 'font-semibold text-gray-200';
        title.textContent = `// ${definition.title.toUpperCase()}`;
        header.appendChild(title);
        const content = document.createElement('div');
        content.className = 'mt-3 space-y-3';
        if (withToggle) {
            header.classList.add('cursor-pointer');
            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.checked = definition.active;
            toggle.className = 'form-checkbox';
            if (!definition.active) content.classList.add('hidden');
            toggle.addEventListener('change', () => {
              definition.active = toggle.checked;
            });
            header.addEventListener('click', (e) => {
                if(e.target !== toggle) {
                    toggle.checked = !toggle.checked;
                    toggle.dispatchEvent(new Event('change'));
                }
                content.classList.toggle('hidden', !toggle.checked);
            });
            definition.toggleElement = toggle;
            header.appendChild(toggle);
        }
        stateObject.ui[key] = {};
        if (stateObject.jitter) {
            stateObject.jitter[key] = {};
        }
        for (const [controlKey, controlDef] of Object.entries(definition.controls)) {
          const slider = this.createSlider(controlKey, controlDef);
          content.appendChild(slider.container);
          stateObject.ui[key][controlKey] = slider.input;
          if (stateObject.jitter) {
              stateObject.jitter[key][controlKey] = { base: controlDef.value, current: controlDef.value };
              slider.input.addEventListener('input', () => {
                stateObject.jitter[key][controlKey].base = parseFloat(slider.input.value);
              });
          }
        }
        group.append(header, content);
        parentElement.appendChild(group);
      },
      createSlider(id, def) {
        const container = document.createElement('div');
        container.className = 'control-item space-y-2';
        const labelContainer = document.createElement('div');
        labelContainer.className = 'flex justify-between items-center';
        const label = document.createElement('label');
        label.className = 'text-sm font-medium text-gray-300';
        label.textContent = def.label.toUpperCase();
        const valueSpan = document.createElement('span');
        valueSpan.className = 'text-sm font-mono text-gray-400';
        const input = document.createElement('input');
        input.type = 'range';
        Object.assign(input, { min: def.min, max: def.max, step: def.step, value: def.value });
        const updateValue = () => valueSpan.textContent = parseFloat(input.value).toFixed(String(def.step).includes('.') ? 3 : 0);
        input.addEventListener('input', updateValue);
        updateValue();
        labelContainer.append(label, valueSpan);
        container.append(labelContainer, input);
        return { container, input };
      },
      setStatus(text, isError = false) {
        this.elements.statusBar.textContent = `STATUS: ${text}`;
        this.elements.statusBar.classList.toggle('error', isError);
      },
      setMsg(text) { this.elements.msg.textContent = text; }
    };

    const PresetManager = {
      init() {
        this.populateList();
        UI.elements.savePresetBtn.addEventListener('click', () => this.save());
        UI.elements.deletePresetBtn.addEventListener('click', () => this.delete());
        UI.elements.presetList.addEventListener('change', () => this.load());
        UI.elements.randomBtn.addEventListener('click', () => this.randomize());
      },
      getPresets: () => JSON.parse(localStorage.getItem('bodyGlitchV5.0Presets') || '{}'),
      savePresets: (p) => localStorage.setItem('bodyGlitchV5.0Presets', JSON.stringify(p)),
      getAppState() {
        const state = { controls: {}, toggles: {}, checkboxes: {}, globalControls: {}, misc: {} };
        for (const [groupKey, group] of Object.entries(UI.state.ui)) {
          state.controls[groupKey] = {};
          state.toggles[groupKey] = UI.definitions[groupKey].active;
          for (const [controlKey, control] of Object.entries(group)) {
            state.controls[groupKey][controlKey] = control.value;
          }
        }
        for (const [groupKey, group] of Object.entries(UI.globalState.ui)) {
            state.globalControls[groupKey] = {};
            for (const [controlKey, control] of Object.entries(group)) {
                state.globalControls[groupKey][controlKey] = control.value;
            }
        }
        state.checkboxes = { 
            animateChk: UI.elements.animateChk.checked, 
            mirrorChk: UI.elements.mirrorChk.checked,
            useBgChk: UI.elements.useBgChk.checked
        };
        state.misc = {
            maskFeather: UI.elements.maskFeather.value,
        };
        return state;
      },
      setAppState(state) {
        if (!state) return;
        if (state.controls) {
          for (const [groupKey, group] of Object.entries(state.controls)) {
            if (UI.state.ui[groupKey]) {
              for (const [controlKey, value] of Object.entries(group)) {
                const el = UI.state.ui[groupKey][controlKey];
                if (el) {
                  el.value = value;
                  el.dispatchEvent(new Event('input'));
                  if (UI.state.jitter[groupKey]?.[controlKey]) UI.state.jitter[groupKey][controlKey].base = parseFloat(el.value);
                }
              }
            }
          }
        }
        if (state.toggles) {
          for (const [groupKey, isChecked] of Object.entries(state.toggles)) {
            const def = UI.definitions[groupKey];
            if (def && def.toggleElement) {
              def.toggleElement.checked = isChecked;
              def.toggleElement.dispatchEvent(new Event('change'));
            }
          }
        }
        if (state.globalControls) {
            for (const [groupKey, group] of Object.entries(state.globalControls)) {
                if (UI.globalState.ui[groupKey]) {
                    for (const [controlKey, value] of Object.entries(group)) {
                        const el = UI.globalState.ui[groupKey][controlKey];
                        if (el) {
                            el.value = value;
                            el.dispatchEvent(new Event('input'));
                        }
                    }
                }
            }
        }
        if (state.checkboxes) {
          UI.elements.animateChk.checked = state.checkboxes.animateChk ?? true;
          UI.elements.mirrorChk.checked  = state.checkboxes.mirrorChk ?? true;
          UI.elements.useBgChk.checked = state.checkboxes.useBgChk ?? false;
        }
        if (state.misc) {
            const featherSlider = UI.elements.maskFeather;
            if (featherSlider) {
                featherSlider.value = state.misc.maskFeather ?? '0.15';
                featherSlider.dispatchEvent(new Event('input'));
            }
        }
      },
      populateList() {
        const presets = this.getPresets();
        const { presetList } = UI.elements;
        const currentVal = presetList.value;
        presetList.innerHTML = '<option value="">-- LOAD PRESET --</option>';
        for (const name in presets) {
          const opt = document.createElement('option');
          opt.value = name; opt.textContent = name; presetList.appendChild(opt);
        }
        presetList.value = currentVal;
      },
      save() {
        const { presetName } = UI.elements;
        const name = presetName.value.trim();
        if (!name) return UI.setMsg('Enter a preset name.');
        const presets = this.getPresets();
        presets[name] = this.getAppState();
        this.savePresets(presets);
        this.populateList();
        UI.elements.presetList.value = name;
        UI.setMsg(`Preset '${name}' saved.`);
      },
      delete() {
        const { presetList, presetName } = UI.elements;
        const name = presetList.value;
        if (!name) return UI.setMsg('Select a preset to delete.');
        const presets = this.getPresets();
        delete presets[name];
        this.savePresets(presets);
        this.populateList();
        presetName.value = '';
        UI.setMsg(`Preset '${name}' deleted.`);
      },
      load(name) {
        const { presetList, presetName } = UI.elements;
        const presetToLoad = name || presetList.value;
        if (!presetToLoad) return;
        const presets = this.getPresets();
        if (presets[presetToLoad]) {
          this.setAppState(presets[presetToLoad]);
          presetName.value = presetToLoad;
          presetList.value = presetToLoad;
          UI.setMsg(`Preset '${presetToLoad}' loaded.`);
        }
      },
      randomize() {
        for (const groupKey in UI.state.ui) {
          const def = UI.definitions[groupKey];
          if(def && def.toggleElement){
            def.toggleElement.checked = Math.random() > 0.3;
            def.toggleElement.dispatchEvent(new Event('change'));
          }
          for (const controlKey in UI.state.ui[groupKey]) {
            const el = UI.state.ui[groupKey][controlKey];
            const min = parseFloat(el.min), max = parseFloat(el.max), step = parseFloat(el.step);
            el.value = Math.round((min + Math.random() * (max - min)) / step) * step;
            el.dispatchEvent(new Event('input'));
          }
        }
        UI.setMsg('Parameters randomized!');
      }
    };
    
    const Controller = {
      currentPresetIndex: 0,
      init(definitions, globalDefinitions) {
        UI.init(definitions, globalDefinitions);
        PresetManager.init();

        UI.elements.launchPreviewBtn.addEventListener('click', () => {
          previewWindow = window.open('preview.html', 'UnknownPreview', 'width=1280,height=720,noopener,noreferrer');
          UI.setStatus('Preview launched. Press Initialize.');
        });
        
        UI.elements.startBtn.addEventListener('click', () => {
          channel.postMessage({ type: 'START' });
          UI.setStatus('Initialize signal sent.');
        });
        
        UI.elements.stopBtn.addEventListener('click', () => {
          channel.postMessage({ type: 'STOP' });
          this.stopAutomation();
          UI.setStatus('Terminate signal sent.');
        });

        const allInputs = document.querySelectorAll('input[type="range"], input[type="checkbox"]');
        allInputs.forEach(input => {
          input.addEventListener('input', this.broadcastState);
          input.addEventListener('change', this.broadcastState);
        });

        const presetButtons = ['savePresetBtn', 'deletePresetBtn', 'randomBtn'];
        presetButtons.forEach(id => document.getElementById(id).addEventListener('click', () => setTimeout(this.broadcastState, 50)));
        document.getElementById('presetList').addEventListener('change', () => setTimeout(this.broadcastState, 50));
        
        channel.onmessage = (ev) => {
            const msg = ev.data || {};
            if (msg.type === 'STATUS_UPDATE') {
                UI.setStatus(msg.text, msg.isError);
            }
        };
        
        UI.elements.bgUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                channel.postMessage({
                    type: 'SET_BACKGROUND',
                    payload: {
                        name: file.name,
                        type: file.type,
                        dataUrl: event.target.result
                    }
                });
                UI.elements.useBgChk.disabled = false;
                UI.elements.useBgChk.checked = true;
                this.broadcastState();
            };
            reader.readAsDataURL(file);
        });

        UI.elements.autoRandomizeSlider.addEventListener('input', () => this.setupAutomation());
        UI.elements.presetIterationSlider.addEventListener('input', () => this.setupAutomation());
      },

      broadcastState() {
        const state = PresetManager.getAppState();
        channel.postMessage({ type: 'SET_STATE', payload: state });
      },
      
      stopAutomation() {
        if (autoRandomizeIntervalId) clearInterval(autoRandomizeIntervalId);
        if (presetIterationIntervalId) clearInterval(presetIterationIntervalId);
        autoRandomizeIntervalId = null;
        presetIterationIntervalId = null;
      },

      setupAutomation() {
        this.stopAutomation();
        
        const autoRandomizeInterval = parseFloat(UI.elements.autoRandomizeSlider.value);
        if (autoRandomizeInterval > 0) {
            autoRandomizeIntervalId = setInterval(() => {
                PresetManager.randomize();
                this.broadcastState();
            }, autoRandomizeInterval * 1000);
        }

        const presetIterationInterval = parseFloat(UI.elements.presetIterationSlider.value);
        if (presetIterationInterval > 0) {
            presetIterationIntervalId = setInterval(() => {
                const presets = PresetManager.getPresets();
                const presetNames = Object.keys(presets);
                if (presetNames.length > 0) {
                    this.currentPresetIndex = (this.currentPresetIndex + 1) % presetNames.length;
                    const nextPresetName = presetNames[this.currentPresetIndex];
                    PresetManager.load(nextPresetName);
                    this.broadcastState();
                }
            }, presetIterationInterval * 1000);
        }
      }
    };
    
    const definitions = {
      Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.005, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } },
      Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 30, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 10, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.2, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } },
      Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } },
      Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.1, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } },
      Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.01, neutral: 0.0 } } },
      Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.5, neutral: 0.0 } } }
    };
    const globalDefinitions = {
        Opacity: { title: 'Global Opacity', active: true, controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 1.0, neutral: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.01, neutral: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.3, neutral: 0.0 } } },
        Seep: { title: 'Effect Seep', active: true, controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 2.0, neutral: 0.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 20, neutral: 0.0 } } }
    };

    Controller.init(definitions, globalDefinitions);
  })();
</script>
  
<script>
// --- Remote Trigger Module (PeerJS over PeerServer Cloud; no sign-in required) ---
// Note: This module remains in the control window. For a fully working implementation,
// the `recordCanvasFiveSeconds` function would need to be replaced with a message
// to the preview window, which would then perform the recording and send the data back.
// This is a complex addition, so the original code is left here to drive the UI.
(() => {
  const els = {
    enable: document.getElementById('remoteEnable'),
    showQR: document.getElementById('remoteShowQR'),
    reset: document.getElementById('remoteReset'),
    status: document.getElementById('remoteStatus'),
    canvas: null // Canvas is in the other window
  };
  if (!els.enable) return;

  let peer = null;
  const connections = new Map();
  let sessionToken = null;
  let armed = false;
  let isRecording = false;

  const PEERJS_URL = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
  const QR_URL = 'remote-qr.html';
  const PHONE_URL = 'phone.html';

  function updateStatus() {
    const count = connections.size;
    let text = 'REMOTE: idle';
    let good = true;

    if (armed) {
        if (isRecording) {
            text = `REMOTE: RECORDING... (${count} connected)`;
        } else if (count > 0) {
            text = `REMOTE: ${count} phone(s) connected. Ready.`;
        } else if (peer && peer.id) {
            text = `REMOTE: armed @ ${peer.id.slice(0,6)}… waiting for connections`;
        } else {
            text = 'REMOTE: arming...';
        }
    }

    if (els.status) {
        els.status.textContent = text;
        els.status.classList.toggle('text-red-400', !good);
        els.status.classList.toggle('text-green-400', good);
    }
  }

  function lazyLoadPeerJS() {
    return new Promise((resolve, reject) => {
      if (window.Peer) return resolve();
      const s = document.createElement('script');
      s.src = PEERJS_URL; s.crossOrigin = 'anonymous';
      s.onload = () => resolve();
      s.onerror = e => reject(new Error('Failed to load PeerJS'));
      document.body.appendChild(s);
    });
  }

  function randomToken(len=24) {
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    return Array.from(arr, b => b.toString(16).padStart(2,'0')).join('');
  }

  async function armRemote() {
    await lazyLoadPeerJS();
    sessionToken = randomToken(16);
    
    peer = new window.Peer(undefined, {
      debug: 1,
      config: {
        'iceServers': [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ]
      }
    });

    peer.on('open', id => {
      updateStatus();
      els.showQR.disabled = false;
      els.reset.disabled = false;
    });

    peer.on('connection', (conn) => {
      if (connections.size >= 3) {
        const oldestPeerId = connections.keys().next().value;
        if (oldestPeerId) {
          const oldestConn = connections.get(oldestPeerId);
          if (oldestConn) {
            oldestConn.send(JSON.stringify({ type: 'error', message: 'A new user connected. Please rescan.' }));
            setTimeout(() => { try { oldestConn.close(); } catch {} }, 100);
          }
          connections.delete(oldestPeerId);
        }
      }

      connections.set(conn.peer, conn);
      updateStatus();
      
      conn.on('data', (msg) => onMessage(msg, conn));
      conn.on('close', () => {
        connections.delete(conn.peer);
        updateStatus();
      });
      conn.on('error', (e) => {
        console.error('Peer connection error:', e);
        connections.delete(conn.peer);
        updateStatus();
      });
    });
    
    peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        if (err.type === 'peer-unavailable' || err.type === 'network') {
            disarmRemote();
            els.enable.checked = false;
            updateStatus();
        }
    });

    armed = true;
    updateStatus();
  }

  function disarmRemote() {
    armed = false;
    for (const conn of connections.values()) {
      try { conn.close(); } catch {}
    }
    connections.clear();
    
    if (peer) try { peer.destroy(); } catch {}
    peer = null;
    sessionToken = null;
    els.showQR.disabled = true;
    els.reset.disabled = true;
    updateStatus();
  }
  
  // This is a placeholder. A real implementation would message the preview window.
  async function recordCanvasFiveSeconds(preferMp4 = false) {
      alert("Recording must be implemented via communication with the preview window.");
      return Promise.reject("Recording not implemented in split-view.");
  }

  async function onMessage(msg, conn) {
    try {
      const data = typeof msg === 'string' ? JSON.parse(msg) : msg;
      if (data.type === 'hello') {
        if (data.token !== sessionToken) {
          conn.send(JSON.stringify({ type:'error', message: 'Invalid token.' }));
          setTimeout(() => { try { conn.close(); } catch {} }, 100);
          return;
        }
        conn.capabilities = { supportsWebM: !!data.supportsWebM };
        conn.send(JSON.stringify({ type:'helloAck', ok:true }));
        return;
      }

      if (data.type === 'startRecording') {
        if (!armed) return conn.send(JSON.stringify({ type: 'error', message: 'Remote is not armed.' }));
        if (isRecording) return conn.send(JSON.stringify({ type: 'error', message: 'Host is busy recording.' }));
        
        // **MODIFICATION REQUIRED FOR FULL FUNCTIONALITY**
        // Here, you would send a message to the preview window:
        // channel.postMessage({type: 'REMOTE_RECORD_REQUEST', payload: { ... }});
        // And then wait for the preview window to send back the recorded Blob.
        // For now, we'll just show an error.
        conn.send(JSON.stringify({ type:'error', message: 'Recording is not yet supported in split-view mode.' }));
        return;
      }
    } catch (e) {
      console.error('Remote message error', e);
      isRecording = false;
      updateStatus();
    }
  }

  function openQRWindow() {
    if (!peer || !sessionToken) return;
    const url = new URL(PHONE_URL, location.href);
    url.searchParams.set('host', peer.id);
    url.searchParams.set('token', sessionToken);
    const qrUrl = new URL(QR_URL, location.href);
    qrUrl.searchParams.set('target', url.toString());
    window.open(qrUrl.toString(), '_blank', 'noopener,noreferrer,width=520,height=600');
  }

  els.enable.addEventListener('change', async () => {
    if (els.enable.checked) {
      try { await armRemote(); } 
      catch (e) { console.error("Failed to arm remote:", e); els.enable.checked = false; updateStatus(); }
    } else { disarmRemote(); }
  });
  els.showQR.addEventListener('click', openQRWindow);
  els.reset.addEventListener('click', () => {
    const wasEnabled = els.enable.checked;
    disarmRemote();
    if (wasEnabled) {
      els.enable.checked = true;
      armRemote();
    }
  });
})();
</script>

</body>
</html>
