<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Face Glitch V3.1</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0d11;
            --panel-bg: #11141a;
            --stroke: #1f2430;
            --fg: #e5e7eb;
            --muted: #9aa0aa;
            --accent: #6ee7b7;
            --danger: #f87171;
            --primary-bg: #1a202c;
            --secondary-bg: #2d3748;
            --text-color: #f7fafc;
            --primary-color: #6ee7b7;
            --border-color: #4a5568;
            --shadow: 0 10px 30px rgba(0,0,0,0.4);
            --radius-sm: 8px;
            --radius-md: 12px;
        }
        
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: var(--bg); color: var(--text-color); }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: radial-gradient(circle at center, #1a1f26 0%, #0d0f13 100%);
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            width: 100%;
            max-width: 1600px;
            height: 90vh;
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: var(--shadow);
            background: var(--primary-bg);
            border: 1px solid var(--border-color);
        }

        .left-panel {
            background: var(--secondary-bg);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            display: flex;
            flex-direction: column;
        }

        .live-stage {
            position: relative;
            background: #0d0f13;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        #glcanvas, #video {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: var(--radius-md);
        }

        #video {
            display: none;
        }

        .right-panel {
            background: var(--secondary-bg);
            border-left: 1mpx solid var(--border-color);
            padding: 24px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 16px;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
            letter-spacing: -0.5px;
        }

        .btn {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background-color: transparent;
            color: var(--text-color);
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            font-family: 'Poppins', sans-serif;
        }
        
        .btn:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: #1a1f26;
            font-weight: 600;
        }
        
        .btn-primary:hover:not(:disabled) {
            background-color: #55d4a6;
            border-color: #55d4a6;
        }
        
        .section-heading {
            font-size: 16px;
            font-weight: 600;
            margin: 16px 0 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .effect-toggles {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--primary-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .toggle-item.active {
            border-color: var(--primary-color);
            background: rgba(110, 231, 183, 0.2);
            color: var(--primary-color);
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .toggle-switch input { display: none; }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .param-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 4px;
        }
        
        .slider-control-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .slider-input {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--border-color);
            -webkit-appearance: none;
            appearance: none;
            outline: none;
        }

        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid #0d0f13;
        }

        .slider-input::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid #0d0f13;
        }
        
        .auto-btn {
            padding: 4px 8px;
            font-size: 10px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'JetBrains Mono', monospace;
            line-height: 1;
        }
        
        .auto-btn.active {
            background: var(--primary-color);
            color: #1a1f26;
            border-color: var(--primary-color);
        }

        .global-controls {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .status-bar {
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--muted);
        }
        
        .status-badge {
            background: var(--primary-bg);
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            font-size: 10px;
        }
        
        .status-error {
            color: var(--danger);
        }

    </style>
</head>
<body>
    <div class="container">
        
        <div class="left-panel">
            <header>
                <h1>Face Glitch</h1>
                <p style="color:var(--muted); font-size:12px; margin:4px 0 16px">V3.1 - WebGL2.0</p>
                <div style="display:flex; gap:8px; margin-bottom:16px;">
                    <button id="startBtn" class="btn btn-primary">Start</button>
                    <button id="stopBtn" class="btn" disabled>Stop</button>
                </div>
            </header>
            
            <div class="effect-toggles">
                <div class="toggle-item active" data-effect="glitch">
                    <span>Glitch</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="glitchChk" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="smear">
                    <span>Smear (Dir.)</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="smearChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="noise">
                    <span>Noise Flow</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="noiseChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="blur">
                    <span>Box Blur</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="blurChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="distort">
                    <span>Wavy Distort</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="distortChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="rgb">
                    <span>RGB Split</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="rgbChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="vignette">
                    <span>Vignette</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="vignetteChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-item" data-effect="scanlines">
                    <span>Scanlines</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="scanlinesChk">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div style="margin-top:auto; padding-top:16px; border-top:1px solid var(--border-color)">
                <div style="display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--muted); padding-bottom:8px;">
                    <span>Presets</span>
                    <button id="randomBtn" class="auto-btn">Randomize</button>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <button id="presetSoft" class="btn">Soft Blur</button>
                    <button id="presetGlitch" class="btn">Heavy Glitch</button>
                    <button id="presetSmear" class="btn">Smear Sweep</button>
                    <button id="presetNoise" class="btn">Noise Flow</button>
                </div>
            </div>

        </div>

        <div class="live-stage">
            <video id="video" playsinline muted></video>
            <canvas id="glcanvas" aria-label="camera with face effects"></canvas>
        </div>

        <div class="right-panel">
            <div id="paramPanel">
                <div class="param-group" data-effect="glitch">
                    <p class="section-heading">Glitch Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Glitch Block (px)<span id="blockVal">22</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="block" min="2" max="160" step="2" value="22" class="slider-input">
                            <button class="auto-btn" data-param="block">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Glitch Probability<span id="probVal">0.45</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="prob" min="0" max="1" step="0.01" value="0.45" class="slider-input">
                            <button class="auto-btn" data-param="prob">Auto</button>
                        </div>
                    </div>
                </div>

                <div class="param-group" data-effect="smear">
                    <p class="section-heading">Smear Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Smear Length (px)<span id="smLenVal">40</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="smLen" min="0" max="120" step="1" value="40" class="slider-input">
                            <button class="auto-btn" data-param="smLen">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Smear Angle (°)<span id="smAngVal">0</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="smAng" min="0" max="360" step="1" value="0" class="slider-input">
                            <button class="auto-btn" data-param="smAng">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Samples<span id="samplesVal">12</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="samples" min="1" max="32" step="1" value="12" class="slider-input">
                            <button class="auto-btn" data-param="samples">Auto</button>
                        </div>
                    </div>
                </div>

                <div class="param-group" data-effect="noise">
                    <p class="section-heading">Noise Flow Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Noise Scale<span id="nScaleVal">3.0</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="nScale" min="0.5" max="10" step="0.1" value="3" class="slider-input">
                            <button class="auto-btn" data-param="nScale">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Noise Strength (px)<span id="nStrengthVal">18</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="nStrength" min="0" max="60" step="1" value="18" class="slider-input">
                            <button class="auto-btn" data-param="nStrength">Auto</button>
                        </div>
                    </div>
                </div>
                
                <div class="param-group" data-effect="blur">
                    <p class="section-heading">Box Blur Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Blur Radius (px)<span id="blurVal">16</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="blur" min="0" max="48" step="1" value="16" class="slider-input">
                            <button class="auto-btn" data-param="blur">Auto</button>
                        </div>
                    </div>
                </div>

                <div class="param-group" data-effect="distort">
                    <p class="section-heading">Wavy Distort Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Wave Freq<span id="freqVal">12.0</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="freq" min="0" max="60" step="0.5" value="12" class="slider-input">
                            <button class="auto-btn" data-param="freq">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Wave Amp (px)<span id="ampVal">16</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="amp" min="0" max="60" step="1" value="16" class="slider-input">
                            <button class="auto-btn" data-param="amp">Auto</button>
                        </div>
                    </div>
                </div>

                <div class="param-group" data-effect="rgb">
                    <p class="section-heading">RGB Split Controls</p>
                    <div class="control-item">
                        <label class="slider-label">RGB Split Amount<span id="rgbSplitVal">6</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="rgbSplit" min="0" max="20" step="1" value="6" class="slider-input">
                            <button class="auto-btn" data-param="rgbSplit">Auto</button>
                        </div>
                    </div>
                </div>

                <div class="param-group" data-effect="vignette">
                    <p class="section-heading">Vignette Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Vignette Radius<span id="vignetteRadiusVal">0.70</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="vignetteRadius" min="0" max="1" step="0.01" value="0.7" class="slider-input">
                            <button class="auto-btn" data-param="vignetteRadius">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Vignette Softness<span id="vignetteSoftnessVal">0.50</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="vignetteSoftness" min="0" max="1" step="0.01" value="0.5" class="slider-input">
                            <button class="auto-btn" data-param="vignetteSoftness">Auto</button>
                        </div>
                    </div>
                </div>

                <div class="param-group" data-effect="scanlines">
                    <p class="section-heading">Scanlines Controls</p>
                    <div class="control-item">
                        <label class="slider-label">Scanline Count<span id="scanlineCountVal">400</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="scanlineCount" min="50" max="1000" step="10" value="400" class="slider-input">
                            <button class="auto-btn" data-param="scanlineCount">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Scanline Intensity<span id="scanlineIntensityVal">0.20</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="scanlineIntensity" min="0" max="1" step="0.01" value="0.2" class="slider-input">
                            <button class="auto-btn" data-param="scanlineIntensity">Auto</button>
                        </div>
                    </div>
                </div>

            </div>

            <div class="global-controls">
                <p class="section-heading">Global Controls</p>
                <div class="param-group">
                    <div class="control-item">
                        <label class="slider-label">Intensity<span id="intensityVal">0.90</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="intensity" min="0" max="1" step="0.01" value="0.9" class="slider-input">
                            <button class="auto-btn" data-param="intensity">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Animation Speed<span id="speedVal">1.20</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="speed" min="0" max="5" step="0.01" value="1.2" class="slider-input">
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Mix (Opacity)<span id="mixVal">1.00</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="mix" min="0" max="1" step="0.01" value="1" class="slider-input">
                            <button class="auto-btn" data-param="mix">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Feather<span id="featherVal">18</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="feather" min="0" max="64" step="1" value="18" class="slider-input">
                            <button class="auto-btn" data-param="feather">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Mask Padding (px)<span id="padVal">16</span></label>
                        <div class="slider-control-row">
                            <input type="range" id="pad" min="0" max="120" step="1" value="16" class="slider-input">
                            <button class="auto-btn" data-param="pad">Auto</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <label class="slider-label">Mask Shape (Fallback):
                            <select id="shape" class="btn">
                                <option value="0">Rounded Rect</option>
                                <option value="1">Ellipse</option>
                            </select>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="status-bar">
                <span id="msg" class="status-error"></span>
                <span id="status2" class="status-badge">Idle</span>
            </div>
        </div>
    </div>
<script>
(() => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('glcanvas');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const status2El = document.getElementById('status2');
    const msgEl = document.getElementById('msg');
    const effectToggles = document.querySelectorAll('.effect-toggles .toggle-item');
    const paramGroups = document.querySelectorAll('.param-group');
    const autoBtns = document.querySelectorAll('.auto-btn');
    const randomBtn = document.getElementById('randomBtn');
    const presets = {
        softBlur: document.getElementById('presetSoft'),
        heavyGlitch: document.getElementById('presetGlitch'),
        smearSweep: document.getElementById('presetSmear'),
        noiseFlow: document.getElementById('presetNoise')
    };

    // UI state management
    const animatedParams = new Set();
    const effectFlagsMap = {
        glitch: 1, smear: 2, noise: 4, blur: 8, distort: 16,
        rgb: 32, vignette: 64, scanlines: 128
    };
    
    function hook(id, outId) {
        const el = document.getElementById(id);
        const out = document.getElementById(outId);
        if (!el || !out) {
            console.error(`Error: Missing element with ID '${id}' or '${outId}'. Please ensure all slider and value display elements are present in the HTML.`);
            return null;
        }
        const set = () => {
            out.textContent = parseFloat(el.value).toFixed(el.step < 1 ? 2 : 0);
        };
        el.addEventListener('input', set);
        set();
        return el;
    }

    const ui = {
        intensity: hook('intensity', 'intensityVal'),
        speed: hook('speed', 'speedVal'),
        block: hook('block', 'blockVal'),
        prob: hook('prob', 'probVal'),
        smLen: hook('smLen', 'smLenVal'),
        smAng: hook('smAng', 'smAngVal'),
        samples: hook('samples', 'samplesVal'),
        nScale: hook('nScale', 'nScaleVal'),
        nStrength: hook('nStrength', 'nStrengthVal'),
        blur: hook('blur', 'blurVal'),
        freq: hook('freq', 'freqVal'),
        amp: hook('amp', 'ampVal'),
        rgbSplit: hook('rgbSplit', 'rgbSplitVal'),
        vignetteRadius: hook('vignetteRadius', 'vignetteRadiusVal'),
        vignetteSoftness: hook('vignetteSoftness', 'vignetteSoftnessVal'),
        scanlineCount: hook('scanlineCount', 'scanlineCountVal'),
        scanlineIntensity: hook('scanlineIntensity', 'scanlineIntensityVal'),
        mix: hook('mix', 'mixVal'),
        feather: hook('feather', 'featherVal'),
        pad: hook('pad', 'padVal'),
        shape: document.getElementById('shape'),
        glitchChk: document.getElementById('glitchChk'),
        smearChk: document.getElementById('smearChk'),
        noiseChk: document.getElementById('noiseChk'),
        blurChk: document.getElementById('blurChk'),
        distortChk: document.getElementById('distortChk'),
        rgbChk: document.getElementById('rgbChk'),
        vignetteChk: document.getElementById('vignetteChk'),
        scanlinesChk: document.getElementById('scanlinesChk'),
        mirrorChk: document.getElementById('mirrorChk'),
        animateChk: document.getElementById('animateChk'), // This is no longer used, but kept for compatibility
        trackCenterChk: document.getElementById('trackCenterChk'),
        preciseMaskChk: document.getElementById('preciseMaskChk'),
        invertChk: document.getElementById('invert'),
    };
    
    // UI setup
    updateParamPanel('glitch');
    
    // --- WEBGL CORE ---
    let stream = null, rafId = null, detector = null, gl = null, program = null, tex = null, buf = null;
    let lastDetections = [];
    let lastFacesMesh = [];
    let lastDetTime = 0;
    const DETECT_EVERY_MS = 110;
    const MAX_FACES = 5;
    const faceRects = new Float32Array(MAX_FACES * 4);
    let effectCenter = { x: 0.5, y: 0.5 };
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    const tmpCanvas = document.createElement('canvas');
    const tmpCtx = tmpCanvas.getContext('2d');
    let maskTex = null;
    let faceMesh = null;
    let faceMeshReady = false;
    let fmBusy = false;
    let lastFmTime = 0;
    const FM_MIN_INTERVAL = 60;
    const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
    
    const vertSrc = `#version 300 es
    precision highp float;
    in vec2 a_pos; 
    out vec2 v_uv; 
    void main(){ v_uv = a_pos; gl_Position = vec4(a_pos*2.0-1.0, 0.0, 1.0);}`;
    
    const fragSrc = `#version 300 es
    precision highp float;
    in vec2 v_uv;
    out vec4 FragColor;
    uniform sampler2D u_tex; uniform sampler2D u_maskTex;
    uniform vec2 u_resolution; uniform float u_time; uniform vec2 u_center;
    uniform float u_intensity, u_speed, u_mix, u_feather, u_seed;
    uniform float u_block, u_prob, u_smLen, u_smAng, u_samples, u_nScale, u_nStrength, u_blur, u_freq, u_amp, u_rgbSplit, u_vignetteRadius, u_vignetteSoftness, u_scanlineCount, u_scanlineIntensity;
    uniform int u_faceCount, u_shape, u_invert, u_maskMode, u_effectFlags; uniform vec4 u_faces[5];
    
    float hash(float n){ return fract(sin(n)*43758.5453123); }
    float rand(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
    vec3 hash3(vec2 p){ vec3 q = vec3(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3)), dot(p, vec2(419.2,371.9))); return fract(sin(q)*43758.5453); }
    float noise(vec2 p){ vec2 i = floor(p), f = fract(p); float a = dot(hash3(i).xy, f); float b = dot(hash3(i+vec2(1.0,0.0)).xy, f-vec2(1.0,0.0)); float c = dot(hash3(i+vec2(0.0,1.0)).xy, f-vec2(0.0,1.0)); float d = dot(hash3(i+vec2(1.0,1.0)).xy, f-vec2(1.0,1.0)); vec2 u = f*f*(3.0-2.0*f); return mix(mix(a,b,u.x), mix(c,d,u.x), u.y); }
    vec2 noise2(vec2 p){ return vec2(noise(p), noise(p+vec2(5.2,1.3))); }
    
    vec4 applyGlitch(vec4 color, vec2 uv){
        float rows = u_resolution.y / max(1.0, u_block);
        float row = floor(uv.y * rows);
        float t = floor(u_time * (2.0 + u_speed*20.0) + u_seed*10.0);
        float r = hash(row + t*13.17);
        float active = step(1.0 - u_prob, r);
        float shift = (hash(row*7.31 + t*3.17) - 0.5) * 0.25 * u_intensity * active;
        vec2 new_uv = uv + vec2(shift, 0.0);
        return texture(u_tex, new_uv);
    }
    
    vec4 applySmear(vec4 color, vec2 uv){
        vec2 dir = vec2(cos(radians(u_smAng)), sin(radians(u_smAng)));
        vec2 stepUV = (u_smLen / u_resolution) * dir / max(1.0, u_samples);
        vec4 acc = vec4(0.0); float wsum = 0.0;
        for(int i=0;i<64;i++){
            if(i>=int(u_samples)) break;
            float t = float(i);
            float w = 1.0 - t/u_samples; acc += texture(u_tex, uv - stepUV * t) * w; wsum += w;
        }
        return acc / max(wsum, 1e-4);
    }
    
    vec4 applyNoiseFlow(vec4 color, vec2 uv){
        vec2 p = uv * u_nScale * 2.5 + vec2(u_time * 0.1 * u_speed, 0.0);
        vec2 n = noise2(p) * 2.0 - 1.0;
        vec2 off = (u_nStrength / u_resolution) * n;
        return texture(u_tex, uv + off * u_intensity);
    }
    
    vec4 applyBoxBlur(vec4 color, vec2 uv){
        vec2 off = vec2(u_blur) / u_resolution; vec4 acc = vec4(0.0);
        for(int dx=-1; dx<=1; ++dx){ for(int dy=-1; dy<=1; ++dy){ acc += texture(u_tex, uv + off*vec2(float(dx), float(dy))); } }
        return acc / 9.0;
    }

    vec4 applyWavyDistort(vec4 color, vec2 uv){
        float twopi = 6.2831853; float sx = sin((uv.y * (1.0 + u_freq*0.05) + u_time * (0.2 + u_speed*0.6)) * twopi);
        float cy = cos((uv.x * (0.6 + u_freq*0.04) + u_time * (0.3 + u_speed*0.5)) * twopi);
        vec2 d = vec2(sx, cy) * (u_amp / u_resolution);
        return texture(u_tex, uv + d * u_intensity);
    }

    vec4 applyRGBsplit(vec4 color, vec2 uv){
        float split = u_rgbSplit / u_resolution.x;
        vec3 split_color;
        split_color.r = texture(u_tex, uv + vec2(split, 0.0)).r;
        split_color.g = texture(u_tex, uv).g;
        split_color.b = texture(u_tex, uv - vec2(split, 0.0)).b;
        return vec4(split_color, 1.0);
    }

    vec4 applyVignette(vec4 color, vec2 uv){
        float dist = distance(uv, vec2(0.5));
        float vignette = smoothstep(u_vignetteRadius, u_vignetteRadius + u_vignetteSoftness, dist);
        return vec4(color.rgb * (1.0 - vignette), color.a);
    }

    vec4 applyScanlines(vec4 color, vec2 uv){
        float scanline = sin(uv.y * u_scanlineCount * 3.14159) * 0.5 + 0.5;
        float scanline_eff = (scanline * 0.2 + 0.8);
        return vec4(color.rgb * scanline_eff * (1.0 - u_scanlineIntensity) + color.rgb * u_scanlineIntensity, color.a);
    }

    float maskRect(vec2 uv, vec4 r){ float inside = step(r.x, uv.x) * step(uv.x, r.x + r.z) * step(r.y, uv.y) * step(uv.y, r.y + r.w); if(inside < 0.5) return 0.0; float fx = u_feather / u_resolution.x; float fy = u_feather / u_resolution.y; float f = max(fx, fy); float dx = min(uv.x - r.x, (r.x + r.z) - uv.x); float dy = min(uv.y - r.y, (r.y + r.w) - uv.y); float d = min(dx, dy); return smoothstep(0.0, f, d); }
    float maskEllipse(vec2 uv, vec4 r){ vec2 c = r.xy + r.zw * 0.5; vec2 rad = r.zw * 0.5; vec2 p = (uv - c) / rad; float rr = dot(p,p); float edge = 1.0 - sqrt(max(rr, 0.0)); float fe = u_feather / min(u_resolution.x, u_resolution.y); return smoothstep(0.0, fe, edge); }
    float faceMaskShape(vec2 uv){ float a = 0.0; for(int i=0;i<5;++i){ if(i>=u_faceCount) break; vec4 r = u_faces[i]; float m = (u_shape==0) ? maskRect(uv,r) : maskEllipse(uv,r); a = max(a, m); } return a; }
    float faceMask(vec2 uv){ float a = (u_maskMode==1) ? texture(u_maskTex, uv).r : faceMaskShape(uv); if(u_invert==1) a = 1.0 - a; return clamp(a, 0.0, 1.0); }
    
    void main(){
        vec2 uv = v_uv;
        vec4 baseColor = texture(u_tex, uv);
        vec4 effectColor = baseColor;
        
        if ((u_effectFlags & 1) > 0) { // Glitch
            effectColor = mix(effectColor, applyGlitch(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 2) > 0) { // Smear
            effectColor = mix(effectColor, applySmear(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 4) > 0) { // Noise Flow
            effectColor = mix(effectColor, applyNoiseFlow(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 8) > 0) { // Box Blur
            effectColor = mix(effectColor, applyBoxBlur(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 16) > 0) { // Wavy Distort
            effectColor = mix(effectColor, applyWavyDistort(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 32) > 0) { // RGB Split
            effectColor = mix(effectColor, applyRGBsplit(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 64) > 0) { // Vignette
            effectColor = mix(effectColor, applyVignette(effectColor, uv), u_intensity);
        }
        if ((u_effectFlags & 128) > 0) { // Scanlines
            effectColor = mix(effectColor, applyScanlines(effectColor, uv), u_intensity);
        }

        float m = faceMask(uv);
        FragColor = mix(baseColor, effectColor, m * u_mix);
    }
    `;

    function setStatus(text){ status2El.textContent = text; }
    function setMsg(text, isError=false){ msgEl.textContent = text || ''; msgEl.classList.toggle('status-error', !!isError); }
    const faceApiAvailable = 'FaceDetector' in window;
    if(!isSecureContext){ setMsg('Page is not secure (HTTPS). Camera access will be blocked by the browser.', true); }

    async function initDetector(){ if(!faceApiAvailable) throw new Error('FaceDetector API not available in this browser.'); detector = new FaceDetector({ fastMode:true, maxDetectedFaces: 5 }); }

    function fit(){ if(!video.videoWidth) return; const w = video.videoWidth, h = video.videoHeight; canvas.width = w; canvas.height = h; maskCanvas.width = w; maskCanvas.height = h; tmpCanvas.width = w; tmpCanvas.height = h; if(gl) gl.viewport(0,0,w,h); }

    function createGL(){
        gl = canvas.getContext('webgl2'); 
        if(!gl) {
            setMsg('WebGL2 not available. Check your browser/device support.', true);
            throw new Error('WebGL2 not available');
        }
        function compile(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ throw new Error(gl.getShaderInfoLog(s)||'shader compile fail'); } return s; }
        const vs = compile(gl.VERTEX_SHADER, vertSrc); const fs = compile(gl.FRAGMENT_SHADER, fragSrc);
        program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program); if(!gl.getProgramParameter(program, gl.LINK_STATUS)){ throw new Error(gl.getProgramInfoLog(program)||'link fail'); }

        const a_pos = gl.getAttribLocation(program, 'a_pos');
        buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        const verts = new Float32Array([ 0,0, 1,0, 0,1, 1,1 ]);
        gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
        gl.useProgram(program);
        gl.enableVertexAttribArray(a_pos);
        gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

        tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

        maskTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, maskTex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }

    const U = {};
    function getU(name){ return U[name] || (U[name] = gl.getUniformLocation(program, name)); }

    function uploadVideoTexture(){ gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex); try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video); } catch(e) { } gl.uniform1i(getU('u_tex'), 0); }

    function uploadMaskTexture(){ gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas); gl.uniform1i(getU('u_maskTex'), 1); }

    function setFacesUniform(){
        const W = canvas.width, H = canvas.height; const mirror = ui.mirrorChk.checked; const grow = parseFloat(ui.pad.value);
        let count = 0; let cx = 0.5, cy = 0.5;
        for(let i=0;i<Math.min(lastDetections.length, MAX_FACES); i++){
            const bb = lastDetections[i].boundingBox || lastDetections[i];
            let x = bb.x, y = bb.y, w = bb.width, h = bb.height;
            let nx = Math.floor(x - grow), ny = Math.floor(y - grow), nw = Math.ceil(w + 2*grow), nh = Math.ceil(h + 2*grow);
            if (nx < 0) { nw += nx; nx = 0; }
            if (ny < 0) { nh += ny; ny = 0; }
            if (nx + nw > W) nw = W - nx;
            if (ny + nh > H) nh = H - ny;
            if (nw <= 2 || nh <= 2) continue;
            if(mirror){ nx = W - (nx + nw); }
            faceRects[count*4+0] = nx / W; faceRects[count*4+1] = ny / H; faceRects[count*4+2] = nw / W; faceRects[count*4+3] = nh / H; count++;
            if(i===0){ cx = (nx + nw*0.5)/W; cy = (ny + nh*0.5)/H; }
            if(count>=MAX_FACES) break;
        }
        for(let j=count;j<MAX_FACES;j++){ faceRects[j*4+0]=0; faceRects[j*4+1]=0; faceRects[j*4+2]=0; faceRects[j*4+3]=0; }
        gl.uniform1i(getU('u_faceCount'), count);
        for(let k=0;k<MAX_FACES;k++){ gl.uniform4f(getU(`u_faces[${k}]`), faceRects[k*4], faceRects[k*4+1], faceRects[k*4+2], faceRects[k*4+3]); }
        if(ui.trackCenterChk.checked) effectCenter = { x: cx, y: cy };
    }

    function drawMaskFromMesh(){
        const W = maskCanvas.width, H = maskCanvas.height; maskCtx.clearRect(0,0,W,H); tmpCtx.clearRect(0,0,W,H);
        tmpCtx.fillStyle = '#fff'; tmpCtx.beginPath();
        for(const lm of lastFacesMesh){ if(!lm || lm.length < 468) continue; const p0 = lm[FACE_OVAL[0]]; tmpCtx.moveTo(p0.x*W, p0.y*H); for(let i=1;i<FACE_OVAL.length;i++){ const p = lm[FACE_OVAL[i]]; tmpCtx.lineTo(p.x*W, p.y*H); } tmpCtx.closePath(); }
        tmpCtx.fill();
        maskCtx.filter = `blur(${parseInt(ui.feather.value||0)}px)`;
        maskCtx.drawImage(tmpCanvas, 0, 0);
        maskCtx.filter = 'none';
    }
    
    function updateAnimatedValues(time) {
        const speed = parseFloat(ui.speed.value);
        animatedParams.forEach(paramId => {
            const el = ui[paramId];
            if (el) {
                const min = parseFloat(el.min);
                const max = parseFloat(el.max);
                const range = max - min;
                const animatedVal = min + (range / 2) * (1 + Math.sin(time * speed * 2 + Math.PI * parseFloat(ui.seed.value)/100));
                el.value = animatedVal;
                el.dispatchEvent(new Event('input'));
            }
        });
    }

    function setCommonUniforms(timeSec){
        gl.uniform1f(getU('u_intensity'), parseFloat(ui.intensity.value));
        gl.uniform1f(getU('u_speed'), parseFloat(ui.speed.value));
        gl.uniform1f(getU('u_block'), parseFloat(ui.block.value));
        gl.uniform1f(getU('u_prob'), parseFloat(ui.prob.value));
        gl.uniform1f(getU('u_smLen'), parseFloat(ui.smLen.value));
        gl.uniform1f(getU('u_smAng'), parseFloat(ui.smAng.value) * 3.14159265 / 180.0);
        gl.uniform1f(getU('u_samples'), parseFloat(ui.samples.value));
        gl.uniform1f(getU('u_nScale'), parseFloat(ui.nScale.value));
        gl.uniform1f(getU('u_nStrength'), parseFloat(ui.nStrength.value));
        gl.uniform1f(getU('u_blur'), parseFloat(ui.blur.value));
        gl.uniform1f(getU('u_freq'), parseFloat(ui.freq.value));
        gl.uniform1f(getU('u_amp'), parseFloat(ui.amp.value));
        gl.uniform1f(getU('u_rgbSplit'), parseFloat(ui.rgbSplit.value));
        gl.uniform1f(getU('u_vignetteRadius'), parseFloat(ui.vignetteRadius.value));
        gl.uniform1f(getU('u_vignetteSoftness'), parseFloat(ui.vignetteSoftness.value));
        gl.uniform1f(getU('u_scanlineCount'), parseFloat(ui.scanlineCount.value));
        gl.uniform1f(getU('u_scanlineIntensity'), parseFloat(ui.scanlineIntensity.value));
        gl.uniform1f(getU('u_mix'), parseFloat(ui.mix.value));
        gl.uniform1f(getU('u_feather'), parseFloat(ui.feather.value));
        gl.uniform1f(getU('u_seed'), parseFloat(ui.seed.value));

        gl.uniform1i(getU('u_shape'), parseInt(ui.shape.value,10));
        gl.uniform1i(getU('u_invert'), ui.invertChk.checked ? 1 : 0);
        gl.uniform2f(getU('u_resolution'), canvas.width, canvas.height);
        gl.uniform1f(getU('u_time'), timeSec);
        gl.uniform2f(getU('u_center'), effectCenter.x, effectCenter.y);
        
        let effectFlags = 0;
        if(ui.glitchChk.checked) effectFlags |= effectFlagsMap.glitch;
        if(ui.smearChk.checked) effectFlags |= effectFlagsMap.smear;
        if(ui.noiseChk.checked) effectFlags |= effectFlagsMap.noise;
        if(ui.blurChk.checked) effectFlags |= effectFlagsMap.blur;
        if(ui.distortChk.checked) effectFlags |= effectFlagsMap.distort;
        if(ui.rgbChk.checked) effectFlags |= effectFlagsMap.rgb;
        if(ui.vignetteChk.checked) effectFlags |= effectFlagsMap.vignette;
        if(ui.scanlinesChk.checked) effectFlags |= effectFlagsMap.scanlines;

        gl.uniform1i(getU('u_effectFlags'), effectFlags);
    }

    async function ensureFaceMesh(){
        if(faceMeshReady) return true;
        if(typeof window.FaceMesh === 'undefined'){
            await new Promise((resolve, reject) => {
                const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js'; s.onload = resolve; s.onerror = () => reject(new Error('Failed to load MediaPipe FaceMesh')); document.head.appendChild(s);
            });
        }
        faceMesh = new window.FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
        faceMesh.setOptions({ maxNumFaces: MAX_FACES, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults((res) => {
            lastFacesMesh = res.multiFaceLandmarks ? res.multiFaceLandmarks.map(lm => lm.map(p => ({x:p.x, y:p.y}))) : [];
            if(ui.trackCenterChk.checked && lastFacesMesh.length){ const lm = lastFacesMesh[0]; let sx=0, sy=0; for(const p of lm){ sx+=p.x; sy+=p.y; } effectCenter = { x: sx/lm.length, y: sy/lm.length }; }
        });
        faceMeshReady = true; return true;
    }

    async function start(){
        if(!navigator.mediaDevices?.getUserMedia){ setMsg('getUserMedia not supported. Try Chrome/Edge/Firefox.', true); return; }
        if(!isSecureContext){ setMsg('This page is not in a secure context (HTTPS). Camera will be blocked. Use GitHub Pages HTTPS or localhost with HTTPS.', true); return; }
        try {
            setStatus('Requesting camera…');
            stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
            video.srcObject = stream; await video.play();
            await new Promise((res) => { if (video.videoWidth && video.videoHeight) return res(); const onMeta = () => { video.removeEventListener('loadedmetadata', onMeta); res(); }; video.addEventListener('loadedmetadata', onMeta, { once: true }); });
            fit(); window.addEventListener('resize', fit);
            try { await initDetector(); setMsg(''); } catch(e){ console.warn(e); setMsg('FaceDetector API not available. Using MediaPipe for tracking.', true); }
            createGL();
            startBtn.disabled = true; stopBtn.disabled = false;
            loop();
        } catch(err){
            console.error(err);
            let hint = '';
            if (err && (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError')) { hint = ' • Permission blocked. Click the camera icon in the address bar and allow access.'; }
            if (err && err.name === 'NotFoundError') { hint = ' • No camera found. If you have multiple, pick one in site settings.'; }
            setMsg('Could not start camera: ' + err.message + hint, true); setStatus('Error');
        }
    }

    function stop(){ if(rafId) cancelAnimationFrame(rafId), rafId=null; if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } startBtn.disabled=false; stopBtn.disabled=true; setStatus('Stopped'); }

    async function detectFaces(){ if(!detector) return []; try { return (await detector.detect(video)) || []; } catch(e){ return []; } }

    function loop(){
        rafId = requestAnimationFrame(loop);
        const t = performance.now()/1000;
        
        updateAnimatedValues(t);

        if(ui.preciseMaskChk.checked){
            ensureFaceMesh().catch(e => setMsg(e.message, true));
            if(faceMesh && !fmBusy && (performance.now() - lastFmTime) > FM_MIN_INTERVAL){
                fmBusy = true; lastFmTime = performance.now();
                faceMesh.send({ image: video }).then(() => { fmBusy = false; }).catch(()=>{ fmBusy=false; });
            }
        } else if(!lastDetTime || (performance.now() - lastDetTime) > DETECT_EVERY_MS){
            lastDetTime = performance.now(); if(detector){ detectFaces().then(faces => { lastDetections = faces; status2El.textContent = faces.length ? `Faces: ${faces.length}` : 'No face'; }); } else { status2El.textContent = 'Camera on'; }
        }
        if(!video.videoWidth){ return; }
        if(canvas.width === 0 || canvas.height === 0){ fit(); }
        if(!ui.preciseMaskChk.checked){ setFacesUniform(); }
        let maskMode = 0;
        if(ui.preciseMaskChk.checked && lastFacesMesh.length){ drawMaskFromMesh(); uploadMaskTexture(); maskMode = 1; }
        uploadVideoTexture();
        gl.useProgram(program);
        gl.uniform1i(getU('u_maskMode'), maskMode);
        if(!ui.preciseMaskChk.checked){
        } else {
            gl.uniform1i(getU('u_faceCount'), 0);
        }
        setCommonUniforms(t);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        status2El.textContent = `${canvas.width}×${canvas.height} • Active effects: ${[...effectToggles].filter(e=>e.querySelector('input').checked).length}`;
    }

    // UI Logic for dynamic panels and effect selection
    function updateParamPanel(effect) {
        paramGroups.forEach(panel => {
            if (panel.dataset.effect === effect) {
                panel.style.display = 'flex';
            } else {
                panel.style.display = 'none';
            }
        });
    }

    effectToggles.forEach(toggle => {
        const checkbox = toggle.querySelector('input');
        checkbox.addEventListener('change', () => {
            toggle.classList.toggle('active', checkbox.checked);
        });
        toggle.addEventListener('click', (e) => {
            if (e.target.tagName !== 'INPUT') {
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            }
            updateParamPanel(toggle.dataset.effect);
        });
    });

    autoBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            btn.classList.toggle('active');
            const paramId = btn.dataset.param;
            if (btn.classList.contains('active')) {
                animatedParams.add(paramId);
            } else {
                animatedParams.delete(paramId);
            }
        });
    });

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    
    presets.softBlur.addEventListener('click', () => {
        [ui.glitchChk, ui.smearChk, ui.noiseChk, ui.distortChk, ui.rgbChk, ui.vignetteChk, ui.scanlinesChk].forEach(chk => chk.checked = false);
        ui.blurChk.checked = true;
        [ui.blur, ui.intensity, ui.rgbSplit, ui.feather, ui.mix, ui.pad].forEach(el=>el && el.dispatchEvent(new Event('input')));
        updateParamPanel('blur');
        effectToggles.forEach(t=>t.classList.remove('active')); document.querySelector('[data-effect="blur"]').classList.add('active');
    });
    presets.heavyGlitch.addEventListener('click', () => {
        [ui.blurChk, ui.smearChk, ui.noiseChk, ui.distortChk, ui.rgbChk, ui.vignetteChk, ui.scanlinesChk].forEach(chk => chk.checked = false);
        ui.glitchChk.checked = true;
        [ui.block,ui.prob,ui.intensity,ui.rgbSplit,ui.speed,ui.feather,ui.mix, ui.pad].forEach(el=>el && el.dispatchEvent(new Event('input')));
        updateParamPanel('glitch');
        effectToggles.forEach(t=>t.classList.remove('active')); document.querySelector('[data-effect="glitch"]').classList.add('active');
    });
    presets.smearSweep.addEventListener('click', () => {
        [ui.glitchChk, ui.blurChk, ui.noiseChk, ui.distortChk, ui.rgbChk, ui.vignetteChk, ui.scanlinesChk].forEach(chk => chk.checked = false);
        ui.smearChk.checked = true;
        [ui.smLen, ui.smAng, ui.samples, ui.intensity, ui.mix, ui.rgbSplit, ui.feather, ui.pad].forEach(el=>el && el.dispatchEvent(new Event('input')));
        updateParamPanel('smear');
        effectToggles.forEach(t=>t.classList.remove('active')); document.querySelector('[data-effect="smear"]').classList.add('active');
    });
    presets.noiseFlow.addEventListener('click', () => {
        [ui.glitchChk, ui.blurChk, ui.smearChk, ui.distortChk, ui.rgbChk, ui.vignetteChk, ui.scanlinesChk].forEach(chk => chk.checked = false);
        ui.noiseChk.checked = true;
        [ui.nScale, ui.nStrength, ui.intensity, ui.mix, ui.rgbSplit, ui.feather, ui.pad].forEach(el=>el && el.dispatchEvent(new Event('input')));
        updateParamPanel('noise');
        effectToggles.forEach(t=>t.classList.remove('active')); document.querySelector('[data-effect="noise"]').classList.add('active');
    });

    randomBtn.addEventListener('click', () => {
        const effects = ['glitch', 'smear', 'noise', 'blur', 'distort', 'rgb', 'vignette', 'scanlines'];
        const activeEffects = new Set();
        while (activeEffects.size < 2) {
            activeEffects.add(effects[Math.floor(Math.random() * effects.length)]);
        }

        effects.forEach(effect => {
            const chk = ui[`${effect}Chk`];
            if (chk) {
                chk.checked = activeEffects.has(effect);
                chk.dispatchEvent(new Event('change'));
            }
        });

        // Set one of the active effects as the visible one
        const visibleEffect = [...activeEffects][0] || 'glitch';
        updateParamPanel(visibleEffect);
        effectToggles.forEach(t=>t.classList.remove('active')); document.querySelector(`[data-effect="${visibleEffect}"]`).classList.add('active');

        const setRand=(el,min,max,step=1)=>{ if(!el) return; const v = (Math.round((min + Math.random()*(max-min))/step)*step).toFixed(step<1?2:0); el.value = v; el.dispatchEvent(new Event('input'));};
        setRand(ui.intensity,0.2,1,0.01); setRand(ui.speed,0,3,0.01); setRand(ui.blur,0,48,1); setRand(ui.rgbSplit,0,20,1); setRand(ui.block,4,140,2); setRand(ui.prob,0,1,0.01); setRand(ui.smLen,0,120,1); setRand(ui.smAng,0,360,1); setRand(ui.samples,4,28,1); setRand(ui.nScale,0.5,6,0.1); setRand(ui.nStrength,0,50,1); setRand(ui.freq,0,50,0.5); setRand(ui.amp,0,50,1); setRand(ui.mix,0.3,1,0.01); setRand(ui.feather,0,40,1); setRand(ui.pad,0,80,1); setRand(ui.vignetteRadius,0.5,1,0.01); setRand(ui.vignetteSoftness,0.1,0.5,0.01); setRand(ui.scanlineCount,100,800,10); setRand(ui.scanlineIntensity,0.1,0.5,0.01);
        ui.shape.value = Math.random() < 0.5 ? '0' : '1'; ui.invertChk.checked = Math.random() < 0.2; ui.preciseMaskChk.checked = Math.random() < 0.7; ui.trackCenterChk.checked = Math.random() < 0.8;
        
        animatedParams.clear();
        autoBtns.forEach(btn => btn.classList.remove('active'));
    });

    updateParamPanel(activeEffect);
    (async () => { try { const p = await navigator.permissions.query({ name:'camera' }); if(p.state==='granted') start(); } catch{} })();
})();
</script>
</body>
</html>
