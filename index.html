<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Face Glitch V3 (Generative)</title>
    <style>
        :root {
            --bg: #0b0d11;
            --panel: #11141a;
            --stroke: #1f2430;
            --fg: #e5e7eb;
            --muted: #9aa0aa;
            --accent: #6ee7b7;
            --danger: #f87171;
            --primary-bg: #1a202c;
            --secondary-bg: #2d3748;
            --text-color: #f7fafc;
            --primary-color: #6ee7b7;
            --border-color: #4a5568;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            --radius-sm: 8px;
            --radius-md: 12px;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: var(--bg); color: var(--text-color); }
        body { display: flex; justify-content: center; align-items: center; padding: 20px; background: radial-gradient(circle at center, #1a1f26 0%, #0d0f13 100%); }
        .container { display: flex; width: 100%; max-width: 1600px; height: 90vh; border-radius: var(--radius-md); overflow: hidden; box-shadow: var(--shadow); background: var(--primary-bg); border: 1px solid var(--border-color); }
        .main-stage { flex: 3; position: relative; background: #0d0f13; display: flex; align-items: center; justify-content: center; }
        #glcanvas, #video { width: 100%; height: 100%; display: block; }
        #video { display: none; }
        .controls-panel { flex: 1; min-width: 420px; padding: 24px; display: flex; flex-direction: column; overflow-y: auto; background: var(--secondary-bg); }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; border-bottom: 1px solid var(--border-color); padding-bottom: 16px; }
        h1 { font-size: 24px; font-weight: 600; margin: 0; letter-spacing: -0.5px; }
        .btn { padding: 10px 20px; border: 1px solid var(--border-color); border-radius: var(--radius-sm); background-color: transparent; color: var(--text-color); font-size: 14px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; font-family: 'Poppins', sans-serif; }
        .btn:hover:not(:disabled) { background-color: rgba(255, 255, 255, 0.1); border-color: var(--primary-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-small { padding: 4px 8px; font-size: 12px; }
        .btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #1a1f26; font-weight: 600; }
        .btn-primary:hover:not(:disabled) { background-color: #55d4a6; border-color: #55d4a6; }
        .section-heading { font-size: 16px; font-weight: 600; margin: 16px 0 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); }
        .effect-selector { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
        .effect-btn { background: var(--primary-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 8px 12px; border-radius: var(--radius-sm); cursor: pointer; transition: all 0.2s; }
        .effect-btn:hover { border-color: var(--primary-color); background: rgba(110, 231, 183, 0.1); }
        .effect-btn.active { border-color: var(--primary-color); background: var(--primary-color); color: #1a1f26; font-weight: 600; }
        .dynamic-controls { display: flex; flex-direction: column; gap: 16px; }
        .control-group { border: 1px solid var(--border-color); border-radius: var(--radius-md); margin-bottom: 16px; background: var(--primary-bg); display: none; }
        .control-group.global, .control-group.active { display: block; }
        .control-group-header { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-weight: 600; transition: background-color 0.2s; }
        .control-group-header:hover { background-color: rgba(255, 255, 255, 0.05); }
        .control-group-header::after { content: '▼'; font-size: 0.8rem; transition: transform 0.2s; }
        .control-group.collapsed .control-group-header::after { transform: rotate(-90deg); }
        .control-group-content { padding: 12px 16px; border-top: 1px solid var(--border-color); transition: all 0.3s ease-in-out; }
        .control-group.collapsed .control-group-content { display: none; }
        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .preset-grid { display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; margin-bottom: 12px; }
        #presetName, #presetList { width: 100%; background: var(--primary-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 8px 12px; border-radius: var(--radius-sm); }
        #presetList { margin-bottom: 12px; }
        .control-item { display: flex; flex-direction: column; gap: 6px; }
        .control-item.full-width { grid-column: 1 / -1; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
        .slider-input { width: 100%; height: 4px; border-radius: 2px; background: var(--border-color); -webkit-appearance: none; appearance: none; outline: none; }
        .slider-input::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #0d0f13; }
        .slider-input::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #0d0f13; }
        .options-list { display: flex; flex-direction: column; gap: 10px; margin-top: 16px; }
        .options-list label { display: flex; align-items: center; gap: 10px; font-size: 14px; cursor: pointer; }
        .options-list input[type="checkbox"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 18px; height: 18px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--primary-bg); cursor: pointer; position: relative; }
        .options-list input[type="checkbox"]:checked { background-color: var(--primary-color); border-color: var(--primary-color); }
        .options-list input[type="checkbox"]:checked:after { content: '✓'; color: #1a1f26; font-size: 14px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .status-bar { margin-top: auto; padding-top: 16px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--muted); }
        .status-badge { background: var(--primary-bg); padding: 4px 8px; border-radius: var(--radius-sm); border: 1px solid var(--border-color); font-size: 10px; }
        .status-error { color: var(--danger); }
        .slider-container { display: flex; flex-direction: column; gap: 4px; }
        .slider-main-line { display: flex; align-items: center; gap: 8px; }
        .wiggle-btn { background: none; border: 1px solid var(--border-color); color: var(--muted); cursor: pointer; border-radius: 4px; width: 24px; height: 24px; font-weight: bold; font-family: 'JetBrains Mono', monospace; transition: all 0.2s; }
        .wiggle-btn.active { color: var(--primary-color); border-color: var(--primary-color); background-color: rgba(110, 231, 183, 0.1); }
        .wiggle-controls { display: none; flex-direction: column; gap: 8px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: var(--radius-sm); margin-top: 4px; }
        .wiggle-controls.active { display: flex; }
        .wiggle-controls .slider-label { font-size: 10px; }
        .wiggle-controls .slider-input::-webkit-slider-thumb { width: 12px; height: 12px; }
        .wiggle-controls .slider-input::-moz-range-thumb { width: 12px; height: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-stage">
            <video id="video" playsinline muted></video>
            <canvas id="glcanvas" aria-label="camera with face effects"></canvas>
        </div>
        <div class="controls-panel">
            <div class="header">
                <h1>Face Glitch V3</h1>
                <div class="header-actions">
                    <button id="startBtn" class="btn btn-primary">Start</button>
                    <button id="stopBtn" class="btn" disabled>Stop</button>
                </div>
            </div>

            <div class="section-heading">Effect Layers</div>
            <div class="effect-selector">
                <button class="effect-btn" data-effect="Smear">Smear</button>
                <button class="effect-btn" data-effect="Turbulence">Turbulence</button>
                <button class="effect-btn" data-effect="DataMosh">DataMosh</button>
                <button class="effect-btn" data-effect="Pixelate">Pixelate</button>
                <button class="effect-btn" data-effect="Glitch">Glitch</button>
                <button class="effect-btn" data-effect="ChromaJitter">Chroma Jitter</button>
            </div>

            <div class="dynamic-controls">
                <div id="smearControls" class="control-group" data-effect="Smear">
                    <div class="control-group-header">Smear Controls</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item" data-control-id="smLen"></div>
                            <div class="control-item" data-control-id="smAng"></div>
                            <div class="control-item" data-control-id="samples"></div>
                        </div>
                    </div>
                </div>
                <div id="turbulenceControls" class="control-group" data-effect="Turbulence">
                    <div class="control-group-header">Turbulence Controls</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            <div class="control-item" data-control-id="turbScale"></div>
                            <div class="control-item" data-control-id="turbStrength"></div>
                        </div>
                    </div>
                </div>
                <div id="dataMoshControls" class="control-group" data-effect="DataMosh">
                     <div class="control-group-header">Data Mosh Controls</div>
                     <div class="control-group-content">
                         <div class="control-grid">
                             <div class="control-item" data-control-id="moshBlock"></div>
                             <div class="control-item" data-control-id="moshProb"></div>
                         </div>
                     </div>
                 </div>
                <div id="pixelateControls" class="control-group" data-effect="Pixelate">
                     <div class="control-group-header">Pixelate Controls</div>
                     <div class="control-group-content">
                         <div class="control-grid">
                             <div class="control-item full-width" data-control-id="pixelSize"></div>
                         </div>
                     </div>
                 </div>
                 <div id="glitchControls" class="control-group" data-effect="Glitch">
                     <div class="control-group-header">Glitch Controls</div>
                     <div class="control-group-content">
                         <div class="control-grid">
                             <div class="control-item" data-control-id="glitchBlock"></div>
                             <div class="control-item" data-control-id="glitchProb"></div>
                         </div>
                     </div>
                 </div>
                 <div id="chromaJitterControls" class="control-group" data-effect="ChromaJitter">
                     <div class="control-group-header">Chroma Jitter Controls</div>
                     <div class="control-group-content">
                         <div class="control-grid">
                            <div class="control-item full-width" data-control-id="chromaShift"></div>
                         </div>
                     </div>
                 </div>
            </div>

            <div id="globalControls" class="control-group global">
                <div class="control-group-header">Global & Mask Controls</div>
                <div class="control-group-content">
                    <div class="control-grid">
                         <div class="control-item" data-control-id="speed"></div>
                         <div class="control-item" data-control-id="mix"></div>
                         <div class="control-item" data-control-id="feather"></div>
                         <div class="control-item" data-control-id="pad"></div>
                         <div class="control-item full-width" data-control-id="feedback"></div>
                    </div>
                    <div class="options-list">
                        <label><input type="checkbox" id="mirrorChk" checked> Mirror Camera</label>
                        <label><input type="checkbox" id="animateChk" checked> Animate Effects</label>
                        <label><input type="checkbox" id="trackCenterChk" checked> Track Center of Face</label>
                        <label><input type="checkbox" id="preciseMaskChk" checked> Precise Face Mesh Mask</label>
                    </div>
                </div>
            </div>
            
             <div id="presetsTools" class="control-group global">
                 <div class="control-group-header">Presets</div>
                 <div class="control-group-content">
                     <div class="preset-grid">
                         <input type="text" id="presetName" placeholder="Preset Name...">
                         <button id="savePresetBtn" class="btn btn-small">Save</button>
                         <button id="deletePresetBtn" class="btn btn-small" style="color: var(--danger);">Delete</button>
                     </div>
                     <select id="presetList" class="btn"></select>
                     <button id="randomBtn" class="btn" style="width: 100%; margin-top: 8px;">Randomize All</button>
                 </div>
             </div>

            <div class="status-bar">
                <span id="msg" class="status-error"></span>
                <span id="status2" class="status-badge">Idle</span>
            </div>
        </div>
    </div>
    <script>
    (() => {
        // --- DOM Elements & UI Hooks ---
        const video = document.getElementById('video');
        const canvas = document.getElementById('glcanvas');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const mirrorChk = document.getElementById('mirrorChk');
        const animateChk = document.getElementById('animateChk');
        const trackCenterChk = document.getElementById('trackCenterChk');
        const preciseMaskChk = document.getElementById('preciseMaskChk');
        const status2El = document.getElementById('status2');
        const msgEl = document.getElementById('msg');
        const effectBtns = document.querySelectorAll('.effect-btn');
        const savePresetBtn = document.getElementById('savePresetBtn');
        const deletePresetBtn = document.getElementById('deletePresetBtn');
        const presetNameInput = document.getElementById('presetName');
        const presetList = document.getElementById('presetList');
        const randomBtn = document.getElementById('randomBtn');

        // *** ERROR FIX: Define helper functions here ***
        function setStatus(text) { status2El.textContent = text; }
        function setMsg(text, isError = false) { msgEl.textContent = text || ''; msgEl.classList.toggle('status-error', !!isError); }

        const ALL_EFFECTS = Array.from(effectBtns).map(btn => btn.dataset.effect);
        let activeEffects = new Set();
        
        const controlsState = {};

        function createSliderControl(id, def) {
            controlsState[id] = {
                base: def.value,
                wiggleAmt: 0,
                wiggleSpd: 1,
                isWiggling: false
            };
            
            const container = document.querySelector(`[data-control-id="${id}"]`);
            if (!container) return;

            const isFullWidth = container.classList.contains('full-width');
            const gridTemplate = isFullWidth ? `1fr` : `auto 1fr`;

            container.innerHTML = `
                <div class="slider-container">
                    <div class="slider-main-line" style="display: grid; grid-template-columns: ${gridTemplate}; gap: 8px; align-items: center;">
                        <button class="wiggle-btn" data-id="${id}">~</button>
                        <div style="flex-grow: 1;">
                            <label class="slider-label">${def.label}<span id="${id}-val">${def.value}</span></label>
                            <input type="range" id="${id}-base" min="${def.min}" max="${def.max}" step="${def.step}" value="${def.value}" class="slider-input">
                        </div>
                    </div>
                    <div class="wiggle-controls" id="${id}-wiggle-panel">
                        <label class="slider-label">Wiggle Amount<span id="${id}-amt-val">0</span></label>
                        <input type="range" id="${id}-amt" min="0" max="${(def.max - def.min) / 2}" step="${def.step}" value="0" class="slider-input">
                        
                        <label class="slider-label">Wiggle Speed<span id="${id}-spd-val">1</span></label>
                        <input type="range" id="${id}-spd" min="0" max="10" step="0.1" value="1" class="slider-input">
                    </div>
                </div>
            `;
            if (isFullWidth) {
                container.querySelector('.wiggle-btn').style.gridRow = "1 / 3";
                container.querySelector('.slider-main-line > div').style.gridColumn = "2 / 3";
            }


            const baseSlider = document.getElementById(`${id}-base`);
            const amtSlider = document.getElementById(`${id}-amt`);
            const spdSlider = document.getElementById(`${id}-spd`);
            const baseVal = document.getElementById(`${id}-val`);
            const amtVal = document.getElementById(`${id}-amt-val`);
            const spdVal = document.getElementById(`${id}-spd-val`);
            const wiggleBtn = container.querySelector('.wiggle-btn');
            const wigglePanel = document.getElementById(`${id}-wiggle-panel`);

            const update = () => {
                baseVal.textContent = parseFloat(baseSlider.value).toFixed(def.step < 1 ? 2 : 0);
                amtVal.textContent = parseFloat(amtSlider.value).toFixed(def.step < 1 ? 2 : 0);
                spdVal.textContent = parseFloat(spdSlider.value).toFixed(1);
                controlsState[id].base = parseFloat(baseSlider.value);
                controlsState[id].wiggleAmt = parseFloat(amtSlider.value);
                controlsState[id].wiggleSpd = parseFloat(spdSlider.value);
            };

            baseSlider.addEventListener('input', update);
            amtSlider.addEventListener('input', update);
            spdSlider.addEventListener('input', update);

            wiggleBtn.addEventListener('click', () => {
                const isActive = wigglePanel.classList.toggle('active');
                wiggleBtn.classList.toggle('active', isActive);
                controlsState[id].isWiggling = isActive;
            });
            update();
        }

        const controlDefinitions = {
            smLen: { label: "Length", min: 0, max: 200, step: 1, value: 40 },
            smAng: { label: "Angle", min: 0, max: 360, step: 1, value: 0 },
            samples: { label: "Samples", min: 1, max: 32, step: 1, value: 12 },
            turbScale: { label: "Scale", min: 0.5, max: 50, step: 0.1, value: 8 },
            turbStrength: { label: "Strength (px)", min: 0, max: 100, step: 1, value: 10 },
            moshBlock: { label: "Block Size", min: 4, max: 64, step: 1, value: 16 },
            moshProb: { label: "I-Frame Prob.", min: 0, max: 0.1, step: 0.001, value: 0.01 },
            pixelSize: { label: "Pixel Size", min: 1, max: 64, step: 1, value: 12 },
            glitchBlock: { label: "Block Size", min: 2, max: 160, step: 2, value: 22 },
            glitchProb: { label: "Probability", min: 0, max: 1, step: 0.01, value: 0.45 },
            chromaShift: { label: "Shift (px)", min: 0, max: 50, step: 1, value: 8 },
            speed: { label: "Global Speed", min: 0, max: 5, step: 0.01, value: 1.2 },
            mix: { label: "Effect Mix", min: 0, max: 1, step: 0.01, value: 1.0 },
            feather: { label: "Feather", min: 0, max: 64, step: 1, value: 18 },
            pad: { label: "Mask Padding", min: -50, max: 120, step: 1, value: 16 },
            feedback: { label: "Feedback Amt", min: 0, max: 0.99, step: 0.01, value: 0 }
        };

        Object.keys(controlDefinitions).forEach(id => createSliderControl(id, controlDefinitions[id]));
        
        let stream = null, rafId = null, gl = null, program = null;
        let videoTex = null, maskTex = null;
        let fbos = [], currentFBO = 0;
        let lastFacesMesh = [];
        let effectCenter = { x: 0.5, y: 0.5 };
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        let faceMesh = null, faceMeshReady = false, fmBusy = false, lastFmTime = 0;
        const FM_MIN_INTERVAL = 60;
        const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
        
        const vertSrc = `attribute vec2 a_pos; varying vec2 v_uv; void main(){ v_uv = a_pos; gl_Position = vec4(a_pos*2.0-1.0, 0.0, 1.0);}`;
        const fragSrc = `
            precision highp float; 
            varying vec2 v_uv; 
            
            // UNIFORMS
            uniform sampler2D u_videoTex; 
            uniform sampler2D u_maskTex;
            uniform sampler2D u_feedbackTex;
            uniform vec2 u_resolution; 
            uniform float u_time; 
            
            // Effect Flags
            uniform bool u_Smear_active;
            uniform bool u_Turbulence_active;
            uniform bool u_DataMosh_active;
            uniform bool u_Pixelate_active;
            uniform bool u_Glitch_active;
            uniform bool u_ChromaJitter_active;
            
            // Control Uniforms
            uniform float u_smLen, u_smAng, u_samples;
            uniform float u_turbScale, u_turbStrength;
            uniform float u_moshBlock, u_moshProb;
            uniform float u_pixelSize;
            uniform float u_glitchBlock, u_glitchProb;
            uniform float u_chromaShift;
            uniform float u_feather, u_mix, u_feedback, u_speed;

            // HELPERS
            float rand(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
            float noise(vec2 p) {
                vec2 i = floor(p); vec2 f = fract(p);
                vec2 u = f*f*(3.0-2.0*f);
                return mix(mix(rand(i), rand(i + vec2(1,0)), u.x),
                           mix(rand(i + vec2(0,1)), rand(i + vec2(1,1)), u.x), u.y);
            }

            // MASKING
            float getMaskValue(vec2 uv) {
                float m = texture2D(u_maskTex, uv).r;
                float feather_amount = u_feather / u_resolution.y;
                return smoothstep(0.5 - feather_amount, 0.5 + feather_amount, m);
            }

            // --- ADVANCED EFFECT FUNCTIONS ---
            vec4 applySmear(vec2 uv, vec4 base_color) {
                vec4 acc = vec4(0.0);
                float w_sum = 0.0;
                vec2 dir = vec2(cos(radians(u_smAng)), sin(radians(u_smAng)));

                for(int i = 0; i < 32; i++) {
                    if (i >= int(u_samples)) break;
                    float t = float(i);
                    vec2 sample_uv = uv - (dir * u_smLen / u_resolution) * (t / u_samples);
                    
                    float sample_mask = getMaskValue(sample_uv);
                    vec4 sample_color = texture2D(u_videoTex, sample_uv);
                    
                    acc += sample_color * sample_mask;
                    w_sum += sample_mask;
                }
                
                if (w_sum > 0.0) acc /= w_sum;

                return acc + base_color * (1.0 - getMaskValue(uv));
            }

            vec2 applyTurbulence(vec2 uv) {
                float strength = u_turbStrength / u_resolution.x;
                float time_mult = u_time * u_speed;
                vec2 p1 = uv * u_turbScale + time_mult * 0.1;
                vec2 p2 = uv * u_turbScale * 2.1 - time_mult * 0.15;
                vec2 offset = vec2(noise(p1), noise(p1 + 5.2)) * 2.0 - 1.0;
                offset += (vec2(noise(p2), noise(p2 + 8.3)) * 2.0 - 1.0) * 0.5;
                return uv + offset * strength;
            }

            vec4 applyDataMosh(vec2 uv, vec4 current_color, sampler2D feedback_tex) {
                vec2 block_uv = floor(uv * u_moshBlock) / u_moshBlock;
                if (rand(block_uv + floor(u_time * 5.0 * u_speed)) > u_moshProb) {
                    vec2 flow = (vec2(rand(block_uv), rand(block_uv + 9.8)) - 0.5) * 0.1;
                    return texture2D(feedback_tex, uv + flow);
                }
                return current_color;
            }

            vec2 applyPixelate(vec2 uv) {
                 vec2 res_factor = u_resolution / u_pixelSize;
                 return (floor(uv * res_factor) + 0.5) / res_factor;
            }
            
            vec2 applyGlitch(vec2 uv) {
                float row = floor(uv.y * u_glitchBlock);
                if(rand(vec2(row, floor(u_time * 10.0 * u_speed))) > u_glitchProb) return uv;
                return uv + vec2((rand(vec2(row, floor(u_time * 15.0))) - 0.5) * 0.3, 0.0);
            }
            
            vec4 applyChromaJitter(vec4 color, vec2 uv) {
                 float shift = u_chromaShift * (1.0 + (rand(uv + u_time) - 0.5) * 0.5) / u_resolution.x;
                 float r = texture2D(u_videoTex, uv + vec2(shift, 0.0)).r;
                 float b = texture2D(u_videoTex, uv - vec2(shift, 0.0)).b;
                 return vec4(r, color.g, b, color.a);
            }

            void main() {
                vec4 base_color = texture2D(u_videoTex, v_uv);
                vec4 feedback_color = texture2D(u_feedbackTex, v_uv);
                
                vec4 current_color = mix(base_color, feedback_color, u_feedback);
                vec2 effect_uv = v_uv;

                if (u_Turbulence_active) { effect_uv = applyTurbulence(effect_uv); }
                if (u_Pixelate_active) { effect_uv = applyPixelate(effect_uv); }
                if (u_Glitch_active) { effect_uv = applyGlitch(effect_uv); }

                vec4 final_color = texture2D(u_videoTex, effect_uv);

                if (u_ChromaJitter_active) { final_color = applyChromaJitter(final_color, effect_uv); }
                
                // DataMosh uses the mixed feedback color as input
                if (u_DataMosh_active) { final_color = applyDataMosh(v_uv, current_color, u_feedbackTex); }
                
                float mask = getMaskValue(v_uv);
                final_color = mix(final_color, current_color, 1.0 - mask);
                
                if (u_Smear_active) { final_color = applySmear(v_uv, final_color); }
                
                gl_FragColor = mix(base_color, final_color, u_mix);
            }
        `;
        
        const U = {};
        function getU(name) { return U[name] || (U[name] = gl.getUniformLocation(program, name)); }
        
        async function start() {
            if (!navigator.mediaDevices?.getUserMedia) { setMsg('getUserMedia not supported.', true); return; }
            if (!isSecureContext) { setMsg('Page is not secure (HTTPS).', true); return; }
            try {
                setStatus('Requesting camera…');
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                video.srcObject = stream; await video.play();
                await new Promise(res => video.addEventListener('loadedmetadata', res, { once: true }));
                
                fit();
                window.addEventListener('resize', fit);
                
                setStatus('Initializing...');
                await initFaceMesh();
                createGL();
                initFBOs();
                
                startBtn.disabled = true; stopBtn.disabled = false;
                setStatus('Running');
                setMsg('');
                loop();
            } catch (err) {
                console.error(err);
                setMsg('Could not start camera: ' + err.message, true); setStatus('Error');
            }
        }

        function stop() {
            if (rafId) cancelAnimationFrame(rafId), rafId = null;
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
            startBtn.disabled = false; stopBtn.disabled = true;
            setStatus('Stopped');
        }

        function loop(time) {
            rafId = requestAnimationFrame(loop);
            if (!video.videoWidth || !gl) return;
            const t = animateChk.checked ? time / 1000 : 0;

            if (faceMeshReady && !fmBusy && (performance.now() - lastFmTime) > FM_MIN_INTERVAL) {
                fmBusy = true; lastFmTime = performance.now();
                faceMesh.send({ image: video }).finally(() => { fmBusy = false; });
            }

            if (preciseMaskChk.checked) {
                drawMaskFromMesh();
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, maskTex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);
            }
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, videoTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

            gl.useProgram(program);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[currentFBO].framebuffer);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.uniform1i(getU('u_videoTex'), 0);
            gl.uniform1i(getU('u_maskTex'), 1);
            gl.uniform1i(getU('u_feedbackTex'), 2);
            
            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_2D, fbos[1 - currentFBO].texture);

            gl.uniform2f(getU('u_resolution'), canvas.width, canvas.height);
            gl.uniform1f(getU('u_time'), t);
            
            for (const id in controlsState) {
                const state = controlsState[id];
                let value = state.base;
                if (state.isWiggling && animateChk.checked) {
                    value += Math.sin(t * state.wiggleSpd) * state.wiggleAmt;
                }
                gl.uniform1f(getU(`u_${id}`), value);
            }
            
            for (const effect of ALL_EFFECTS) {
                gl.uniform1i(getU(`u_${effect}_active`), activeEffects.has(effect));
            }
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_2D, fbos[currentFBO].texture);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            currentFBO = 1 - currentFBO;

            status2El.textContent = `${lastFacesMesh.length > 0 ? 'Face OK' : 'No Face'} @ ${canvas.width}x${canvas.height}`;
        }
        
        function fit() {
            if (!video.videoWidth) return;
            const w = video.videoWidth; const h = video.videoHeight;
            canvas.width = w; canvas.height = h;
            maskCanvas.width = w; maskCanvas.height = h;
            if (gl) {
                gl.viewport(0, 0, w, h);
                if (fbos.length > 0) {
                    fbos.forEach(fbo => {
                        gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    });
                }
            }
        }

        function createGL() {
            gl = canvas.getContext('webgl');
            const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vertSrc); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fragSrc); gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) { setMsg("Shader Error: " + gl.getShaderInfoLog(fs), true); throw new Error("Shader compile error"); }
            program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
            
            const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
            const a_pos = gl.getAttribLocation(program, 'a_pos');
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            videoTex = createTexture(); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            maskTex = createTexture();
        }
        
        function createTexture() {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return tex;
        }

        function initFBOs() {
            for (let i = 0; i < 2; i++) {
                const texture = createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

                fbos.push({ framebuffer: fbo, texture: texture });
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        async function initFaceMesh() {
            if (faceMeshReady) return;
            if (typeof window.FaceMesh === 'undefined') {
                await new Promise((resolve, reject) => {
                    const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js'; s.onload = resolve; s.onerror = () => reject(new Error('Failed to load MediaPipe FaceMesh')); document.head.appendChild(s);
                });
            }
            faceMesh = new window.FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
            faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            faceMesh.onResults((res) => {
                lastFacesMesh = res.multiFaceLandmarks || [];
            });
            faceMeshReady = true;
        }

        function drawMaskFromMesh() {
            const W = maskCanvas.width, H = maskCanvas.height;
            maskCtx.save();
            maskCtx.clearRect(0, 0, W, H);
            
            if(mirrorChk.checked){ maskCtx.translate(W, 0); maskCtx.scale(-1, 1); }
            
            maskCtx.fillStyle = '#fff';
            maskCtx.beginPath();
            
            if(lastFacesMesh.length > 0){
                const lm = lastFacesMesh[0];
                if (!lm || lm.length < 468) { maskCtx.restore(); return; }
                
                const padding = controlsState.pad ? controlsState.pad.base : 0;
                const padFactor = 1 + padding / 100;

                let minX = W, minY = H, maxX = 0, maxY = 0;
                for(const p of lm) { minX = Math.min(minX, p.x * W); minY = Math.min(minY, p.y * H); maxX = Math.max(maxX, p.x * W); maxY = Math.max(maxY, p.y * H); }
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                const p0 = lm[FACE_OVAL[0]];
                maskCtx.moveTo(centerX + (p0.x*W - centerX) * padFactor, centerY + (p0.y*H - centerY) * padFactor);
                for(let i = 1; i < FACE_OVAL.length; i++){
                    const p = lm[FACE_OVAL[i]];
                    maskCtx.lineTo(centerX + (p.x*W - centerX) * padFactor, centerY + (p.y*H - centerY) * padFactor);
                }
                maskCtx.closePath();
            }
            maskCtx.fill();
            maskCtx.restore();
        }
        
        function getAppState() {
            return {
                controls: JSON.parse(JSON.stringify(controlsState)),
                checkboxes: {
                    mirrorChk: mirrorChk.checked, animateChk: animateChk.checked,
                    trackCenterChk: trackCenterChk.checked, preciseMaskChk: preciseMaskChk.checked
                },
                effects: Array.from(activeEffects)
            };
        }

        function setAppState(state) {
            if (!state) return;
            if (state.controls) {
                Object.keys(state.controls).forEach(id => {
                    if (controlsState[id] && state.controls[id]) {
                        Object.assign(controlsState[id], state.controls[id]);
                        document.getElementById(`${id}-base`).value = state.controls[id].base;
                        document.getElementById(`${id}-amt`).value = state.controls[id].wiggleAmt;
                        document.getElementById(`${id}-spd`).value = state.controls[id].wiggleSpd;
                        const wigglePanel = document.getElementById(`${id}-wiggle-panel`);
                        const wiggleBtn = document.querySelector(`[data-id="${id}"]`);
                        wigglePanel.classList.toggle('active', state.controls[id].isWiggling);
                        wiggleBtn.classList.toggle('active', state.controls[id].isWiggling);
                        document.getElementById(`${id}-base`).dispatchEvent(new Event('input'));
                        document.getElementById(`${id}-amt`).dispatchEvent(new Event('input'));
                        document.getElementById(`${id}-spd`).dispatchEvent(new Event('input'));
                    }
                });
            }
            if (state.checkboxes) {
                mirrorChk.checked = state.checkboxes.mirrorChk ?? true;
                animateChk.checked = state.checkboxes.animateChk ?? true;
                trackCenterChk.checked = state.checkboxes.trackCenterChk ?? true;
                preciseMaskChk.checked = state.checkboxes.preciseMaskChk ?? true;
            }
            if (state.effects) {
                activeEffects = new Set(state.effects);
                updateEffectUI();
            }
        }

        function getPresets() { return JSON.parse(localStorage.getItem('faceGlitchV3Presets') || '{}'); }
        function savePresets(presets) { localStorage.setItem('faceGlitchV3Presets', JSON.stringify(presets)); }

        function populatePresetList() {
            const presets = getPresets();
            presetList.innerHTML = '<option value="">Load a preset...</option>';
            for(const name in presets) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                presetList.appendChild(opt);
            }
        }
        
        function updateEffectUI() {
            document.querySelectorAll('.dynamic-controls .control-group').forEach(panel => {
                panel.classList.toggle('active', activeEffects.has(panel.dataset.effect));
            });
            effectBtns.forEach(btn => {
                btn.classList.toggle('active', activeEffects.has(btn.dataset.effect));
            });
        }
        
        effectBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const effectName = btn.dataset.effect;
                if (activeEffects.has(effectName)) { activeEffects.delete(effectName); } else { activeEffects.add(effectName); }
                updateEffectUI();
            });
        });
        document.querySelectorAll('.control-group-header').forEach(header => { header.addEventListener('click', () => header.parentElement.classList.toggle('collapsed')); });
        
        savePresetBtn.addEventListener('click', () => {
            const name = presetNameInput.value.trim();
            if(!name) { setMsg('Please enter a name for the preset.', true); return; }
            const presets = getPresets(); presets[name] = getAppState();
            savePresets(presets); populatePresetList();
            presetList.value = name; setMsg(`Preset '${name}' saved.`);
        });
        deletePresetBtn.addEventListener('click', () => {
             const name = presetList.value; if(!name) { setMsg('Select a preset to delete.', true); return; }
             const presets = getPresets(); delete presets[name];
             savePresets(presets); populatePresetList(); setMsg(`Preset '${name}' deleted.`);
        });
        presetList.addEventListener('change', () => {
            const name = presetList.value; if(!name) return;
            const presets = getPresets();
            if(presets[name]) { setAppState(presets[name]); presetNameInput.value = name; setMsg(`Preset '${name}' loaded.`); }
        });
        randomBtn.addEventListener('click', () => {
            const rand = (min,max) => min + Math.random() * (max-min);
            Object.keys(controlDefinitions).forEach(id => {
                const def = controlDefinitions[id];
                const baseVal = rand(def.min, def.max);
                document.getElementById(`${id}-base`).value = baseVal;
                document.getElementById(`${id}-base`).dispatchEvent(new Event('input'));
                
                const isWiggling = Math.random() > 0.7;
                const wiggleAmt = isWiggling ? rand(0, (def.max-def.min)/4) : 0;
                const wiggleSpd = isWiggling ? rand(0.1, 5) : 1;
                document.getElementById(`${id}-amt`).value = wiggleAmt;
                document.getElementById(`${id}-spd`).value = wiggleSpd;
                document.getElementById(`${id}-amt`).dispatchEvent(new Event('input'));
                document.getElementById(`${id}-spd`).dispatchEvent(new Event('input'));
                
                const wigglePanel = document.getElementById(`${id}-wiggle-panel`);
                const wiggleBtn = document.querySelector(`[data-id="${id}"]`);
                wigglePanel.classList.toggle('active', isWiggling);
                wiggleBtn.classList.toggle('active', isWiggling);
                controlsState[id].isWiggling = isWiggling;
            });

            activeEffects.clear();
            ALL_EFFECTS.forEach(effect => { if(Math.random() > 0.5) activeEffects.add(effect); });
            if (activeEffects.size === 0) activeEffects.add(ALL_EFFECTS[Math.floor(rand(0, ALL_EFFECTS.length))]);
            updateEffectUI();
            setMsg('Parameters randomized!');
        });
        
        populatePresetList();
        activeEffects.add('Turbulence');
        updateEffectUI();
        (async () => { try { const p = await navigator.permissions.query({ name: 'camera' }); if (p.state === 'granted') start(); } catch { } })();
    })();
    </script>
</body>
</html>
