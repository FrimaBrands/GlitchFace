<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>U N K N O W N // Preview</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
  <style>
    body { 
        font-family: 'JetBrains Mono', monospace; 
        background-color: #000000;
        color: #EAEAEA;
        overflow: hidden;
    }
  </style>
</head>
<body class="bg-black">
  <div class="main-stage w-screen h-screen relative flex items-center justify-center overflow-hidden">
    <video id="video" playsinline muted class="hidden"></video>
    <video id="backgroundMedia" loop muted playsinline class="hidden absolute w-full h-full object-cover"></video>
    <img id="backgroundImage" class="hidden absolute w-full h-full object-cover" />
    <canvas id="glcanvas" class="w-full h-full object-cover"></canvas>
    </div>

  <script>
  // --- All JavaScript functionality remains unchanged, except for the UI module, which now broadcasts status messages. ---
  (() => {
    // --- APP ARCHITECTURE ---
    const vertSrc = `
      attribute vec2 a_pos;
      varying vec2 v_uv;
      void main() {
        v_uv = a_pos;
        gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
      }`;

    const fragSrc = `
      precision highp float;
      varying vec2 v_uv;

      // Textures
      uniform sampler2D u_tex;
      uniform sampler2D u_feedbackTex;
      uniform sampler2D u_maskTex;
      uniform sampler2D u_backgroundTex;

      // Global uniforms
      uniform vec2  u_resolution;
      uniform float u_time;
      uniform bool  u_isFeedbackPass;
      uniform bool  u_useBackground;
      uniform float u_maskFeather;

      // Opacity uniforms (not randomized)
      uniform float u_overallOpacity;
      uniform float u_flickerPerSecond;
      uniform float u_flickerDuration;
      uniform float u_flickerIntensity;
      uniform float u_flickerFade;

      // Seep uniforms (not randomized)
      uniform float u_seepAmount;
      uniform float u_seepIntensity;

      // Effect uniforms (randomized)
      uniform float u_feedbackAmount;
      uniform float u_feedbackZoom;
      uniform float u_glitchIntensity;
      uniform float u_glitchBlockSize;
      uniform float u_rgbShift;
      uniform float u_noiseAmount;
      uniform float u_noiseSpeed;
      uniform float u_vignette;
      
      // Smear uniforms
      uniform float u_globalSmearIntensity;
      uniform float u_globalSmearAngle;
      uniform float u_spotSmearIntensity;
      uniform float u_spotSmearDensity;
      uniform float u_spotSmearSize;


      // --- Helper Functions ---
      float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }

      // Generic smear effect
      vec4 smear(sampler2D tex, vec2 uv, float intensity, float angle) {
        vec2 dir = vec2(cos(angle), sin(angle)) / u_resolution;
        vec4 color = vec4(0.0);
        const int samples = 16;
        for (int i = 0; i < samples; i++) {
          float t = float(i) / float(samples - 1);
          color += texture2D(tex, uv - dir * t * intensity);
        }
        return color / float(samples);
      }
      
      // Simple box blur for creating the 'seep' effect
      vec4 blur(sampler2D tex, vec2 uv, float radius) {
          vec4 acc = vec4(0.0);
          vec2 res = u_resolution.xy;
          float count = 0.0;
          // A 5x5 kernel for a small, efficient blur
          for(float x = -2.0; x <= 2.0; x++) {
              for(float y = -2.0; y <= 2.0; y++) {
                  vec2 offset = vec2(x, y) * radius / res;
                  acc += texture2D(tex, uv + offset);
                  count += 1.0;
              }
          }
          return acc / count;
      }

      void main() {
        vec2 uv = v_uv;
        vec4 videoColor = texture2D(u_tex, uv);

        // --- EFFECT PIPELINE ---
        vec4 feedbackColor = texture2D(u_feedbackTex, (uv - 0.5) * u_feedbackZoom + 0.5);
        vec4 effectedColor = mix(videoColor, feedbackColor, u_feedbackAmount);

        if (rand(vec2(floor(u_time * 15.0), 0.0)) < u_glitchIntensity) {
          vec2 block_uv = floor(uv * u_resolution.y / u_glitchBlockSize) / (u_resolution.y / u_glitchBlockSize);
          effectedColor = texture2D(u_tex, uv + vec2((rand(block_uv) - 0.5) * 0.1, 0.0));
        }

        float r = texture2D(u_tex, uv + vec2(u_rgbShift, 0.0)).r;
        float b = texture2D(u_tex, uv - vec2(u_rgbShift, 0.0)).b;
        effectedColor = vec4(r, effectedColor.g, b, effectedColor.a);

        effectedColor += (rand(uv + u_time * u_noiseSpeed) - 0.5) * u_noiseAmount;
        effectedColor.rgb *= 1.0 - u_vignette * distance(uv, vec2(0.5));

        vec4 smearedColor = effectedColor;
        
        vec2 grid_uv = floor(uv * u_spotSmearSize) / u_spotSmearSize;
        if (rand(grid_uv + floor(u_time * 5.0)) < u_spotSmearDensity) {
          smearedColor = smear(u_feedbackTex, uv, u_spotSmearIntensity, rand(grid_uv + 10.0) * 6.283);
        }

        float maskValue = texture2D(u_maskTex, uv).r;
        if (maskValue > 0.1) {
            vec4 globalSmear = smear(u_feedbackTex, uv, u_globalSmearIntensity, radians(u_globalSmearAngle));
            smearedColor = mix(smearedColor, globalSmear, 0.5);
        }


        float effectedGray = dot(smearedColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 effectedGrayscale = vec4(vec3(effectedGray), 1.0);

        // --- RENDER PASS LOGIC ---
        if (u_isFeedbackPass) {
          gl_FragColor = effectedGrayscale;
          return;
        }

        // --- FINAL COMPOSITION (Screen Pass) ---
        float originalGray = dot(videoColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 originalGrayscale = vec4(vec3(originalGray), 1.0);

        float baseMask = texture2D(u_maskTex, uv).r;
        float blurredMask = blur(u_maskTex, uv, u_seepIntensity).r;
        float seep = (1.0 - baseMask) * blurredMask * u_seepAmount;

        float finalMask = smoothstep(0.5 - u_maskFeather, 0.5 + u_maskFeather, baseMask);
        float silhouetteMask = clamp(finalMask + seep, 0.0, 1.0);

        // Calculate flicker
        float flickerMultiplier = 1.0;
        if (u_flickerPerSecond > 0.0) {
            float flickerCycle = 1.0 / u_flickerPerSecond;
            float flickerPhase = mod(u_time, flickerCycle);
            float flickerEdge = flickerCycle * u_flickerDuration;
            
            float fadeWidth = flickerCycle * u_flickerFade * 0.5;
            float isFlickerOff = 1.0 - smoothstep(flickerEdge - fadeWidth, flickerEdge + fadeWidth, flickerPhase);
            flickerMultiplier = 1.0 - (isFlickerOff * u_flickerIntensity);
        }

        // 'effectAmount' now combines opacity and flicker. This controls HOW MUCH effect is applied.
        float effectAmount = u_overallOpacity * flickerMultiplier;

        // The foreground color is a mix of the original body and the fully effected body.
        vec4 foregroundColor = mix(originalGrayscale, effectedGrayscale, effectAmount);
        
        // Determine the background color
        vec4 backgroundColor = u_useBackground ? texture2D(u_backgroundTex, uv) : originalGrayscale;

        // Mix the background with the calculated foreground color using the silhouette mask.
        gl_FragColor = mix(backgroundColor, foregroundColor, silhouetteMask);
      }`;

    const UI = {
      elements: {},
      state: {},
      channel: null,
      
      init(definitions, globalDefinitions, channel) {
        this.channel = channel;
        const ids = ['video', 'glcanvas', 'backgroundMedia', 'backgroundImage'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.state = {
          controls: {},
          toggles: {},
          checkboxes: { animateChk: true, mirrorChk: true, useBgChk: false },
          globalControls: {},
          misc: { maskFeather: 0.15 }
        };

        for (const [key, def] of Object.entries(definitions)) {
          this.state.controls[key] = {};
          this.state.toggles[key] = def.active;
          for (const [controlKey, controlDef] of Object.entries(def.controls)) {
            this.state.controls[key][controlKey] = controlDef.value;
          }
        }
        for (const [key, def] of Object.entries(globalDefinitions)) {
            this.state.globalControls[key] = {};
            for (const [controlKey, controlDef] of Object.entries(def.controls)) {
                this.state.globalControls[key][controlKey] = controlDef.value;
            }
        }
      },

      updateState(newState) {
        if (!newState) return;
        this.state.controls = newState.controls ?? this.state.controls;
        this.state.toggles = newState.toggles ?? this.state.toggles;
        this.state.globalControls = newState.globalControls ?? this.state.globalControls;
      },
      
      updateCheckboxes(newCheckboxes) {
        this.state.checkboxes = { ...this.state.checkboxes, ...newCheckboxes };
        if (this.elements.glcanvas) {
            this.elements.glcanvas.style.transform = this.state.checkboxes.mirrorChk ? 'scaleX(-1)' : 'none';
        }
      },

      updateMisc(newMisc) {
        this.state.misc = { ...this.state.misc, ...newMisc };
      },

      setStatus(text, isError = false) {
        if (this.channel) {
            this.channel.postMessage({
                type: 'statusUpdate',
                payload: { text, isError }
            });
        }
      },
    };

    const Renderer = {
      gl: null, program: null, textures: {}, framebuffers: {}, uniforms: {},
      maskCanvas: document.createElement('canvas'),

      init(canvas, vsSrc, fsSrc, uniformKeys) {
        this.gl = canvas.getContext('webgl', { premultipliedAlpha: false, antialias: true });
        if (!this.gl) throw new Error('WebGL not available');

        const compile = (type, src) => {
          const s = this.gl.createShader(type);
          this.gl.shaderSource(s, src); this.gl.compileShader(s);
          if (!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) throw new Error(`Shader compile error: ${this.gl.getShaderInfoLog(s)}`);
          return s;
        };
        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, compile(this.gl.VERTEX_SHADER, vsSrc));
        this.gl.attachShader(this.program, compile(this.gl.FRAGMENT_SHADER, fsSrc));
        this.gl.linkProgram(this.program);
        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) throw new Error(`Program link error: ${this.gl.getProgramInfoLog(this.program)}`);
        
        const buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), this.gl.STATIC_DRAW);
        const posLoc = this.gl.getAttribLocation(this.program, 'a_pos');
        this.gl.enableVertexAttribArray(posLoc); this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);

        const createTex = () => {
          const tex = this.gl.createTexture();
          this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          return tex;
        };
        this.textures = { video: createTex(), feedbackA: createTex(), feedbackB: createTex(), mask: createTex(), background: createTex() };
        this.framebuffers.feedback = this.gl.createFramebuffer();
        
        this.gl.useProgram(this.program);
        uniformKeys.forEach(key => this.uniforms[key] = this.gl.getUniformLocation(this.program, key));
      },

      fit(video) {
        if (!video.videoWidth) return;
        const { videoWidth: w, videoHeight: h } = video;
        const canvas = this.gl.canvas;
        if (canvas.width === w && canvas.height === h) return;
        canvas.width = w; canvas.height = h;
        const resizableTextures = [this.textures.video, this.textures.feedbackA, this.textures.feedbackB, this.textures.mask];
        for (const tex of resizableTextures) {
          this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, w, h, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
        }
        this.gl.viewport(0, 0, w, h);
      },

      drawMask(video, segmentationMask) {
        const { videoWidth: W, videoHeight: H } = video;
        const ctx = this.maskCanvas.getContext('2d');
        if (this.maskCanvas.width !== W || this.maskCanvas.height !== H) {
          this.maskCanvas.width = W; this.maskCanvas.height = H;
        }
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, W, H);
        if (segmentationMask) ctx.drawImage(segmentationMask, 0, 0, W, H);

        this.gl.activeTexture(this.gl.TEXTURE2); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.mask);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.maskCanvas);
      },

      render(appState) {
        const { video, t, uiState } = appState;
        this.gl.useProgram(this.program);
        
        this.gl.activeTexture(this.gl.TEXTURE0); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.video);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, video);
        
        const backgroundMedia = !UI.elements.backgroundImage.classList.contains('hidden') ? UI.elements.backgroundImage : UI.elements.backgroundMedia;
        if (uiState.checkboxes.useBgChk && (backgroundMedia.videoWidth || backgroundMedia.naturalWidth || backgroundMedia.width)) {
            this.gl.activeTexture(this.gl.TEXTURE3);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.background);
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, backgroundMedia);
        }

        this.gl.uniform2f(this.uniforms.u_resolution, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform1f(this.uniforms.u_time, t);

        for (const [groupKey, group] of Object.entries(uiState.controls)) {
          const groupIsActive = uiState.toggles[groupKey];
          for (const [controlKey, value] of Object.entries(group)) {
            let val = groupIsActive ? parseFloat(value) : App.definitions[groupKey].controls[controlKey].neutral;
            this.gl.uniform1f(this.uniforms[`u_${controlKey}`], val);
          }
        }
        for (const [groupKey, group] of Object.entries(uiState.globalControls)) {
            for (const [controlKey, value] of Object.entries(group)) {
                this.gl.uniform1f(this.uniforms[`u_${controlKey}`], parseFloat(value));
            }
        }

        this.gl.uniform1i(this.uniforms.u_useBackground, uiState.checkboxes.useBgChk);
        this.gl.uniform1f(this.uniforms.u_maskFeather, uiState.misc.maskFeather);

        this.gl.uniform1i(this.uniforms.u_tex, 0); this.gl.uniform1i(this.uniforms.u_feedbackTex, 1);
        this.gl.uniform1i(this.uniforms.u_maskTex, 2); this.gl.uniform1i(this.uniforms.u_backgroundTex, 3);
        
        this.gl.activeTexture(this.gl.TEXTURE1); this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.feedbackA);

        this.gl.uniform1i(this.uniforms.u_isFeedbackPass, 1);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffers.feedback);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.textures.feedbackB, 0);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

        this.gl.uniform1i(this.uniforms.u_isFeedbackPass, 0);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

        [this.textures.feedbackA, this.textures.feedbackB] = [this.textures.feedbackB, this.textures.feedbackA];
      }
    };

    const BodySegmenter = {
      segmenter: null, lastResult: null, isReady: false, isBusy: false,
      lastUpdateTime: 0, minInterval: 60,

      async init() {
        if (this.isReady) return true;
        try {
          this.segmenter = new window.SelfieSegmentation({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}` });
          this.segmenter.setOptions({ modelSelection: 1 });
          this.segmenter.onResults(res => { this.lastResult = res.segmentationMask; this.isBusy = false; });
          await this.segmenter.initialize();
          this.isReady = true; return true;
        } catch (err) { console.error("Selfie Segmentation initialization failed:", err); return false; }
      },
      update(video) {
        const now = performance.now();
        if (this.isReady && !this.isBusy && (now - this.lastUpdateTime) > this.minInterval) {
          this.isBusy = true; this.lastUpdateTime = now; this.segmenter.send({ image: video });
        }
      }
    };

    const PresetManager = {
      channel: null,
      init(channel) {
        this.channel = channel;
      },
      getPresets: () => JSON.parse(localStorage.getItem('bodyGlitchV5.0Presets') || '{}'),
      savePresets: (p) => localStorage.setItem('bodyGlitchV5.0Presets', JSON.stringify(p)),
      
      save(name) {
        if (!name) return;
        const presets = this.getPresets();
        presets[name] = UI.state;
        this.savePresets(presets);
        this.channel.postMessage({ type: 'updatePresetList', payload: Object.keys(presets) });
      },
      delete(name) {
        if (!name) return;
        const presets = this.getPresets();
        delete presets[name];
        this.savePresets(presets);
        this.channel.postMessage({ type: 'updatePresetList', payload: Object.keys(presets) });
      },
      load(name) {
        if (!name) return;
        const presets = this.getPresets();
        if (presets[name]) {
          UI.updateState(presets[name]);
          UI.updateCheckboxes(presets[name].checkboxes || {});
          UI.updateMisc(presets[name].misc || {});
          // Inform controls to update its UI
          this.channel.postMessage({ type: 'stateUpdate', payload: UI.state });
        }
      },
      randomize() {
        const newState = JSON.parse(JSON.stringify(UI.state)); // Deep copy
        for (const [groupKey, group] of Object.entries(App.definitions)) {
          newState.toggles[groupKey] = Math.random() > 0.3;
          for (const [controlKey, controlDef] of Object.entries(group.controls)) {
            const min = controlDef.min, max = controlDef.max, step = controlDef.step;
            const randomVal = Math.round((min + Math.random() * (max - min)) / step) * step;
            newState.controls[groupKey][controlKey] = randomVal;
          }
        }
        UI.updateState(newState);
        this.channel.postMessage({ type: 'stateUpdate', payload: UI.state });
      }
    };
    
    const Automation = {
        lastRandomizeTime: 0,
        lastPresetIterateTime: 0,
        currentPresetIndex: 0,
        randomizeInterval: 0,
        presetInterval: 0,

        update(time) {
            // Auto-Randomize Logic
            if (this.randomizeInterval > 0) {
                if (this.lastRandomizeTime === 0) this.lastRandomizeTime = time;
                if ((time - this.lastRandomizeTime) > this.randomizeInterval * 1000) {
                    PresetManager.randomize();
                    this.lastRandomizeTime = time;
                }
            } else {
                this.lastRandomizeTime = 0;
            }
            
            // Preset Iteration Logic
            if (this.presetInterval > 0) {
                if (this.lastPresetIterateTime === 0) this.lastPresetIterateTime = time;
                if ((time - this.lastPresetIterateTime) > this.presetInterval * 1000) {
                    const presets = PresetManager.getPresets();
                    const presetNames = Object.keys(presets);
                    if (presetNames.length > 0) {
                        this.currentPresetIndex = (this.currentPresetIndex + 1) % presetNames.length;
                        PresetManager.load(presetNames[this.currentPresetIndex]);
                    }
                    this.lastPresetIterateTime = time;
                }
            } else {
                this.lastPresetIterateTime = 0;
            }
        }
    };

    const App = {
      stream: null, rafId: null, shaders: {}, definitions: {}, globalDefinitions: {}, channel: null,

      async start() {
        if (!navigator.mediaDevices?.getUserMedia) return;
        try {
          UI.setStatus('Requesting camera...');
          this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 1280, height: 720 }, audio: false });
          const video = UI.elements.video;
          video.srcObject = this.stream;
          await new Promise(resolve => { video.onloadedmetadata = resolve; });
          await video.play();

          UI.setStatus('Initializing GL...');
          const uniformKeys = ['u_resolution', 'u_time', 'u_isFeedbackPass', 'u_tex', 'u_feedbackTex', 'u_maskTex', 'u_backgroundTex', 'u_useBackground', 'u_maskFeather'];
          Object.values(this.definitions).forEach(def => uniformKeys.push(...Object.keys(def.controls).map(c => `u_${c}`)));
          Object.values(this.globalDefinitions).forEach(def => uniformKeys.push(...Object.keys(def.controls).map(c => `u_${c}`)));
          Renderer.init(UI.elements.glcanvas, this.shaders.vert, this.shaders.frag, uniformKeys);
          Renderer.fit(UI.elements.video);

          UI.setStatus('Initializing Body Segmentation...');
          if (!(await BodySegmenter.init())) return UI.setStatus('Segmentation Failed', true);

          UI.setStatus('Running');
          this.loop();
        } catch (err) {
          console.error(err);
          UI.setStatus('Error', true);
        }
      },

      loop(time) {
        this.rafId = requestAnimationFrame(t => this.loop(t));
        const video = UI.elements.video;
        if (!video.videoWidth || !Renderer.gl) return;
        
        Renderer.fit(video);
        BodySegmenter.update(video);
        Renderer.drawMask(video, BodySegmenter.lastResult);
        
        Automation.update(time);
        
        Renderer.render({
          video: video,
          t: UI.state.checkboxes.animateChk ? time / 1000 : 0,
          uiState: UI.state,
        });
        
        const statusText = BodySegmenter.lastResult
          ? `BODY DETECTED [${Renderer.gl.canvas.width}x${Renderer.gl.canvas.height}]` 
          : `NO SIGNAL...`;
        UI.setStatus(statusText);
      },

      init(definitions, globalDefinitions, shaders) {
        this.shaders = shaders;
        this.definitions = definitions;
        this.globalDefinitions = globalDefinitions;
        
        this.channel = new BroadcastChannel('unknown_controls');
        UI.init(definitions, globalDefinitions, this.channel);

        this.channel.onmessage = (ev) => {
            const { type, payload, name } = ev.data;
            switch (type) {
                case 'requestState':
                    this.channel.postMessage({ type: 'stateUpdate', payload: UI.state });
                    this.channel.postMessage({ type: 'updatePresetList', payload: Object.keys(PresetManager.getPresets()) });
                    break;
                case 'stateUpdate':
                    UI.updateState(payload);
                    break;
                case 'checkboxUpdate':
                    UI.updateCheckboxes(payload);
                    break;
                case 'miscUpdate':
                    UI.updateMisc(payload);
                    break;
                case 'automationUpdate':
                    Automation.randomizeInterval = payload.autoRandomizeInterval;
                    Automation.presetInterval = payload.presetIterationInterval;
                    break;
                case 'triggerAction':
                    if (name === 'randomize') PresetManager.randomize();
                    else if (name === 'savePreset') PresetManager.save(payload);
                    else if (name === 'deletePreset') PresetManager.delete(payload);
                    else if (name === 'loadPreset') PresetManager.load(payload);
                    else if (name === 'start') this.start();
                    else if (name === 'stop') this.stop();
                    break;
            }
        };

        PresetManager.init(this.channel);
        this.start(); // Automatically start on load
      }
    };
    
    // --- Entry Point ---
    const definitions = {
      Jitter: { title: 'Jitter Animation', active: true, controls: { jitterAmount: { label: 'Amount', min: 0, max: 0.1, step: 0.001, value: 0.0, neutral: 0.0 }, jitterSpeed: { label: 'Speed', min: 0, max: 10, step: 0.1, value: 2.5, neutral: 0.0 } } },
      Smear: { title: 'Smearing', active: true, controls: { globalSmearIntensity: { label: 'Global Intensity', min: 0, max: 100, step: 1, value: 0, neutral: 0.0 }, globalSmearAngle: { label: 'Global Angle', min: 0, max: 360, step: 1, value: 0, neutral: 0.0 }, spotSmearIntensity: { label: 'Spot Intensity', min: 0, max: 50, step: 1, value: 0, neutral: 0.0 }, spotSmearDensity: { label: 'Spot Density', min: 0, max: 1, step: 0.01, value: 0.0, neutral: 0.0 }, spotSmearSize: { label: 'Spot Size', min: 5, max: 50, step: 1, value: 20, neutral: 0.0 } } },
      Feedback: { title: 'Data Moshing', active: true, controls: { feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.97, neutral: 0.0 }, feedbackZoom: { label: 'Zoom', min: 0.9, max: 1.1, step: 0.001, value: 1.001, neutral: 1.0 } } },
      Glitch: { title: 'Signal Glitch', active: true, controls: { glitchIntensity: { label: 'Intensity', min: 0, max: 1, step: 0.01, value: 0.0, neutral: 0.0 }, glitchBlockSize: { label: 'Block Size', min: 1, max: 50, step: 1, value: 8, neutral: 0.0 } } },
      Color: { title: 'Color Distortion', active: true, controls: { rgbShift: { label: 'RGB Shift', min: 0, max: 0.1, step: 0.001, value: 0.0, neutral: 0.0 } } },
      Distortion: { title: 'Lens Distortion', active: true, controls: { noiseAmount: { label: 'Noise Amount', min: 0, max: 0.5, step: 0.01, value: 0.0, neutral: 0.0 }, noiseSpeed:  { label: 'Noise Speed',  min: 0, max: 10, step: 0.1, value: 1, neutral: 0.0 }, vignette:    { label: 'Vignette',     min: 0, max: 2,  step: 0.01, value: 0.0, neutral: 0.0 } } }
    };
    const globalDefinitions = {
        Opacity: { title: 'Global Opacity', active: true, controls: { overallOpacity: { label: 'Effect Opacity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 1.0 }, flickerPerSecond: { label: 'Flickers per Second', min: 0, max: 30, step: 0.1, value: 0, neutral: 0 }, flickerDuration: { label: 'Flicker Off Ratio', min: 0.01, max: 1, step: 0.01, value: 0.1, neutral: 0.1 }, flickerIntensity: { label: 'Flicker Intensity', min: 0, max: 1, step: 0.01, value: 1.0, neutral: 0.0 }, flickerFade: { label: 'Flicker Fade', min: 0.0, max: 0.5, step: 0.01, value: 0.05, neutral: 0.0 }}},
        Seep: { title: 'Effect Seep', active: true, controls: { seepAmount: { label: 'Seep Amount', min: 0, max: 2.0, step: 0.01, value: 0.0, neutral: 0.0 }, seepIntensity: { label: 'Seep Distance', min: 0, max: 20, step: 0.1, value: 0.0, neutral: 0.0 }}}
    };

    App.init(definitions, globalDefinitions, { vert: vertSrc, frag: fragSrc });

  })();
  </script>

</body>
</html>
