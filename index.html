<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Face Glitch V2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0d11;
            --panel: #11141a;
            --stroke: #1f2430;
            --fg: #e5e7eb;
            --muted: #9aa0aa;
            --accent: #6ee7b7;
            --danger: #f87171;
            --primary-bg: #1a202c;
            --secondary-bg: #2d3748;
            --text-color: #f7fafc;
            --primary-color: #6ee7b7;
            --border-color: #4a5568;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            --radius-sm: 8px;
            --radius-md: 12px;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: var(--bg); color: var(--text-color); }
        body { display: flex; justify-content: center; align-items: center; padding: 20px; background: radial-gradient(circle at center, #1a1f26 0%, #0d0f13 100%); }
        .container { display: flex; width: 100%; max-width: 1600px; height: 90vh; border-radius: var(--radius-md); overflow: hidden; box-shadow: var(--shadow); background: var(--primary-bg); border: 1px solid var(--border-color); }
        .main-stage { flex: 3; position: relative; background: #0d0f13; display: flex; align-items: center; justify-content: center; }
        #glcanvas, #video { width: 100%; height: 100%; object-fit: contain; display: block; }
        #video { display: none; }
        .controls-panel { flex: 1; min-width: 400px; padding: 24px; display: flex; flex-direction: column; overflow-y: auto; background: var(--secondary-bg); }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; border-bottom: 1px solid var(--border-color); padding-bottom: 16px; }
        h1 { font-size: 24px; font-weight: 600; margin: 0; letter-spacing: -0.5px; }
        .btn { padding: 10px 16px; border: 1px solid var(--border-color); border-radius: var(--radius-sm); background-color: transparent; color: var(--text-color); font-size: 14px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; font-family: 'Poppins', sans-serif; }
        .btn:hover:not(:disabled) { background-color: rgba(255, 255, 255, 0.1); border-color: var(--primary-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #1a1f26; font-weight: 600; }
        .btn-primary:hover:not(:disabled) { background-color: #55d4a6; border-color: #55d4a6; }
        .section-heading { font-size: 18px; font-weight: 600; margin: 20px 0 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); }
        .effect-stack { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
        .effect-toggle { display: flex; align-items: center; justify-content: space-between; background: var(--primary-bg); padding: 12px; border-radius: var(--radius-sm); border: 1px solid var(--border-color); cursor: pointer; transition: all 0.2s; }
        .effect-toggle:hover { border-color: var(--primary-color); }
        .effect-toggle.active { background: rgba(110, 231, 183, 0.1); border-color: var(--primary-color); }
        .effect-toggle span { font-weight: 600; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .switch-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border-color); transition: .4s; border-radius: 24px; }
        .switch-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .switch-slider { background-color: var(--primary-color); }
        input:checked + .switch-slider:before { transform: translateX(20px); }
        .control-group { border: 1px solid var(--border-color); border-radius: var(--radius-md); margin-bottom: 10px; background: var(--primary-bg); display: none; }
        .control-group.active { display: block; }
        .control-group-header { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-weight: 600; transition: background-color 0.2s; }
        .control-group-header:hover { background-color: rgba(255, 255, 255, 0.05); }
        .control-group-content { padding: 12px 16px; border-top: 1px solid var(--border-color); }
        .control-grid { display: grid; grid-template-columns: 1fr; gap: 16px; }
        @media (min-width: 600px) { .control-grid { grid-template-columns: 1fr 1fr; } }
        .control-item { display: flex; flex-direction: column; gap: 6px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
        .slider-input { width: 100%; height: 4px; border-radius: 2px; background: var(--border-color); -webkit-appearance: none; appearance: none; outline: none; }
        .slider-input::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #0d0f13; }
        .slider-input::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #0d0f13; }
        .options-list { display: flex; flex-direction: column; gap: 10px; }
        .options-list label { display: flex; align-items: center; gap: 10px; font-size: 14px; cursor: pointer; }
        .preset-manager { margin-top: 16px; display: flex; flex-direction: column; gap: 10px; }
        .preset-controls { display: flex; gap: 8px; }
        .preset-controls input { flex-grow: 1; background: var(--primary-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 8px; border-radius: var(--radius-sm); }
        #presetList { display: flex; flex-direction: column; gap: 8px; max-height: 150px; overflow-y: auto; padding: 8px; background: var(--primary-bg); border-radius: var(--radius-sm); }
        .preset-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-radius: 4px; cursor: pointer; transition: background 0.2s; }
        .preset-item:hover { background: rgba(255, 255, 255, 0.1); }
        .preset-delete-btn { background: none; border: none; color: var(--danger); cursor: pointer; font-size: 16px; }
        .status-bar { margin-top: auto; padding-top: 16px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--muted); }
        .status-badge { background: var(--primary-bg); padding: 4px 8px; border-radius: var(--radius-sm); border: 1px solid var(--border-color); font-size: 10px; }
        .status-error { color: var(--danger); }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-stage">
            <video id="video" playsinline muted></video>
            <canvas id="glcanvas" aria-label="camera with face effects"></canvas>
        </div>
        <div class="controls-panel">
            <div class="header">
                <h1>Face Glitch V2</h1>
                <div class="header-actions">
                    <button id="startBtn" class="btn btn-primary">Start Camera</button>
                    <button id="stopBtn" class="btn" disabled>Stop</button>
                </div>
            </div>

            <div id="globalControls">
                 <div class="section-heading">Global Controls</div>
                 <div class="control-grid">
                     <div class="control-item">
                         <label class="slider-label">Master Mix<span id="mixVal">1.00</span></label>
                         <input type="range" id="mix" min="0" max="1" step="0.01" value="1.0" class="slider-input">
                     </div>
                     <div class="control-item">
                         <label class="slider-label">Animation Speed<span id="speedVal">1.00</span></label>
                         <input type="range" id="speed" min="0" max="5" step="0.01" value="1.0" class="slider-input">
                     </div>
                      <div class="control-item">
                         <label class="slider-label">Mask Feather<span id="featherVal">20</span></label>
                         <input type="range" id="feather" min="0" max="100" step="1" value="20" class="slider-input">
                     </div>
                     <div class="control-item">
                         <label class="slider-label">Mask Padding (px)<span id="padVal">15</span></label>
                         <input type="range" id="pad" min="-50" max="150" step="1" value="15" class="slider-input">
                     </div>
                 </div>
                 <div class="options-list" style="margin-top: 16px;">
                     <label><input type="checkbox" id="mirrorChk" checked> Mirror Camera</label>
                     <label><input type="checkbox" id="animateChk" checked> Animate Effects</label>
                     <label><input type="checkbox" id="trackCenterChk" checked> Track Center of Face</label>
                     <label><input type="checkbox" id="preciseMaskChk" checked> Use Precise Face Mesh</label>
                     <label><input type="checkbox" id="invertMaskChk"> Invert Mask</label>
                 </div>
            </div>

            <div class="section-heading">Effect Stack</div>
            <div class="effect-stack" id="effectStack">
                </div>
            <div id="effectControlsContainer">
                </div>

            <div class="section-heading">Presets</div>
             <div class="preset-manager">
                 <div class="preset-controls">
                     <input type="text" id="presetName" placeholder="Preset Name">
                     <button id="savePresetBtn" class="btn btn-primary">Save</button>
                 </div>
                 <div id="presetList"></div>
                 <button id="randomBtn" class="btn">Randomize All</button>
             </div>

            <div class="status-bar">
                <span id="msg" class="status-error"></span>
                <span id="status2" class="status-badge">Idle</span>
            </div>
        </div>
    </div>
    <script>
    (() => {
        // --- V2 Feature Flags ---
        const V2_FEATURES = {
            EFFECT_STACKING: true,
            PRESET_SAVING: true,
            ADVANCED_EFFECTS: true,
            TRACKING_FIX: true,
            MASK_FIX: true,
        };

        // --- DOM Elements ---
        const video = document.getElementById('video');
        const canvas = document.getElementById('glcanvas');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const msgEl = document.getElementById('msg');
        const status2El = document.getElementById('status2');
        
        // --- State Variables ---
        let stream = null, rafId = null, gl = null, program = null, tex = null, buf = null;
        let lastFacesMesh = [];
        let effectCenter = { x: 0.5, y: 0.5 };
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
        let maskTex = null;
        let faceMesh = null;
        let faceMeshReady = false;
        let fmBusy = false;
        let lastFmTime = 0;
        const FM_MIN_INTERVAL = 50; // ms
        const FACE_OVAL_INDICES = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
        
        // --- WebGL Source ---
        const vertSrc = `
            attribute vec2 a_pos;
            varying vec2 v_uv;
            void main() {
                v_uv = a_pos;
                gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
            }`;

        const fragSrc = `
            precision highp float;
            varying vec2 v_uv;

            // Textures
            uniform sampler2D u_tex;
            uniform sampler2D u_maskTex;

            // Global settings
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_speed;
            uniform float u_masterMix;
            uniform bool u_mirror;

            // Mask settings
            uniform vec2 u_center;
            uniform bool u_usePreciseMask;
            uniform bool u_invertMask;
            uniform float u_feather;

            // Effect-specific uniforms
            uniform bool u_smear_enabled;
            uniform float u_smear_len;
            uniform float u_smear_ang;
            uniform int u_smear_samples;
            uniform float u_smear_pingpong;

            uniform bool u_pixelate_enabled;
            uniform float u_pixelate_size;
            uniform float u_pixelate_pattern_scale;
            
            uniform bool u_noiseflow_enabled;
            uniform float u_noiseflow_scale;
            uniform float u_noiseflow_strength;

            uniform bool u_jitter_enabled;
            uniform float u_jitter_amount;
            uniform float u_jitter_speed;

            uniform bool u_chroma_enabled;
            uniform float u_chroma_amount;

            uniform bool u_distort_enabled;
            uniform float u_distort_freq;
            uniform float u_distort_amp;

            // --- Utility Functions ---
            float rand(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
            vec3 hash3(vec2 p) {
                vec3 q = vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)));
                return fract(sin(q) * 43758.5453);
            }

            // --- Masking ---
            float getMaskValue(vec2 uv) {
                float mask = 1.0;
                if (u_usePreciseMask) {
                    // MASK_FIX: Feathering is now done via blurring the mask texture lookup, not a canvas filter.
                    // This provides a proper feather instead of a "glow".
                    float feather_uv = u_feather / u_resolution.x;
                    if (feather_uv > 0.001) {
                        float total = 0.0;
                        for (float x = -2.0; x <= 2.0; x += 1.0) {
                            for (float y = -2.0; y <= 2.0; y += 1.0) {
                                total += texture2D(u_maskTex, uv + vec2(x, y) * feather_uv / 2.0).r;
                            }
                        }
                        mask = total / 25.0;
                    } else {
                        mask = texture2D(u_maskTex, uv).r;
                    }
                }
                
                if (u_invertMask) {
                    mask = 1.0 - mask;
                }
                return clamp(mask, 0.0, 1.0);
            }

            // --- Effect Functions ---
            
            // DISPLACEMENT: Noise Flow
            vec2 applyNoiseFlow(vec2 uv, float mask) {
                if (!u_noiseflow_enabled || mask == 0.0) return uv;
                vec2 p = uv * u_noiseflow_scale + u_time * u_speed * 0.1;
                vec3 n = hash3(p) * 2.0 - 1.0;
                vec2 offset = n.xy * (u_noiseflow_strength / u_resolution) * mask;
                return uv + offset;
            }

            // DISPLACEMENT: Wavy Distort
            vec2 applyDistort(vec2 uv, float mask) {
                if (!u_distort_enabled || mask == 0.0) return uv;
                float angle = u_time * u_speed;
                float sx = sin(uv.y * u_distort_freq + angle);
                float sy = cos(uv.x * u_distort_freq + angle);
                vec2 offset = vec2(sx, sy) * (u_distort_amp / u_resolution) * mask;
                return uv + offset;
            }

            // DISPLACEMENT: Jitter
            vec2 applyJitter(vec2 uv, float mask) {
                if (!u_jitter_enabled || mask == 0.0) return uv;
                float t = floor(u_time * u_jitter_speed);
                vec2 block_uv = floor(uv * 50.0);
                float r = rand(block_uv + t);
                if (r < 0.95) return uv;
                vec2 offset = (hash3(block_uv + t + 10.0).xy - 0.5) * (u_jitter_amount / u_resolution) * mask;
                return uv + offset;
            }

            // COLOR: Smear
            vec4 applySmear(vec4 originalColor, vec2 uv, float mask) {
                if (!u_smear_enabled || mask == 0.0) return originalColor;
                
                // ADVANCED_EFFECTS: Smear animates back and forth (ping-pong)
                float angle = radians(u_smear_ang + sin(u_time * u_speed * 2.0) * u_smear_pingpong);
                vec2 dir = vec2(cos(angle), sin(angle));
                vec2 stepUV = dir * (u_smear_len / u_resolution) / float(u_smear_samples);
                
                vec4 acc = vec4(0.0);
                float totalWeight = 0.0;
                
                for(int i = 0; i < 32; i++) {
                    if (i >= u_smear_samples) break;
                    float t = float(i);
                    // MASK_FIX: The effect "seeps" because it samples outside pixels.
                    // The strength of the effect (smear length) is modulated by the mask.
                    vec2 sampleUV = uv - stepUV * t * mask;
                    float weight = 1.0 - (t / float(u_smear_samples));
                    acc += texture2D(u_tex, sampleUV) * weight;
                    totalWeight += weight;
                }
                
                return acc / max(totalWeight, 1.0);
            }

            // COLOR: Pixelate
            vec4 applyPixelate(vec4 originalColor, vec2 uv, float mask) {
                if (!u_pixelate_enabled || mask == 0.0) return originalColor;
                
                // ADVANCED_EFFECTS: Pixelation strength is modulated by a noise pattern.
                float noise_mask = rand(uv * u_pixelate_pattern_scale + floor(u_time * u_speed * 5.0));
                float currentPixelSize = u_pixelate_size * noise_mask * mask;
                
                if (currentPixelSize < 1.5) return originalColor;
                
                vec2 pixelatedUV = (floor(uv * u_resolution / currentPixelSize) + 0.5) * currentPixelSize / u_resolution;
                return texture2D(u_tex, pixelatedUV);
            }

            // COLOR: Chromatic Aberration
            vec4 applyChroma(vec4 originalColor, vec2 uv, float mask) {
                if (!u_chroma_enabled || mask == 0.0) return originalColor;
                float offset = u_chroma_amount / u_resolution.x * mask;
                float r = texture2D(u_tex, uv + vec2(offset, 0.0)).r;
                float b = texture2D(u_tex, uv - vec2(offset, 0.0)).b;
                return vec4(r, originalColor.g, b, originalColor.a);
            }


            void main() {
                // Base UV coordinate, handling mirroring
                vec2 uv = v_uv;
                if (u_mirror) {
                    uv.x = 1.0 - uv.x;
                }

                // Get the mask value at the current pixel
                float mask = getMaskValue(uv);
                
                // --- EFFECT STACKING: UV / Displacement Effects ---
                // Effects that change *where* we look up the texture
                vec2 effectedUV = uv;
                effectedUV = applyNoiseFlow(effectedUV, mask);
                effectedUV = applyDistort(effectedUV, mask);
                effectedUV = applyJitter(effectedUV, mask);
                
                // Sample the texture using the final distorted UV
                vec4 effectedColor = texture2D(u_tex, effectedUV);

                // --- EFFECT STACKING: Color / Post-Processing Effects ---
                // Effects that change the color of the sampled pixel
                effectedColor = applySmear(effectedColor, effectedUV, mask);
                effectedColor = applyPixelate(effectedColor, effectedUV, mask);
                effectedColor = applyChroma(effectedColor, effectedUV, mask);
                
                // Get the original, unaffected color
                vec4 baseColor = texture2D(u_tex, uv);

                // Final mix between base color and effected color, controlled by master mix
                gl_FragColor = mix(baseColor, effectedColor, u_masterMix);
            }
        `;
        
        // --- Effect Definitions ---
        const effects = {
            smear: {
                name: 'Directional Smear',
                enabled: true,
                controls: [
                    { id: 'smear_len', label: 'Length', min: 0, max: 200, step: 1, value: 40 },
                    { id: 'smear_ang', label: 'Angle', min: 0, max: 360, step: 1, value: 0 },
                    { id: 'smear_samples', label: 'Samples', min: 1, max: 32, step: 1, value: 12 },
                    { id: 'smear_pingpong', label: 'Ping-Pong', min: 0, max: 90, step: 1, value: 20 },
                ]
            },
            pixelate: {
                name: 'Patterned Pixelate',
                enabled: false,
                controls: [
                    { id: 'pixelate_size', label: 'Max Size', min: 1, max: 80, step: 1, value: 16 },
                    { id: 'pixelate_pattern_scale', label: 'Pattern Scale', min: 1, max: 200, step: 1, value: 50 },
                ]
            },
            noiseflow: {
                name: 'Noise Flow',
                enabled: true,
                controls: [
                    { id: 'noiseflow_scale', label: 'Scale', min: 0.5, max: 20, step: 0.1, value: 4 },
                    { id: 'noiseflow_strength', label: 'Strength', min: 0, max: 100, step: 1, value: 20 },
                ]
            },
            jitter: {
                name: 'Block Jitter',
                enabled: false,
                controls: [
                    { id: 'jitter_amount', label: 'Amount', min: 0, max: 200, step: 1, value: 50 },
                    { id: 'jitter_speed', label: 'Speed', min: 1, max: 30, step: 1, value: 10 },
                ]
            },
            chroma: {
                name: 'Chroma Shift',
                enabled: true,
                controls: [
                    { id: 'chroma_amount', label: 'Amount', min: 0, max: 50, step: 1, value: 8 },
                ]
            },
            distort: {
                name: 'Wavy Distort',
                enabled: false,
                controls: [
                    { id: 'distort_freq', label: 'Frequency', min: 0, max: 100, step: 0.5, value: 15 },
                    { id: 'distort_amp', label: 'Amplitude', min: 0, max: 100, step: 1, value: 10 },
                ]
            }
        };

        // UI hooks
        const ui = {};

        function hookSlider(id, valueId, config) {
            const el = document.getElementById(id);
            const out = document.getElementById(valueId);
            if (!el || !out) return null;
            
            const set = () => {
                const val = parseFloat(el.value);
                out.textContent = val.toFixed(config.step < 1 ? 2 : 0);
            };
            el.addEventListener('input', set);
            set();
            return el;
        }

        function createEffectUI() {
            const stackContainer = document.getElementById('effectStack');
            const controlsContainer = document.getElementById('effectControlsContainer');
            stackContainer.innerHTML = '';
            controlsContainer.innerHTML = '';

            for (const key in effects) {
                const config = effects[key];
                
                // Create Toggles
                const toggle = document.createElement('div');
                toggle.className = 'effect-toggle';
                toggle.id = `toggle_${key}`;
                toggle.innerHTML = `
                    <span>${config.name}</span>
                    <label class="switch">
                        <input type="checkbox" id="chk_${key}" ${config.enabled ? 'checked' : ''}>
                        <span class="switch-slider"></span>
                    </label>
                `;
                stackContainer.appendChild(toggle);

                // Create Control Panels
                const panel = document.createElement('div');
                panel.className = `control-group ${config.enabled ? 'active' : ''}`;
                panel.id = `controls_${key}`;
                panel.innerHTML = `
                    <div class="control-group-header">${config.name} Controls</div>
                    <div class="control-group-content">
                        <div class="control-grid">
                            ${config.controls.map(c => `
                                <div class="control-item">
                                    <label class="slider-label">${c.label}<span id="val_${c.id}">${c.value}</span></label>
                                    <input type="range" id="${c.id}" min="${c.min}" max="${c.max}" step="${c.step}" value="${c.value}" class="slider-input">
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                controlsContainer.appendChild(panel);
                
                // Hook up controls
                ui[`chk_${key}`] = document.getElementById(`chk_${key}`);
                ui[`chk_${key}`].addEventListener('change', (e) => {
                    document.getElementById(`controls_${key}`).classList.toggle('active', e.target.checked);
                    document.getElementById(`toggle_${key}`).classList.toggle('active', e.target.checked);
                });
                 document.getElementById(`toggle_${key}`).classList.toggle('active', config.enabled);


                config.controls.forEach(c => {
                    ui[c.id] = hookSlider(c.id, `val_${c.id}`, c);
                });
            }
             // Hook global controls
            ui.mix = hookSlider('mix', 'mixVal', { step: 0.01 });
            ui.speed = hookSlider('speed', 'speedVal', { step: 0.01 });
            ui.feather = hookSlider('feather', 'featherVal', { step: 1 });
            ui.pad = hookSlider('pad', 'padVal', { step: 1 });
            ui.mirrorChk = document.getElementById('mirrorChk');
            ui.animateChk = document.getElementById('animateChk');
            ui.trackCenterChk = document.getElementById('trackCenterChk');
            ui.preciseMaskChk = document.getElementById('preciseMaskChk');
            ui.invertMaskChk = document.getElementById('invertMaskChk');
        }

        function setStatus(text) { status2El.textContent = text; }
        function setMsg(text, isError = false) { msgEl.textContent = text || ''; msgEl.classList.toggle('status-error', !!isError); }

        async function initFaceMesh() {
            if (faceMeshReady) return;
            if (typeof window.FaceMesh === 'undefined') {
                setMsg('Loading FaceMesh model...');
                await new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
                    s.crossOrigin = 'anonymous';
                    s.onload = resolve;
                    s.onerror = () => reject(new Error('Failed to load MediaPipe FaceMesh'));
                    document.head.appendChild(s);
                });
            }
            faceMesh = new window.FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });
            faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            faceMesh.onResults((results) => {
                fmBusy = false;
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const landmarks = results.multiFaceLandmarks[0];
                    lastFacesMesh = landmarks.map(p => ({ x: p.x, y: p.y }));
                    
                    if (ui.trackCenterChk.checked) {
                        const noseTip = landmarks[1]; // Use a stable central point like the nose tip
                        if (noseTip) {
                           // TRACKING_FIX: Y-axis is inverted because WebGL's V coordinate (0=bottom) is opposite to image/DOM Y (0=top).
                           // We use 1.0 - y to correct this. X-axis is handled by the `u_mirror` uniform in the shader.
                           effectCenter = { x: noseTip.x, y: 1.0 - noseTip.y };
                        }
                    }
                } else {
                    lastFacesMesh = [];
                }
            });
            await faceMesh.initialize();
            faceMeshReady = true;
            setMsg('');
        }
        
        function fit() {
            if (!video.videoWidth) return;
            const videoRatio = video.videoWidth / video.videoHeight;
            const container = canvas.parentElement;
            const containerRatio = container.clientWidth / container.clientHeight;
            
            let w, h;
            if (containerRatio > videoRatio) {
                h = container.clientHeight;
                w = h * videoRatio;
            } else {
                w = container.clientWidth;
                h = w / videoRatio;
            }

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h}px`;

            maskCanvas.width = video.videoWidth;
            maskCanvas.height = video.videoHeight;
            if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function createGL() {
            gl = canvas.getContext('webgl');
            if (!gl) throw new Error('WebGL not available');

            const compile = (type, src) => {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
                return s;
            };
            program = gl.createProgram();
            gl.attachShader(program, compile(gl.VERTEX_SHADER, vertSrc));
            gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fragSrc));
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(program));

            const a_pos = gl.getAttribLocation(program, 'a_pos');
            buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // This is important for coordinate systems

            maskTex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, maskTex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        
        const U_CACHE = {};
        function getU(name) { return U_CACHE[name] || (U_CACHE[name] = gl.getUniformLocation(program, name)); }

        function uploadVideoTexture() {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video); } catch (e) { /* stale video frame */ }
            gl.uniform1i(getU('u_tex'), 0);
        }

        function uploadMaskTexture() {
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, maskTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);
            gl.uniform1i(getU('u_maskTex'), 1);
        }
        
        function drawMaskFromMesh() {
            const W = maskCanvas.width, H = maskCanvas.height;
            maskCtx.clearRect(0, 0, W, H);
            
            if (lastFacesMesh.length > 0) {
                maskCtx.fillStyle = '#fff';
                maskCtx.beginPath();
                
                const padding = parseFloat(ui.pad.value || 0);
                const landmarks = lastFacesMesh;
                
                // Find bounding box to calculate center for padding
                let minX = W, minY = H, maxX = 0, maxY = 0;
                for (const p of landmarks) {
                    minX = Math.min(minX, p.x * W);
                    minY = Math.min(minY, p.y * H);
                    maxX = Math.max(maxX, p.x * W);
                    maxY = Math.max(maxY, p.y * H);
                }
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                const p0 = landmarks[FACE_OVAL_INDICES[0]];
                let startX = p0.x * W;
                let startY = p0.y * H;
                if (padding !== 0) {
                    let dx = startX - centerX;
                    let dy = startY - centerY;
                    let len = Math.sqrt(dx*dx + dy*dy);
                    startX += (dx/len) * padding;
                    startY += (dy/len) * padding;
                }
                maskCtx.moveTo(startX, startY);

                for (let i = 1; i < FACE_OVAL_INDICES.length; i++) {
                    const p = landmarks[FACE_OVAL_INDICES[i]];
                    let px = p.x * W;
                    let py = p.y * H;

                    if (padding !== 0) {
                       let dx = px - centerX;
                       let dy = py - centerY;
                       let len = Math.sqrt(dx*dx + dy*dy);
                       px += (dx/len) * padding;
                       py += (dy/len) * padding;
                    }
                    maskCtx.lineTo(px, py);
                }
                maskCtx.closePath();
                maskCtx.fill();
            }
        }

        function setUniforms(timeSec) {
            gl.useProgram(program);
            
            // Globals
            gl.uniform2f(getU('u_resolution'), canvas.width, canvas.height);
            gl.uniform1f(getU('u_time'), timeSec);
            gl.uniform1f(getU('u_speed'), parseFloat(ui.speed.value));
            gl.uniform1f(getU('u_masterMix'), parseFloat(ui.mix.value));
            gl.uniform1i(getU('u_mirror'), ui.mirrorChk.checked);

            // Mask
            gl.uniform2f(getU('u_center'), effectCenter.x, effectCenter.y);
            gl.uniform1i(getU('u_usePreciseMask'), ui.preciseMaskChk.checked);
            gl.uniform1i(getU('u_invertMask'), ui.invertMaskChk.checked);
            gl.uniform1f(getU('u_feather'), parseFloat(ui.feather.value));
            
            // Per-effect uniforms
            for (const key in effects) {
                const enabled = ui[`chk_${key}`] && ui[`chk_${key}`].checked;
                gl.uniform1i(getU(`u_${key}_enabled`), enabled);
                if (enabled) {
                    effects[key].controls.forEach(c => {
                        const uniformType = (c.step === 1 && c.max > 1) ? '1i' : '1f';
                        gl[`uniform${uniformType}`](getU(`u_${c.id}`), parseFloat(ui[c.id].value));
                    });
                }
            }
        }
        
        async function start() {
            if (!navigator.mediaDevices?.getUserMedia) { setMsg('Camera access (getUserMedia) not supported.', true); return; }
            if (!window.isSecureContext) { setMsg('Page not secure (HTTPS). Camera access will be blocked.', true); return; }
            
            try {
                setStatus('Requesting camera…');
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                video.srcObject = stream;
                await video.play();
                fit();
                window.addEventListener('resize', fit, false);

                await initFaceMesh();
                createGL();
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                setMsg('');
                loop();
            } catch (err) {
                let hint = '';
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    hint = ' • Permission blocked. Check browser settings.';
                } else if (err.name === 'NotFoundError') {
                    hint = ' • No camera found.';
                }
                setMsg(`Could not start camera: ${err.message}${hint}`, true);
                setStatus('Error');
            }
        }

        function stop() {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = null;
            if (stream) stream.getTracks().forEach(t => t.stop());
            stream = null;
            video.srcObject = null;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            setStatus('Stopped');
        }

        function loop() {
            rafId = requestAnimationFrame(loop);
            
            if (!video.videoWidth || video.paused || video.ended) return;

            const now = performance.now();
            if (ui.preciseMaskChk.checked && faceMeshReady && !fmBusy && (now - lastFmTime > FM_MIN_INTERVAL)) {
                fmBusy = true;
                lastFmTime = now;
                faceMesh.send({ image: video });
            }
            
            if (canvas.width === 0) fit();

            if (ui.preciseMaskChk.checked && lastFacesMesh.length) {
                drawMaskFromMesh();
                uploadMaskTexture();
            }
            
            uploadVideoTexture();
            
            const timeSec = ui.animateChk.checked ? now / 1000 : 0;
            setUniforms(timeSec);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            const activeEffects = Object.keys(effects).filter(k => ui[`chk_${k}`].checked).length;
            setStatus(`${canvas.width}×${canvas.height} | ${activeEffects} effects active`);
        }

        // --- Preset Management ---
        function collectSettings() {
            const settings = {};
            // Collect global settings
            document.querySelectorAll('#globalControls input').forEach(input => {
                settings[input.id] = input.type === 'checkbox' ? input.checked : input.value;
            });
            // Collect effect settings
            for (const key in effects) {
                settings[`chk_${key}`] = ui[`chk_${key}`].checked;
                effects[key].controls.forEach(c => {
                    settings[c.id] = ui[c.id].value;
                });
            }
            return settings;
        }

        function applySettings(settings) {
            // Apply global settings
            document.querySelectorAll('#globalControls input').forEach(input => {
                if (settings[input.id] !== undefined) {
                    if (input.type === 'checkbox') {
                        input.checked = settings[input.id];
                    } else {
                        input.value = settings[input.id];
                    }
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
             // Apply effect settings
            for (const key in effects) {
                if (settings[`chk_${key}`] !== undefined) {
                     ui[`chk_${key}`].checked = settings[`chk_${key}`];
                     ui[`chk_${key}`].dispatchEvent(new Event('change'));
                }
                effects[key].controls.forEach(c => {
                    if (settings[c.id] !== undefined) {
                        ui[c.id].value = settings[c.id];
                        ui[c.id].dispatchEvent(new Event('input'));
                    }
                });
            }
        }
        
        function renderPresetList() {
            const listEl = document.getElementById('presetList');
            listEl.innerHTML = '';
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('faceglitch_preset_')) {
                    const name = key.replace('faceglitch_preset_', '');
                    const item = document.createElement('div');
                    item.className = 'preset-item';
                    item.textContent = name;
                    item.onclick = () => {
                        const settings = JSON.parse(localStorage.getItem(key));
                        applySettings(settings);
                        setMsg(`Loaded preset: ${name}`);
                    };
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'preset-delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Delete preset "${name}"?`)) {
                            localStorage.removeItem(key);
                            renderPresetList();
                        }
                    };
                    item.appendChild(deleteBtn);
                    listEl.appendChild(item);
                }
            }
        }

        function savePreset() {
            const nameEl = document.getElementById('presetName');
            const name = nameEl.value.trim();
            if (!name) {
                setMsg('Please enter a name for the preset.', true);
                return;
            }
            const settings = collectSettings();
            localStorage.setItem(`faceglitch_preset_${name}`, JSON.stringify(settings));
            nameEl.value = '';
            renderPresetList();
            setMsg(`Preset "${name}" saved.`);
        }

        // --- Event Listeners ---
        startBtn.addEventListener('click', start);
        stopBtn.addEventListener('click', stop);
        document.getElementById('savePresetBtn').addEventListener('click', savePreset);
        document.getElementById('randomBtn').addEventListener('click', () => {
             const randomSettings = {};
             // Randomize globals
             randomSettings.mix = (0.5 + Math.random() * 0.5).toFixed(2);
             randomSettings.speed = (Math.random() * 4).toFixed(2);
             randomSettings.feather = Math.floor(Math.random() * 100);
             randomSettings.pad = Math.floor(Math.random() * 100 - 20);
             randomSettings.invertMaskChk = Math.random() > 0.8;
             
             // Randomize effects
             for(const key in effects) {
                 randomSettings[`chk_${key}`] = Math.random() > 0.4;
                 effects[key].controls.forEach(c => {
                    const min = parseFloat(c.min);
                    const max = parseFloat(c.max);
                    const val = min + Math.random() * (max - min);
                    randomSettings[c.id] = val;
                 });
             }
             applySettings(randomSettings);
             setMsg('Settings randomized!');
        });

        // --- Initialization ---
        createEffectUI();
        renderPresetList();
        
        // Auto-start if camera permission was already granted
        (async () => {
            if (navigator.permissions) {
                try {
                    const permission = await navigator.permissions.query({ name: 'camera' });
                    if (permission.state === 'granted') {
                        start();
                    }
                } catch(e) { /* ignore */ }
            }
        })();

    })();
    </script>
</body>
</html>
