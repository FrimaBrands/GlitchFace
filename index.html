<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Face Glitch V3 (Corrected)</title>
    <style>
        :root {
            --bg: #0b0d11;
            --panel: #11141a;
            --stroke: #1f2430;
            --fg: #e5e7eb;
            --muted: #9aa0aa;
            --accent: #6ee7b7;
            --danger: #f87171;
            --primary-bg: #1a202c;
            --secondary-bg: #2d3748;
            --text-color: #f7fafc;
            --primary-color: #6ee7b7;
            --border-color: #4a5568;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            --radius-sm: 8px;
            --radius-md: 12px;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: var(--bg); color: var(--text-color); }
        body { display: flex; justify-content: center; align-items: center; padding: 20px; background: radial-gradient(circle at center, #1a1f26 0%, #0d0f13 100%); }
        .container { display: flex; width: 100%; max-width: 1600px; height: 90vh; border-radius: var(--radius-md); overflow: hidden; box-shadow: var(--shadow); background: var(--primary-bg); border: 1px solid var(--border-color); }
        .main-stage { flex: 3; position: relative; background: #0d0f13; display: flex; align-items: center; justify-content: center; }
        #glcanvas, #video { width: 100%; height: 100%; display: block; }
        #video { display: none; }
        .controls-panel { flex: 1; min-width: 420px; padding: 24px; display: flex; flex-direction: column; overflow-y: auto; background: var(--secondary-bg); }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; border-bottom: 1px solid var(--border-color); padding-bottom: 16px; }
        h1 { font-size: 24px; font-weight: 600; margin: 0; letter-spacing: -0.5px; }
        .btn { padding: 10px 20px; border: 1px solid var(--border-color); border-radius: var(--radius-sm); background-color: transparent; color: var(--text-color); font-size: 14px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; font-family: 'Poppins', sans-serif; }
        .btn:hover:not(:disabled) { background-color: rgba(255, 255, 255, 0.1); border-color: var(--primary-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-small { padding: 4px 8px; font-size: 12px; }
        .btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #1a1f26; font-weight: 600; }
        .btn-primary:hover:not(:disabled) { background-color: #55d4a6; border-color: #55d4a6; }
        .section-heading { font-size: 16px; font-weight: 600; margin: 16px 0 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); }
        .effect-selector { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
        .effect-btn { background: var(--primary-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 8px 12px; border-radius: var(--radius-sm); cursor: pointer; transition: all 0.2s; }
        .effect-btn:hover { border-color: var(--primary-color); background: rgba(110, 231, 183, 0.1); }
        .effect-btn.active { border-color: var(--primary-color); background: var(--primary-color); color: #1a1f26; font-weight: 600; }
        .dynamic-controls { display: flex; flex-direction: column; gap: 16px; }
        .control-group { border: 1px solid var(--border-color); border-radius: var(--radius-md); margin-bottom: 16px; background: var(--primary-bg); display: none; }
        .control-group.global, .control-group.active { display: block; }
        .control-group-header { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; font-weight: 600; transition: background-color 0.2s; }
        .control-group-header:hover { background-color: rgba(255, 255, 255, 0.05); }
        .control-group-header::after { content: '▼'; font-size: 0.8rem; transition: transform 0.2s; }
        .control-group.collapsed .control-group-header::after { transform: rotate(-90deg); }
        .control-group-content { padding: 12px 16px; border-top: 1px solid var(--border-color); transition: all 0.3s ease-in-out; }
        .control-group.collapsed .control-group-content { display: none; }
        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .preset-grid { display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; margin-bottom: 12px; }
        #presetName, #presetList { width: 100%; background: var(--primary-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 8px 12px; border-radius: var(--radius-sm); }
        #presetList { margin-bottom: 12px; }
        .control-item { display: flex; flex-direction: column; gap: 6px; }
        .control-item.full-width { grid-column: 1 / -1; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
        .slider-input { width: 100%; height: 4px; border-radius: 2px; background: var(--border-color); -webkit-appearance: none; appearance: none; outline: none; }
        .slider-input::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #0d0f13; }
        .slider-input::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--primary-color); cursor: pointer; border: 2px solid #0d0f13; }
        .options-list { display: flex; flex-direction: column; gap: 10px; margin-top: 16px; }
        .options-list label { display: flex; align-items: center; gap: 10px; font-size: 14px; cursor: pointer; }
        .options-list input[type="checkbox"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 18px; height: 18px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--primary-bg); cursor: pointer; position: relative; }
        .options-list input[type="checkbox"]:checked { background-color: var(--primary-color); border-color: var(--primary-color); }
        .options-list input[type="checkbox"]:checked:after { content: '✓'; color: #1a1f26; font-size: 14px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .status-bar { margin-top: auto; padding-top: 16px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--muted); }
        .status-badge { background: var(--primary-bg); padding: 4px 8px; border-radius: var(--radius-sm); border: 1px solid var(--border-color); font-size: 10px; }
        .status-error { color: var(--danger); }
        .slider-container { display: flex; flex-direction: column; gap: 4px; }
        .slider-main-line { display: grid; gap: 8px; align-items: center; }
        .wiggle-btn { background: none; border: 1px solid var(--border-color); color: var(--muted); cursor: pointer; border-radius: 4px; width: 24px; height: 24px; font-weight: bold; font-family: 'JetBrains Mono', monospace; transition: all 0.2s; }
        .wiggle-btn.active { color: var(--primary-color); border-color: var(--primary-color); background-color: rgba(110, 231, 183, 0.1); }
        .wiggle-controls { display: none; flex-direction: column; gap: 8px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: var(--radius-sm); margin-top: 4px; }
        .wiggle-controls.active { display: flex; }
        .wiggle-controls .slider-label { font-size: 10px; }
        .wiggle-controls .slider-input::-webkit-slider-thumb { width: 12px; height: 12px; }
        .wiggle-controls .slider-input::-moz-range-thumb { width: 12px; height: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-stage">
            <video id="video" playsinline muted></video>
            <canvas id="glcanvas" aria-label="camera with face effects"></canvas>
        </div>
        <div class="controls-panel">
            <div class="header"><h1>Face Glitch V3</h1><div class="header-actions"><button id="startBtn" class="btn btn-primary">Start</button><button id="stopBtn" class="btn" disabled>Stop</button></div></div>
            <div class="section-heading">Effect Layers</div>
            <div class="effect-selector"><button class="effect-btn" data-effect="Smear">Smear</button><button class="effect-btn" data-effect="Turbulence">Turbulence</button><button class="effect-btn" data-effect="DataMosh">DataMosh</button><button class="effect-btn" data-effect="Pixelate">Pixelate</button><button class="effect-btn" data-effect="Glitch">Glitch</button><button class="effect-btn" data-effect="ChromaJitter">Chroma Jitter</button></div>
            <div class="dynamic-controls">
                <div id="smearControls" class="control-group" data-effect="Smear"><div class="control-group-header">Smear Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item" data-control-id="smLen"></div><div class="control-item" data-control-id="smAng"></div><div class="control-item" data-control-id="samples"></div></div></div></div>
                <div id="turbulenceControls" class="control-group" data-effect="Turbulence"><div class="control-group-header">Turbulence Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item" data-control-id="turbScale"></div><div class="control-item" data-control-id="turbStrength"></div></div></div></div>
                <div id="dataMoshControls" class="control-group" data-effect="DataMosh"><div class="control-group-header">Data Mosh Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item" data-control-id="moshBlock"></div><div class="control-item" data-control-id="moshProb"></div></div></div></div>
                <div id="pixelateControls" class="control-group" data-effect="Pixelate"><div class="control-group-header">Pixelate Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item full-width" data-control-id="pixelSize"></div></div></div></div>
                <div id="glitchControls" class="control-group" data-effect="Glitch"><div class="control-group-header">Glitch Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item" data-control-id="glitchBlock"></div><div class="control-item" data-control-id="glitchProb"></div></div></div></div>
                <div id="chromaJitterControls" class="control-group" data-effect="ChromaJitter"><div class="control-group-header">Chroma Jitter Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item full-width" data-control-id="chromaShift"></div></div></div></div>
            </div>
            <div id="globalControls" class="control-group global"><div class="control-group-header">Global & Mask Controls</div><div class="control-group-content"><div class="control-grid"><div class="control-item" data-control-id="speed"></div><div class="control-item" data-control-id="mix"></div><div class="control-item" data-control-id="feather"></div><div class="control-item" data-control-id="pad"></div><div class="control-item full-width" data-control-id="feedback"></div></div><div class="options-list"><label><input type="checkbox" id="mirrorChk" checked> Mirror Camera</label><label><input type="checkbox" id="animateChk" checked> Animate Effects</label><label><input type="checkbox" id="trackCenterChk" checked> Track Center of Face</label><label><input type="checkbox" id="preciseMaskChk" checked> Precise Face Mesh Mask</label></div></div></div>
            <div id="presetsTools" class="control-group global"><div class="control-group-header">Presets</div><div class="control-group-content"><div class="preset-grid"><input type="text" id="presetName" placeholder="Preset Name..."><button id="savePresetBtn" class="btn btn-small">Save</button><button id="deletePresetBtn" class="btn btn-small" style="color: var(--danger);">Delete</button></div><select id="presetList" class="btn"></select><button id="randomBtn" class="btn" style="width: 100%; margin-top: 8px;">Randomize All</button></div></div>
            <div class="status-bar"><span id="msg" class="status-error"></span><span id="status2" class="status-badge">Idle</span></div>
        </div>
    </div>
    <script>
    (() => {
        const video = document.getElementById('video');
        const canvas = document.getElementById('glcanvas');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const mirrorChk = document.getElementById('mirrorChk');
        const animateChk = document.getElementById('animateChk');
        const trackCenterChk = document.getElementById('trackCenterChk');
        const preciseMaskChk = document.getElementById('preciseMaskChk');
        const status2El = document.getElementById('status2');
        const msgEl = document.getElementById('msg');
        const effectBtns = document.querySelectorAll('.effect-btn');
        const savePresetBtn = document.getElementById('savePresetBtn');
        const deletePresetBtn = document.getElementById('deletePresetBtn');
        const presetNameInput = document.getElementById('presetName');
        const presetList = document.getElementById('presetList');
        const randomBtn = document.getElementById('randomBtn');

        function setStatus(text) { status2El.textContent = text; }
        function setMsg(text, isError = false) { msgEl.textContent = text || ''; msgEl.classList.toggle('status-error', !!isError); }

        const ALL_EFFECTS = Array.from(effectBtns).map(btn => btn.dataset.effect);
        let activeEffects = new Set();
        const controlsState = {};

        function createSliderControl(id, def) {
            controlsState[id] = { base: def.value, wiggleAmt: 0, wiggleSpd: 1, isWiggling: false };
            const container = document.querySelector(`[data-control-id="${id}"]`);
            if (!container) return;
            container.innerHTML = `<div class="slider-container"><div class="slider-main-line" style="grid-template-columns: auto 1fr;"><button class="wiggle-btn" data-id="${id}">~</button><div style="flex-grow: 1;"><label class="slider-label">${def.label}<span id="${id}-val">${def.value}</span></label><input type="range" id="${id}-base" min="${def.min}" max="${def.max}" step="${def.step}" value="${def.value}" class="slider-input"></div></div><div class="wiggle-controls" id="${id}-wiggle-panel"><label class="slider-label">Wiggle Amount<span id="${id}-amt-val">0</span></label><input type="range" id="${id}-amt" min="0" max="${(def.max - def.min) / 2}" step="${def.step}" value="0" class="slider-input"><label class="slider-label">Wiggle Speed<span id="${id}-spd-val">1</span></label><input type="range" id="${id}-spd" min="0" max="10" step="0.1" value="1" class="slider-input"></div></div>`;
            
            const baseSlider = document.getElementById(`${id}-base`), amtSlider = document.getElementById(`${id}-amt`), spdSlider = document.getElementById(`${id}-spd`);
            const baseVal = document.getElementById(`${id}-val`), amtVal = document.getElementById(`${id}-amt-val`), spdVal = document.getElementById(`${id}-spd-val`);
            const wiggleBtn = container.querySelector('.wiggle-btn'), wigglePanel = document.getElementById(`${id}-wiggle-panel`);
            const update = () => {
                baseVal.textContent = parseFloat(baseSlider.value).toFixed(def.step < 1 ? 2 : 0);
                amtVal.textContent = parseFloat(amtSlider.value).toFixed(def.step < 1 ? 2 : 0);
                spdVal.textContent = parseFloat(spdSlider.value).toFixed(1);
                controlsState[id].base = parseFloat(baseSlider.value);
                controlsState[id].wiggleAmt = parseFloat(amtSlider.value);
                controlsState[id].wiggleSpd = parseFloat(spdSlider.value);
            };
            [baseSlider, amtSlider, spdSlider].forEach(el => el.addEventListener('input', update));
            wiggleBtn.addEventListener('click', () => {
                const isActive = wigglePanel.classList.toggle('active');
                wiggleBtn.classList.toggle('active', isActive);
                controlsState[id].isWiggling = isActive;
            });
            update();
        }

        const controlDefinitions = {
            smLen: { label: "Length", min: 0, max: 200, step: 1, value: 40 }, smAng: { label: "Angle", min: 0, max: 360, step: 1, value: 0 }, samples: { label: "Samples", min: 1, max: 32, step: 1, value: 12 },
            turbScale: { label: "Scale", min: 0.5, max: 50, step: 0.1, value: 8 }, turbStrength: { label: "Strength (px)", min: 0, max: 100, step: 1, value: 10 },
            moshBlock: { label: "Block Size", min: 4, max: 64, step: 1, value: 16 }, moshProb: { label: "I-Frame Prob.", min: 0, max: 0.1, step: 0.001, value: 0.01 },
            pixelSize: { label: "Pixel Size", min: 1, max: 64, step: 1, value: 12 },
            glitchBlock: { label: "Block Size", min: 2, max: 160, step: 2, value: 22 }, glitchProb: { label: "Probability", min: 0, max: 1, step: 0.01, value: 0.45 },
            chromaShift: { label: "Shift (px)", min: 0, max: 50, step: 1, value: 8 },
            speed: { label: "Global Speed", min: 0, max: 5, step: 0.01, value: 1.2 }, mix: { label: "Effect Mix", min: 0, max: 1, step: 0.01, value: 1.0 },
            feather: { label: "Feather", min: 0, max: 64, step: 1, value: 18 }, pad: { label: "Mask Padding", min: -50, max: 120, step: 1, value: 16 },
            feedback: { label: "Feedback Amt", min: 0, max: 0.99, step: 0.01, value: 0 }
        };

        Object.keys(controlDefinitions).forEach(id => createSliderControl(id, controlDefinitions[id]));
        
        let stream = null, rafId = null, gl = null;
        let effectProgram = null, displayProgram = null;
        let videoTex = null, maskTex = null;
        let fbos = [], currentFBO = 0;
        let lastFacesMesh = [];
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        let faceMesh = null, faceMeshReady = false, fmBusy = false, lastFmTime = 0;
        const FM_MIN_INTERVAL = 60;
        const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
        
        const vertSrc = `attribute vec2 a_pos; varying vec2 v_uv; void main(){ v_uv = a_pos; gl_Position = vec4(a_pos*2.0-1.0, 0.0, 1.0);}`;
        const effectFragSrc = `
            precision highp float; varying vec2 v_uv; 
            uniform sampler2D u_videoTex, u_maskTex, u_feedbackTex;
            uniform vec2 u_resolution; uniform float u_time; 
            uniform bool u_Smear_active, u_Turbulence_active, u_DataMosh_active, u_Pixelate_active, u_Glitch_active, u_ChromaJitter_active;
            uniform float u_smLen, u_smAng, u_samples, u_turbScale, u_turbStrength, u_moshBlock, u_moshProb, u_pixelSize, u_glitchBlock, u_glitchProb, u_chromaShift, u_feather, u_mix, u_feedback, u_speed;
            float rand(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
            float noise(vec2 p) { vec2 i = floor(p), f = fract(p), u = f*f*(3.0-2.0*f); return mix(mix(rand(i), rand(i + vec2(1,0)), u.x), mix(rand(i + vec2(0,1)), rand(i + vec2(1,1)), u.x), u.y); }
            float getMaskValue(vec2 uv) { float m = texture2D(u_maskTex, uv).r; float fa = u_feather / u_resolution.y; return smoothstep(0.5 - fa, 0.5 + fa, m); }
            vec4 applySmear(vec2 uv, vec4 base_color) { vec4 a=vec4(0.); float ws=0.; vec2 d=vec2(cos(radians(u_smAng)), sin(radians(u_smAng))); for(int i=0;i<32;i++){if(i>=int(u_samples))break; vec2 s_uv=uv-(d*u_smLen/u_resolution)*(float(i)/u_samples); float sm=getMaskValue(s_uv); vec4 sc=texture2D(u_videoTex,s_uv); a+=sc*sm; ws+=sm;} if(ws>0.0)a/=ws; return a+base_color*(1.-getMaskValue(uv));}
            vec2 applyTurbulence(vec2 uv) { float s=u_turbStrength/u_resolution.x; float t=u_time*u_speed; vec2 p1=uv*u_turbScale+t*.1; vec2 p2=uv*u_turbScale*2.1-t*.15; vec2 o=vec2(noise(p1),noise(p1+5.2))*2.-1.; o+=(vec2(noise(p2),noise(p2+8.3))*2.-1.)*.5; return uv+o*s; }
            vec4 applyDataMosh(vec2 uv, vec4 cc, sampler2D ft) { vec2 buv=floor(uv*u_moshBlock)/u_moshBlock; if(rand(buv+floor(u_time*5.*u_speed))>u_moshProb){ vec2 f=(vec2(rand(buv),rand(buv+9.8))-.5)*.1; return texture2D(ft,uv+f); } return cc; }
            vec2 applyPixelate(vec2 uv) { vec2 rf=u_resolution/u_pixelSize; return (floor(uv*rf)+.5)/rf; }
            vec2 applyGlitch(vec2 uv) { float r=floor(uv.y*u_glitchBlock); if(rand(vec2(r,floor(u_time*10.*u_speed)))>u_glitchProb)return uv; return uv+vec2((rand(vec2(r,floor(u_time*15.))) - 0.5) * 0.3, 0.); }
            vec4 applyChromaJitter(vec4 c, vec2 uv) { float s=u_chromaShift*(1.+(rand(uv+u_time)-.5)*.5)/u_resolution.x; float r=texture2D(u_videoTex,uv+vec2(s,0.)).r; float b=texture2D(u_videoTex,uv-vec2(s,0.)).b; return vec4(r,c.g,b,c.a); }
            void main() {
                vec4 base_color=texture2D(u_videoTex, v_uv); vec4 feedback_color=texture2D(u_feedbackTex, v_uv);
                vec4 current_color=mix(base_color,feedback_color,u_feedback); vec2 effect_uv=v_uv;
                if(u_Turbulence_active) effect_uv=applyTurbulence(effect_uv); if(u_Pixelate_active) effect_uv=applyPixelate(effect_uv); if(u_Glitch_active) effect_uv=applyGlitch(effect_uv);
                vec4 final_color=texture2D(u_videoTex,effect_uv);
                if(u_ChromaJitter_active) final_color=applyChromaJitter(final_color,effect_uv);
                if(u_DataMosh_active) final_color=applyDataMosh(v_uv,current_color,u_feedbackTex);
                float mask=getMaskValue(v_uv); final_color=mix(final_color,current_color,1.-mask);
                if(u_Smear_active) final_color=applySmear(v_uv,final_color);
                gl_FragColor=mix(base_color,final_color,u_mix);
            }`;
            
        const displayFragSrc = `
            precision highp float; varying vec2 v_uv;
            uniform sampler2D u_displayTex;
            void main() { gl_FragColor = texture2D(u_displayTex, v_uv); }`;
        
        const U = {};
        function getU(prog, name) { const key = `${prog.id}_${name}`; return U[key] || (U[key] = gl.getUniformLocation(prog, name)); }
        
        async function start() {
            if (!navigator.mediaDevices?.getUserMedia) { setMsg('getUserMedia not supported.', true); return; }
            if (!isSecureContext) { setMsg('Page is not secure (HTTPS).', true); return; }
            try {
                setStatus('Requesting camera…');
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                video.srcObject = stream; await video.play();
                await new Promise(res => video.addEventListener('loadedmetadata', res, { once: true }));
                fit(); window.addEventListener('resize', fit);
                setStatus('Initializing...');
                await initFaceMesh(); createGL(); initFBOs();
                startBtn.disabled = true; stopBtn.disabled = false;
                setStatus('Running'); setMsg('');
                loop();
            } catch (err) { console.error(err); setMsg('Could not start camera: ' + err.message, true); setStatus('Error'); }
        }

        function stop() {
            if (rafId) cancelAnimationFrame(rafId), rafId = null;
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
            startBtn.disabled = false; stopBtn.disabled = true;
            setStatus('Stopped');
        }

        function loop(time) {
            rafId = requestAnimationFrame(loop);
            if (!video.videoWidth || !gl) return;
            const t = animateChk.checked ? time / 1000 : 0;

            if (faceMeshReady && !fmBusy && (performance.now() - lastFmTime) > FM_MIN_INTERVAL) {
                fmBusy = true; lastFmTime = performance.now();
                faceMesh.send({ image: video }).finally(() => { fmBusy = false; });
            }

            if (preciseMaskChk.checked) {
                drawMaskFromMesh();
                gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, maskTex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);
            }
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, videoTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

            // --- Pass 1: Effect Pass (draw to FBO) ---
            gl.useProgram(effectProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[currentFBO].framebuffer);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.uniform1i(getU(effectProgram, 'u_videoTex'), 0);
            gl.uniform1i(getU(effectProgram, 'u_maskTex'), 1);
            gl.uniform1i(getU(effectProgram, 'u_feedbackTex'), 2);
            gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, fbos[1 - currentFBO].texture);

            gl.uniform2f(getU(effectProgram, 'u_resolution'), canvas.width, canvas.height);
            gl.uniform1f(getU(effectProgram, 'u_time'), t);
            
            for (const id in controlsState) {
                const state = controlsState[id];
                let value = state.base;
                if (state.isWiggling && animateChk.checked) { value += Math.sin(t * state.wiggleSpd) * state.wiggleAmt; }
                gl.uniform1f(getU(effectProgram, `u_${id}`), value);
            }
            for (const effect of ALL_EFFECTS) { gl.uniform1i(getU(effectProgram, `u_${effect}_active`), activeEffects.has(effect)); }
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // --- Pass 2: Display Pass (draw FBO to canvas) ---
            gl.useProgram(displayProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.uniform1i(getU(displayProgram, 'u_displayTex'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbos[currentFBO].texture);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            currentFBO = 1 - currentFBO;
            status2El.textContent = `${lastFacesMesh.length > 0 ? 'Face OK' : 'No Face'} @ ${canvas.width}x${canvas.height}`;
        }
        
        function fit() {
            if (!video.videoWidth) return;
            const w = video.videoWidth, h = video.videoHeight;
            canvas.width = w; canvas.height = h;
            maskCanvas.width = w; maskCanvas.height = h;
            if (gl) {
                gl.viewport(0, 0, w, h);
                if (fbos.length > 0) {
                    fbos.forEach(fbo => {
                        gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    });
                }
            }
        }

        function createGL() {
            gl = canvas.getContext('webgl');
            let programIdCounter = 0;
            const compileProgram = (vsSrc, fsSrc) => {
                const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
                const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsSrc); gl.compileShader(fs);
                if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) { setMsg("Shader Error: " + gl.getShaderInfoLog(fs), true); throw new Error("Shader compile error"); }
                const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs);

                // BUG FIX: Bind attribute location BEFORE linking.
                // This guarantees a_pos is at location 0 for both programs.
                gl.bindAttribLocation(prog, 0, 'a_pos');

                gl.linkProgram(prog);
                prog.id = programIdCounter++;
                return prog;
            };

            effectProgram = compileProgram(vertSrc, effectFragSrc);
            displayProgram = compileProgram(vertSrc, displayFragSrc);
            
            const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
            
            // BUG FIX: Now that a_pos is always at location 0, this single setup works for both programs.
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            videoTex = createTexture(); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            maskTex = createTexture();
        }
        
        function createTexture() {
            const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return tex;
        }

        function initFBOs() {
            for (let i = 0; i < 2; i++) {
                const texture = createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                fbos.push({ framebuffer: fbo, texture: texture });
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        async function initFaceMesh() {
            if (faceMeshReady) return;
            if (typeof window.FaceMesh === 'undefined') {
                await new Promise((resolve, reject) => {
                    const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js'; s.onload = resolve; s.onerror = () => reject(new Error('Failed to load MediaPipe FaceMesh')); document.head.appendChild(s);
                });
            }
            faceMesh = new window.FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
            faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            faceMesh.onResults((res) => { lastFacesMesh = res.multiFaceLandmarks || []; });
            faceMeshReady = true;
        }

        function drawMaskFromMesh() {
            const W = maskCanvas.width, H = maskCanvas.height;
            maskCtx.save();
            maskCtx.clearRect(0, 0, W, H);
            if(mirrorChk.checked){ maskCtx.translate(W, 0); maskCtx.scale(-1, 1); }
            maskCtx.fillStyle = '#fff'; maskCtx.beginPath();
            if(lastFacesMesh.length > 0){
                const lm = lastFacesMesh[0];
                if (!lm || lm.length < 468) { maskCtx.restore(); return; }
                const padding = controlsState.pad ? controlsState.pad.base : 0;
                const padFactor = 1 + padding / 100;
                let minX = W, minY = H, maxX = 0, maxY = 0;
                for(const p of lm) { minX = Math.min(minX, p.x*W); minY = Math.min(minY, p.y*H); maxX = Math.max(maxX, p.x*W); maxY = Math.max(maxY, p.y*H); }
                const cX = (minX+maxX)/2, cY = (minY+maxY)/2;
                const p0 = lm[FACE_OVAL[0]];
                maskCtx.moveTo(cX + (p0.x*W - cX) * padFactor, cY + (p0.y*H - cY) * padFactor);
                for(let i=1; i<FACE_OVAL.length; i++){ const p=lm[FACE_OVAL[i]]; maskCtx.lineTo(cX + (p.x*W-cX)*padFactor, cY + (p.y*H-cY)*padFactor); }
                maskCtx.closePath();
            }
            maskCtx.fill(); maskCtx.restore();
        }
        
        function getAppState() { return { controls: JSON.parse(JSON.stringify(controlsState)), checkboxes: { mirrorChk: mirrorChk.checked, animateChk: animateChk.checked, trackCenterChk: trackCenterChk.checked, preciseMaskChk: preciseMaskChk.checked }, effects: Array.from(activeEffects) }; }
        function setAppState(state) {
            if (!state) return;
            if (state.controls) { Object.keys(state.controls).forEach(id => { if (controlsState[id] && state.controls[id]) { Object.assign(controlsState[id], state.controls[id]); document.getElementById(`${id}-base`).value = state.controls[id].base; document.getElementById(`${id}-amt`).value = state.controls[id].wiggleAmt; document.getElementById(`${id}-spd`).value = state.controls[id].wiggleSpd; const wp = document.getElementById(`${id}-wiggle-panel`), wb = document.querySelector(`[data-id="${id}"]`); wp.classList.toggle('active', state.controls[id].isWiggling); wb.classList.toggle('active', state.controls[id].isWiggling); ['base','amt','spd'].forEach(t => document.getElementById(`${id}-${t}`).dispatchEvent(new Event('input'))); } }); }
            if (state.checkboxes) { mirrorChk.checked = state.checkboxes.mirrorChk ?? true; animateChk.checked = state.checkboxes.animateChk ?? true; trackCenterChk.checked = state.checkboxes.trackCenterChk ?? true; preciseMaskChk.checked = state.checkboxes.preciseMaskChk ?? true; }
            if (state.effects) { activeEffects = new Set(state.effects); updateEffectUI(); }
        }
        function getPresets() { return JSON.parse(localStorage.getItem('faceGlitchV3Presets') || '{}'); }
        function savePresets(presets) { localStorage.setItem('faceGlitchV3Presets', JSON.stringify(presets)); }
        function populatePresetList() { const p = getPresets(); presetList.innerHTML = '<option value="">Load a preset...</option>'; for(const n in p) { const o=document.createElement('option'); o.value=n; o.textContent=n; presetList.appendChild(o); } }
        function updateEffectUI() { document.querySelectorAll('.dynamic-controls .control-group').forEach(p => p.classList.toggle('active', activeEffects.has(p.dataset.effect))); effectBtns.forEach(b => b.classList.toggle('active', activeEffects.has(b.dataset.effect))); }
        effectBtns.forEach(btn => { btn.addEventListener('click', () => { const n=btn.dataset.effect; if(activeEffects.has(n))activeEffects.delete(n); else activeEffects.add(n); updateEffectUI(); }); });
        document.querySelectorAll('.control-group-header').forEach(h => { h.addEventListener('click', () => h.parentElement.classList.toggle('collapsed')); });
        savePresetBtn.addEventListener('click', () => { const n=presetNameInput.value.trim(); if(!n){setMsg('Preset name required.',true);return;} const p=getPresets(); p[n]=getAppState(); savePresets(p); populatePresetList(); presetList.value=n; setMsg(`Preset '${n}' saved.`); });
        deletePresetBtn.addEventListener('click', () => { const n=presetList.value; if(!n){setMsg('Select preset to delete.',true);return;} const p=getPresets(); delete p[n]; savePresets(p); populatePresetList(); setMsg(`Preset '${n}' deleted.`); });
        presetList.addEventListener('change', () => { const n=presetList.value; if(!n)return; const p=getPresets(); if(p[n]){setAppState(p[n]); presetNameInput.value=n; setMsg(`Preset '${n}' loaded.`);} });
        randomBtn.addEventListener('click', () => { const r=(min,max)=>min+Math.random()*(max-min); Object.keys(controlDefinitions).forEach(id => { const d=controlDefinitions[id]; const b=r(d.min,d.max); document.getElementById(`${id}-base`).value=b; const iw=Math.random()>.7, wa=iw?r(0,(d.max-d.min)/4):0, ws=iw?r(.1,5):1; document.getElementById(`${id}-amt`).value=wa; document.getElementById(`${id}-spd`).value=ws; ['base','amt','spd'].forEach(t=>document.getElementById(`${id}-${t}`).dispatchEvent(new Event('input'))); const wp=document.getElementById(`${id}-wiggle-panel`), wb=document.querySelector(`[data-id="${id}"]`); wp.classList.toggle('active',iw); wb.classList.toggle('active',iw); controlsState[id].isWiggling=iw; }); activeEffects.clear(); ALL_EFFECTS.forEach(e=>{if(Math.random()>.5)activeEffects.add(e);}); if(activeEffects.size===0)activeEffects.add(ALL_EFFECTS[Math.floor(r(0,ALL_EFFECTS.length))]); updateEffectUI(); setMsg('Parameters randomized!'); });
        
        populatePresetList();
        activeEffects.add('Turbulence');
        updateEffectUI();
        (async () => { try { const p = await navigator.permissions.query({ name: 'camera' }); if (p.state === 'granted') start(); } catch { } })();
    })();
    </script>
</body>
</html>
