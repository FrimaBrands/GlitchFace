<!doctype html>
<html lang="en" class="bg-gray-900">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unknown Signal // Glitch Art Installation</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Custom scrollbar for a more modern look */
        .controls-panel::-webkit-scrollbar {
            width: 6px;
        }
        .controls-panel::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        .controls-panel::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 3px;
        }
        .controls-panel::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* Custom slider thumb styles */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #34d399; /* emerald-400 */
            border: 2px solid #111827; /* gray-900 */
            border-radius: 9999px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #34d399; /* emerald-400 */
            border: 2px solid #111827; /* gray-900 */
            border-radius: 9999px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb {
            background: #6ee7b7; /* emerald-300 */
        }
        input[type="range"]:hover::-moz-range-thumb {
            background: #6ee7b7; /* emerald-300 */
        }
        /* Hide the video element */
        #video {
            display: none;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen bg-gray-900 text-gray-200 p-4">

    <div class="container w-full max-w-7xl h-[90vh] flex bg-gray-900 border border-gray-700 rounded-xl shadow-2xl shadow-black/50 overflow-hidden">
        
        <!-- Main Stage: Video and Canvas -->
        <div class="main-stage flex-grow bg-black flex items-center justify-center relative">
            <video id="video" playsinline muted></video>
            <canvas id="glcanvas" class="w-full h-full object-cover" aria-label="camera with face effects"></canvas>
            <div id="loadingIndicator" class="absolute inset-0 bg-black/50 flex flex-col items-center justify-center text-white z-10">
                <svg class="animate-spin h-8 w-8 text-emerald-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p id="statusMsg" class="mt-4 font-mono text-sm">Initializing...</p>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel w-full max-w-sm flex-shrink-0 bg-gray-800/50 border-l border-gray-700 flex flex-col overflow-y-auto">
            
            <!-- Header -->
            <div class="p-4 border-b border-gray-700">
                <h1 class="text-xl font-bold text-white">UNKNOWN SIGNAL</h1>
                <p class="text-sm text-gray-400 font-mono">Real-time Glitch Interface</p>
                <div class="flex space-x-2 mt-4">
                    <button id="startBtn" class="w-full bg-emerald-500 hover:bg-emerald-600 text-gray-900 font-bold py-2 px-4 rounded-md transition-colors duration-200">Initialize Camera</button>
                    <button id="stopBtn" class="w-full bg-red-500 hover:bg-red-600 text-gray-900 font-bold py-2 px-4 rounded-md transition-colors duration-200" disabled>Shutdown</button>
                </div>
            </div>

            <div class="flex-grow p-4 space-y-4">
                <!-- Presets Section -->
                <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <h2 class="font-bold text-gray-300 mb-2">Presets</h2>
                    <div class="space-y-2">
                        <select id="presetList" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-sm focus:ring-emerald-500 focus:border-emerald-500"></select>
                        <div class="grid grid-cols-3 gap-2">
                            <input type="text" id="presetName" placeholder="Preset Name..." class="col-span-3 bg-gray-800 border border-gray-600 rounded-md p-2 text-sm focus:ring-emerald-500 focus:border-emerald-500">
                            <button id="savePresetBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-1 px-2 text-xs rounded-md transition">Save</button>
                            <button id="deletePresetBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-1 px-2 text-xs rounded-md transition">Delete</button>
                            <button id="randomBtn" class="bg-emerald-500/80 hover:bg-emerald-500 text-white font-semibold py-1 px-2 text-xs rounded-md transition">Randomize</button>
                        </div>
                    </div>
                </div>

                <!-- Active Effects Section -->
                <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <h2 class="font-bold text-gray-300 mb-2">Active Effects</h2>
                    <div id="effect-selector" class="grid grid-cols-3 gap-2">
                        <!-- Effect buttons will be generated by JS -->
                    </div>
                </div>

                <!-- Controls Section -->
                <div id="dynamic-controls" class="space-y-3">
                    <!-- Control groups will be generated by JS -->
                </div>
            </div>

            <!-- Footer Status -->
            <div class="p-3 border-t border-gray-700 text-xs font-mono text-gray-500 flex justify-between items-center">
                <span id="errorMsg" class="text-red-400"></span>
                <span id="footerStatus">Idle</span>
            </div>
        </div>
    </div>

    <script>
    (() => {
        // --- CONFIGURATION ---
        const AppConfig = {
            FACE_MESH_MIN_INTERVAL: 50, // ms between face mesh runs
            EFFECTS: {
                // Name: { controls: { control_id: { label, min, max, step, value } } }
                'Feedback': {
                    controls: {
                        feedbackAmount: { label: 'Amount', min: 0.8, max: 1.0, step: 0.001, value: 0.95 }
                    }
                },
                'DataMosh': {
                    controls: {
                        moshAmount: { label: 'Amount', min: 0, max: 0.2, step: 0.001, value: 0.02 }
                    }
                },
                'Displacement': {
                    controls: {
                        nScale: { label: 'Scale', min: 0.5, max: 20, step: 0.1, value: 3 },
                        nStrength: { label: 'Strength', min: 0, max: 100, step: 1, value: 18 }
                    }
                },
                'Pixelate': {
                    controls: {
                        pixelSize: { label: 'Pixel Size', min: 1, max: 64, step: 1, value: 12 }
                    }
                },
                'Glitch': {
                    controls: {
                        blockSize: { label: 'Block Size', min: 2, max: 160, step: 2, value: 22 },
                        glitchProb: { label: 'Probability', min: 0, max: 1, step: 0.01, value: 0.45 }
                    }
                },
                'SlitScan': {
                    controls: {
                        slitSize: { label: 'Slit Size', min: 1, max: 50, step: 1, value: 10 },
                        slitSpeed: { label: 'Speed', min: 0, max: 20, step: 0.1, value: 5 }
                    }
                },
                'Chroma': {
                    controls: {
                        chromaShift: { label: 'Shift', min: 0, max: 40, step: 1, value: 6 }
                    }
                }
            },
            GLOBAL_CONTROLS: {
                speed: { label: 'Global Speed', min: 0, max: 5, step: 0.01, value: 1.2 },
                effectMix: { label: 'Effect Mix', min: 0, max: 1, step: 0.01, value: 1.0 },
                feather: { label: 'Mask Feather', min: 0, max: 64, step: 1, value: 18 },
                pad: { label: 'Mask Padding', min: -50, max: 120, step: 1, value: 16 },
            },
            GLOBAL_OPTIONS: {
                animate: { label: 'Animate Effects', value: true },
                mirror: { label: 'Mirror Camera', value: true },
                trackCenter: { label: 'Track Face Center', value: true },
                preciseMask: { label: 'Use Face Mask', value: true },
                invertMask: { label: 'Invert Mask', value: false },
            }
        };

        // --- DOM ELEMENTS ---
        const DOM = {
            video: document.getElementById('video'),
            canvas: document.getElementById('glcanvas'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            statusMsg: document.getElementById('statusMsg'),
            errorMsg: document.getElementById('errorMsg'),
            footerStatus: document.getElementById('footerStatus'),
            effectSelector: document.getElementById('effect-selector'),
            dynamicControls: document.getElementById('dynamic-controls'),
            savePresetBtn: document.getElementById('savePresetBtn'),
            deletePresetBtn: document.getElementById('deletePresetBtn'),
            presetNameInput: document.getElementById('presetName'),
            presetList: document.getElementById('presetList'),
            randomBtn: document.getElementById('randomBtn'),
        };

        // --- APPLICATION STATE ---
        let appState = {
            isRunning: false,
            rafId: null,
            lastFmTime: 0,
            fmBusy: false,
            faceMeshReady: false,
            activeEffects: new Set(['Displacement', 'Chroma']),
            controls: {},
            options: {},
            lastFacesMesh: [],
            effectCenter: { x: 0.5, y: 0.5 },
        };

        let webgl = { gl: null, effectProgram: null, displayProgram: null, textures: {}, fbos: {}, buffers: {} };
        let faceMesh = null;
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');

        // --- GLSL SHADERS ---
        const vertSrc = `
            attribute vec2 a_pos;
            varying vec2 v_uv;
            void main() {
                v_uv = a_pos;
                gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
            }`;
        
        // FIX: New, simple shader to just display a texture
        const displayFragSrc = `
            precision highp float;
            varying vec2 v_uv;
            uniform sampler2D u_displayTex;
            void main() {
                gl_FragColor = texture2D(u_displayTex, v_uv);
            }`;

        const effectFragSrc = `
            precision highp float;
            varying vec2 v_uv;

            // --- UNIFORMS ---
            uniform sampler2D u_tex;
            uniform sampler2D u_maskTex;
            uniform sampler2D u_feedbackTex; // Previous frame
            uniform vec2 u_resolution;
            uniform float u_time;
            
            // Global
            uniform float u_speed;
            uniform float u_effectMix;
            
            // Masking
            uniform bool u_useMask;
            uniform bool u_invertMask;
            uniform float u_feather;

            // Effect Flags
            uniform bool u_Feedback_active;
            uniform bool u_DataMosh_active;
            uniform bool u_Displacement_active;
            uniform bool u_Pixelate_active;
            uniform bool u_Glitch_active;
            uniform bool u_SlitScan_active;
            uniform bool u_Chroma_active;

            // Effect Parameters
            uniform float u_feedbackAmount;
            uniform float u_moshAmount;
            uniform float u_nScale, u_nStrength;
            uniform float u_pixelSize;
            uniform float u_blockSize, u_glitchProb;
            uniform float u_slitSize, u_slitSpeed;
            uniform float u_chromaShift;

            // --- HELPERS ---
            float rand(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(mix(rand(i + vec2(0.0, 0.0)), rand(i + vec2(1.0, 0.0)), u.x),
                           mix(rand(i + vec2(0.0, 1.0)), rand(i + vec2(1.0, 1.0)), u.x), u.y);
            }

            // --- MASKING LOGIC ---
            float getMask(vec2 uv) {
                if (!u_useMask) return 1.0;
                float m = texture2D(u_maskTex, uv).r;
                float feather_amount = u_feather / u_resolution.y;
                m = smoothstep(0.5 - feather_amount, 0.5 + feather_amount, m);
                return u_invertMask ? 1.0 - m : m;
            }

            // --- EFFECT FUNCTIONS ---
            vec2 applyDisplacement(vec2 uv) {
                vec2 p = uv * u_nScale + u_time * 0.1 * u_speed;
                vec2 offset = vec2(noise(p), noise(p + vec2(5.2, 1.3))) * 2.0 - 1.0;
                return uv + (offset * u_nStrength / u_resolution);
            }

            vec2 applyPixelate(vec2 uv) {
                vec2 res_factor = u_resolution / u_pixelSize;
                return (floor(uv * res_factor) + 0.5) / res_factor;
            }

            vec2 applyGlitch(vec2 uv) {
                float rows = floor(u_resolution.y / u_blockSize);
                float row_idx = floor(uv.y * rows);
                float t = floor(u_time * (2.0 + u_speed * 10.0));
                if (rand(vec2(row_idx, t)) > u_glitchProb) return uv;
                float shift = (rand(vec2(row_idx, t * 1.3)) - 0.5) * 0.3;
                return uv + vec2(shift, 0.0);
            }

            vec2 applySlitScan(vec2 uv) {
                float slit_y = fract(u_time * 0.1 * u_slitSpeed);
                float slit_h = u_slitSize / u_resolution.y;
                if (abs(uv.y - slit_y) < slit_h) return uv;
                return vec2(uv.x, slit_y);
            }

            vec4 applyChroma(vec2 uv, sampler2D tex) {
                float c = u_chromaShift / u_resolution.x;
                float r = texture2D(tex, uv + vec2(c, 0.0)).r;
                float g = texture2D(tex, uv).g;
                float b = texture2D(tex, uv - vec2(c, 0.0)).b;
                return vec4(r, g, b, 1.0);
            }

            vec4 applyDataMosh(vec4 current_color, vec2 uv, sampler2D feedback_tex) {
                float t = u_time * u_speed;
                vec2 block = floor(uv * vec2(32.0, 24.0));
                float block_noise = rand(block + floor(t * 5.0));
                
                if (block_noise > (1.0 - u_moshAmount)) {
                    vec2 offset = (vec2(rand(block + 1.0), rand(block + 2.0)) - 0.5) * 0.1;
                    return texture2D(feedback_tex, uv + offset);
                }
                return current_color;
            }

            void main() {
                vec4 base_color = texture2D(u_tex, v_uv);
                vec4 feedback_color = texture2D(u_feedbackTex, v_uv);
                
                vec2 effect_uv = v_uv;

                // --- EFFECT STACKING PIPELINE ---
                if (u_Displacement_active) { effect_uv = applyDisplacement(effect_uv); }
                if (u_Pixelate_active) { effect_uv = applyPixelate(effect_uv); }
                if (u_Glitch_active) { effect_uv = applyGlitch(effect_uv); }
                if (u_SlitScan_active) { effect_uv = applySlitScan(effect_uv); }

                vec4 effect_color = texture2D(u_tex, effect_uv);

                if (u_Chroma_active) { effect_color = applyChroma(effect_uv, u_tex); }

                // --- FEEDBACK & DATAMOSH ---
                vec4 final_effect = effect_color;
                if(u_Feedback_active) {
                    final_effect = mix(final_effect, feedback_color, u_feedbackAmount);
                }
                if(u_DataMosh_active) {
                    final_effect = applyDataMosh(final_effect, v_uv, u_feedbackTex);
                }

                // --- MASKING & MIXING ---
                float m = getMask(v_uv);
                vec4 final_color = mix(base_color, final_effect, m * u_effectMix);

                gl_FragColor = final_color;
            }`;

        // --- INITIALIZATION ---
        function init() {
            buildUI();
            addEventListeners();
            populatePresetList();
            setStatus('Ready. Press "Initialize Camera".');
            DOM.loadingIndicator.classList.add('hidden');
        }

        function buildUI() {
            // Build Effect Toggles
            DOM.effectSelector.innerHTML = '';
            for (const name in AppConfig.EFFECTS) {
                const btn = document.createElement('button');
                btn.className = "effect-btn border-2 border-gray-700 bg-gray-800 text-gray-300 text-xs font-semibold py-1 px-2 rounded-md transition-all duration-200";
                btn.textContent = name;
                btn.dataset.effect = name;
                if (appState.activeEffects.has(name)) {
                    btn.classList.add('active', 'border-emerald-500', 'bg-emerald-900/50', 'text-white');
                }
                DOM.effectSelector.appendChild(btn);
            }

            // Build Control Groups
            DOM.dynamicControls.innerHTML = '';
            const controlGroups = { ...AppConfig.EFFECTS, 'Global': { controls: AppConfig.GLOBAL_CONTROLS } };
            
            for (const name in controlGroups) {
                const group = controlGroups[name];
                const isGlobal = name === 'Global';
                
                const groupEl = document.createElement('div');
                groupEl.id = `${name.toLowerCase()}Controls`;
                groupEl.dataset.effect = name;
                groupEl.className = `control-group bg-gray-900/50 p-3 rounded-lg border border-gray-700 ${isGlobal ? 'active' : ''}`;

                let contentHTML = `<h2 class="font-bold text-gray-300 mb-2">${name} Controls</h2><div class="space-y-3">`;
                
                for (const id in group.controls) {
                    const c = group.controls[id];
                    appState.controls[id] = c.value; // Initialize state
                    contentHTML += `
                        <div class="control-item">
                            <div class="flex justify-between items-center text-xs font-mono">
                                <label for="${id}" class="text-gray-400">${c.label}</label>
                                <span id="${id}Val" class="text-emerald-400 font-bold">${parseFloat(c.value).toFixed(c.step < 1 ? 3 : 0)}</span>
                            </div>
                            <input type="range" id="${id}" name="${id}" min="${c.min}" max="${c.max}" step="${c.step}" value="${c.value}" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>`;
                }
                
                // Add global options checkboxes
                if (isGlobal) {
                    contentHTML += `<div class="pt-2 mt-2 border-t border-gray-700 space-y-2">`;
                    for (const id in AppConfig.GLOBAL_OPTIONS) {
                        const o = AppConfig.GLOBAL_OPTIONS[id];
                        appState.options[id] = o.value; // Initialize state
                        contentHTML += `
                            <label class="flex items-center space-x-2 text-sm cursor-pointer">
                                <input type="checkbox" id="${id}" name="${id}" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-emerald-500 focus:ring-emerald-500" ${o.value ? 'checked' : ''}>
                                <span>${o.label}</span>
                            </label>`;
                    }
                    contentHTML += `</div>`;
                }

                contentHTML += `</div>`;
                groupEl.innerHTML = contentHTML;
                DOM.dynamicControls.appendChild(groupEl);
            }
            updateEffectUI();
        }

        function addEventListeners() {
            DOM.startBtn.addEventListener('click', start);
            DOM.stopBtn.addEventListener('click', stop);

            // Control listeners
            DOM.dynamicControls.addEventListener('input', (e) => {
                if (e.target.type === 'range') {
                    const value = parseFloat(e.target.value);
                    appState.controls[e.target.id] = value;
                    document.getElementById(`${e.target.id}Val`).textContent = value.toFixed(e.target.step < 1 ? 3 : 0);
                }
                if (e.target.type === 'checkbox') {
                    appState.options[e.target.id] = e.target.checked;
                }
            });

            // Effect toggles
            DOM.effectSelector.addEventListener('click', (e) => {
                const btn = e.target.closest('.effect-btn');
                if (!btn) return;
                const effectName = btn.dataset.effect;
                if (appState.activeEffects.has(effectName)) {
                    appState.activeEffects.delete(effectName);
                } else {
                    appState.activeEffects.add(effectName);
                }
                updateEffectUI();
            });
            
            // Preset listeners
            DOM.savePresetBtn.addEventListener('click', savePreset);
            DOM.deletePresetBtn.addEventListener('click', deletePreset);
            DOM.presetList.addEventListener('change', loadPreset);
            DOM.randomBtn.addEventListener('click', randomizeAll);

            window.addEventListener('resize', fitCanvas);
        }

        // --- CORE LOGIC (START, STOP, LOOP) ---
        async function start() {
            if (appState.isRunning) return;
            if (!navigator.mediaDevices?.getUserMedia) {
                return setMsg('getUserMedia not supported.', true);
            }
            if (!isSecureContext) {
                return setMsg('Page is not secure (HTTPS). Camera access required.', true);
            }

            try {
                DOM.loadingIndicator.classList.remove('hidden');
                setStatus('Requesting camera access...');
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720, facingMode: 'user' }, audio: false });
                DOM.video.srcObject = stream;
                await DOM.video.play();
                await new Promise(res => { DOM.video.addEventListener('loadedmetadata', res, { once: true }); });

                fitCanvas();
                
                setStatus('Initializing Face Mesh...');
                await initFaceMesh();
                
                setStatus('Initializing WebGL...');
                createGL();
                createFramebuffers();

                appState.isRunning = true;
                DOM.startBtn.disabled = true;
                DOM.stopBtn.disabled = false;
                DOM.loadingIndicator.classList.add('hidden');
                setMsg('');

                loop();
            } catch (err) {
                console.error(err);
                let hint = (err.name === 'NotAllowedError') ? 'Permission was blocked.' : '';
                setMsg(`Could not start camera: ${err.message} ${hint}`, true);
                setStatus('Error');
                DOM.loadingIndicator.classList.add('hidden');
            }
        }

        function stop() {
            if (!appState.isRunning) return;
            if (appState.rafId) cancelAnimationFrame(appState.rafId);
            
            if (DOM.video.srcObject) {
                DOM.video.srcObject.getTracks().forEach(t => t.stop());
                DOM.video.srcObject = null;
            }
            
            appState.isRunning = false;
            DOM.startBtn.disabled = false;
            DOM.stopBtn.disabled = true;
            setStatus('Stopped');
        }

        function loop(timestamp) {
            if (!appState.isRunning) return;
            appState.rafId = requestAnimationFrame(loop);

            // Face tracking throttling
            if (appState.faceMeshReady && !appState.fmBusy && (timestamp - appState.lastFmTime) > AppConfig.FACE_MESH_MIN_INTERVAL) {
                appState.fmBusy = true;
                appState.lastFmTime = timestamp;
                faceMesh.send({ image: DOM.video }).finally(() => { appState.fmBusy = false; });
            }

            draw();
        }

        // --- RENDERING & WEBGL ---
        function draw() {
            const gl = webgl.gl;
            if (!gl || DOM.canvas.width === 0) return;

            // --- Update Textures and Masks ---
            if (appState.options.preciseMask) {
                drawMaskFromMesh();
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, webgl.textures.mask);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, maskCanvas);
            }
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, webgl.textures.video);
            try {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, DOM.video);
            } catch (e) {
                if (!(e instanceof DOMException)) console.error(e);
                return;
            }

            // --- Render Pass 1: Draw effects to FBO A ---
            gl.useProgram(webgl.effectProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, webgl.fbos.A.framebuffer);
            gl.viewport(0, 0, DOM.canvas.width, DOM.canvas.height);

            // Set textures for effect shader
            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_2D, webgl.fbos.B.texture); // Read from previous frame
            gl.uniform1i(webgl.effectProgram.uniforms.u_feedbackTex, 2);
            gl.uniform1i(webgl.effectProgram.uniforms.u_tex, 0);
            gl.uniform1i(webgl.effectProgram.uniforms.u_maskTex, 1);
            
            // Set all uniforms for the effect shader
            const t = appState.options.animate ? performance.now() / 1000 : 0;
            gl.uniform1f(webgl.effectProgram.uniforms.u_time, t);
            gl.uniform2f(webgl.effectProgram.uniforms.u_resolution, DOM.canvas.width, DOM.canvas.height);
            for(const key in AppConfig.GLOBAL_CONTROLS) { gl.uniform1f(webgl.effectProgram.uniforms[`u_${key}`], appState.controls[key]); }
            gl.uniform1i(webgl.effectProgram.uniforms.u_useMask, appState.options.preciseMask);
            gl.uniform1i(webgl.effectProgram.uniforms.u_invertMask, appState.options.invertMask);
            for (const effectName in AppConfig.EFFECTS) {
                gl.uniform1i(webgl.effectProgram.uniforms[`u_${effectName}_active`], appState.activeEffects.has(effectName));
                for (const controlId in AppConfig.EFFECTS[effectName].controls) {
                    gl.uniform1f(webgl.effectProgram.uniforms[`u_${controlId}`], appState.controls[controlId]);
                }
            }

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // --- Render Pass 2: Draw FBO A to screen ---
            gl.useProgram(webgl.displayProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, DOM.canvas.width, DOM.canvas.height);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, webgl.fbos.A.texture); // Read from the FBO we just drew to
            gl.uniform1i(webgl.displayProgram.uniforms.u_displayTex, 0);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // --- Swap FBOs for next frame ---
            [webgl.fbos.A, webgl.fbos.B] = [webgl.fbos.B, webgl.fbos.A];

            // Update status
            setFooterStatus(`${appState.lastFacesMesh.length > 0 ? 'FACE DETECTED' : 'NO FACE'} | ${DOM.canvas.width}x${DOM.canvas.height}`);
        }

        function createGL() {
            webgl.gl = DOM.canvas.getContext('webgl', { premultipliedAlpha: false, antialias: true });
            if (!webgl.gl) throw new Error('WebGL not available');
            const gl = webgl.gl;
            
            const vs = compileShader(gl.VERTEX_SHADER, vertSrc);
            const effectFs = compileShader(gl.FRAGMENT_SHADER, effectFragSrc);
            const displayFs = compileShader(gl.FRAGMENT_SHADER, displayFragSrc);

            webgl.effectProgram = createProgram(vs, effectFs);
            webgl.displayProgram = createProgram(vs, displayFs);
            
            webgl.buffers.position = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, webgl.buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), gl.STATIC_DRAW);
            
            const a_pos = gl.getAttribLocation(webgl.effectProgram, 'a_pos');
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            webgl.textures.video = createTexture();
            webgl.textures.mask = createTexture();

            // Cache all uniform locations for both programs
            webgl.effectProgram.uniforms = {};
            const uniformRegex = /uniform\s+\w+\s+u_(\w+)/g;
            let match;
            while((match = uniformRegex.exec(effectFragSrc)) !== null) {
                webgl.effectProgram.uniforms[match[1]] = gl.getUniformLocation(webgl.effectProgram, `u_${match[1]}`);
            }
            webgl.displayProgram.uniforms = {
                u_displayTex: gl.getUniformLocation(webgl.displayProgram, 'u_displayTex')
            };
        }
        
        function createFramebuffers() {
            webgl.fbos.A = createFramebuffer();
            webgl.fbos.B = createFramebuffer();
        }

        function createFramebuffer() {
            const gl = webgl.gl;
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            
            const texture = createTexture();
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, DOM.canvas.width, DOM.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return { framebuffer: fbo, texture: texture };
        }

        function createTexture() {
            const gl = webgl.gl;
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            return tex;
        }
        
        function compileShader(type, src) {
            const gl = webgl.gl;
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(s) || 'Shader compile failed');
            }
            return s;
        }

        function createProgram(vs, fs) {
            const gl = webgl.gl;
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.attachShader(p, fs);
            gl.linkProgram(p);
            if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(p) || 'Program link failed');
            }
            return p;
        }

        // --- FACE MESH & MASKING ---
        async function initFaceMesh() {
            if (appState.faceMeshReady) return;
            if (typeof window.FaceMesh === 'undefined') {
                await new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
                    s.crossOrigin = "anonymous";
                    s.onload = resolve;
                    s.onerror = () => reject(new Error('Failed to load MediaPipe FaceMesh'));
                    document.head.appendChild(s);
                });
            }
            faceMesh = new window.FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });
            faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            faceMesh.onResults(onFaceMeshResults);
            await faceMesh.initialize();
            appState.faceMeshReady = true;
        }

        function onFaceMeshResults(res) {
            appState.lastFacesMesh = res.multiFaceLandmarks ? res.multiFaceLandmarks.map(lm => lm.map(p => ({ x: p.x, y: p.y }))) : [];
            if (appState.options.trackCenter && appState.lastFacesMesh.length > 0) {
                const lm = appState.lastFacesMesh[0];
                const center = lm.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                center.x /= lm.length;
                center.y /= lm.length;
                
                if (appState.options.mirror) center.x = 1.0 - center.x;
                center.y = 1.0 - center.y; // WebGL Y-coord is flipped
                appState.effectCenter = center;
            }
        }

        function drawMaskFromMesh() {
            const W = maskCanvas.width, H = maskCanvas.height;
            maskCtx.save();
            maskCtx.clearRect(0, 0, W, H);
            if (appState.options.mirror) {
                maskCtx.translate(W, 0);
                maskCtx.scale(-1, 1);
            }
            maskCtx.fillStyle = '#fff';
            maskCtx.beginPath();
            
            if (appState.lastFacesMesh.length > 0) {
                const lm = appState.lastFacesMesh[0];
                if (!lm || lm.length < 468) { maskCtx.restore(); return; }

                const FACE_OVAL = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
                
                const padding = appState.controls.pad;
                const bbox = lm.reduce((box, p) => ({
                    minX: Math.min(box.minX, p.x * W), minY: Math.min(box.minY, p.y * H),
                    maxX: Math.max(box.maxX, p.x * W), maxY: Math.max(box.maxY, p.y * H),
                }), { minX: W, minY: H, maxX: 0, maxY: 0 });
                const centerX = (bbox.minX + bbox.maxX) / 2;
                const centerY = (bbox.minY + bbox.maxY) / 2;

                const p0 = lm[FACE_OVAL[0]];
                maskCtx.moveTo(centerX + (p0.x * W - centerX) * (1 + padding / 100), centerY + (p0.y * H - centerY) * (1 + padding / 100));
                for (let i = 1; i < FACE_OVAL.length; i++) {
                    const p = lm[FACE_OVAL[i]];
                    maskCtx.lineTo(centerX + (p.x * W - centerX) * (1 + padding / 100), centerY + (p.y * H - centerY) * (1 + padding / 100));
                }
                maskCtx.closePath();
            }
            maskCtx.fill();
            maskCtx.restore();
        }

        // --- UI & STATE MANAGEMENT ---
        function updateEffectUI() {
            document.querySelectorAll('.effect-btn').forEach(btn => {
                const effectName = btn.dataset.effect;
                const isActive = appState.activeEffects.has(effectName);
                btn.classList.toggle('active', isActive);
                btn.classList.toggle('border-emerald-500', isActive);
                btn.classList.toggle('bg-emerald-900/50', isActive);
                btn.classList.toggle('text-white', isActive);
                btn.classList.toggle('border-gray-700', !isActive);
                btn.classList.toggle('bg-gray-800', !isActive);
                btn.classList.toggle('text-gray-300', !isActive);
                
                const controlPanel = document.getElementById(`${effectName.toLowerCase()}Controls`);
                if (controlPanel) {
                    controlPanel.style.display = isActive ? 'block' : 'none';
                }
            });
        }
        
        function syncUIToState() {
            for(const key in appState.controls) {
                const el = document.getElementById(key);
                if (el) {
                    el.value = appState.controls[key];
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
            for(const key in appState.options) {
                const el = document.getElementById(key);
                if (el) el.checked = appState.options[key];
            }
            updateEffectUI();
        }

        function fitCanvas() {
            if (!DOM.video.videoWidth) return;
            const w = DOM.video.videoWidth;
            const h = DOM.video.videoHeight;
            DOM.canvas.width = w;
            DOM.canvas.height = h;
            maskCanvas.width = w;
            maskCanvas.height = h;
            if (webgl.gl) {
                webgl.gl.viewport(0, 0, w, h);
                // Re-create FBOs with new size
                if (appState.isRunning) createFramebuffers();
            }
        }

        function setStatus(text) { DOM.statusMsg.textContent = text; }
        function setFooterStatus(text) { DOM.footerStatus.textContent = text; }
        function setMsg(text, isError = false) {
            DOM.errorMsg.textContent = text || '';
            DOM.errorMsg.classList.toggle('text-red-400', isError);
        }

        // --- PRESET LOGIC ---
        function getPresets() { return JSON.parse(localStorage.getItem('unknownSignalPresets') || '{}'); }
        function savePresets(presets) { localStorage.setItem('unknownSignalPresets', JSON.stringify(presets)); }

        function savePreset() {
            const name = DOM.presetNameInput.value.trim();
            if (!name) return setMsg('Please enter a preset name.', true);
            const presets = getPresets();
            presets[name] = {
                controls: { ...appState.controls },
                options: { ...appState.options },
                effects: Array.from(appState.activeEffects)
            };
            savePresets(presets);
            populatePresetList();
            DOM.presetList.value = name;
            setMsg(`Preset '${name}' saved.`);
        }
        
        function deletePreset() {
            const name = DOM.presetList.value;
            if (!name) return setMsg('Select a preset to delete.', true);
            const presets = getPresets();
            delete presets[name];
            savePresets(presets);
            populatePresetList();
            setMsg(`Preset '${name}' deleted.`);
        }

        function loadPreset() {
            const name = DOM.presetList.value;
            if (!name) return;
            const presets = getPresets();
            if (presets[name]) {
                const p = presets[name];
                appState.controls = p.controls;
                appState.options = p.options;
                appState.activeEffects = new Set(p.effects);
                syncUIToState();
                DOM.presetNameInput.value = name;
                setMsg(`Preset '${name}' loaded.`);
            }
        }

        function populatePresetList() {
            const presets = getPresets();
            DOM.presetList.innerHTML = '<option value="">Load Preset...</option>';
            for (const name in presets) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                DOM.presetList.appendChild(opt);
            }
        }

        function randomizeAll() {
            // Randomize controls
            for (const id in appState.controls) {
                const el = document.getElementById(id);
                if(el) {
                    const min = parseFloat(el.min);
                    const max = parseFloat(el.max);
                    const step = parseFloat(el.step) || 1;
                    const val = min + Math.random() * (max - min);
                    el.value = Math.round(val / step) * step;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
            // Randomize options
            for (const id in appState.options) {
                const el = document.getElementById(id);
                if (el) el.checked = Math.random() > 0.5;
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
            // Randomize active effects
            appState.activeEffects.clear();
            const effectNames = Object.keys(AppConfig.EFFECTS);
            effectNames.forEach(name => {
                if (Math.random() > 0.6) appState.activeEffects.add(name);
            });
            if (appState.activeEffects.size === 0) {
                appState.activeEffects.add(effectNames[Math.floor(Math.random() * effectNames.length)]);
            }
            updateEffectUI();
            setMsg('Parameters randomized!');
        }

        // --- AUTO-START & RUN ---
        init();
        (async () => {
            try {
                const p = await navigator.permissions.query({ name: 'camera' });
                if (p.state === 'granted') start();
            } catch (e) {
                console.warn("Camera permission query failed, user must click to start.", e);
            }
        })();

    })();
    </script>
</body>
</html>
